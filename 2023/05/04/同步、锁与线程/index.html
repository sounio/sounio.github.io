<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="###AbstractQueuedSynchronizer AQS是一个基于先进先出等待队列来实现阻塞锁和相关同步器的框架。 AQS作为基础类，主要解决了在锁不能获取的情况下的等待，以及锁释放后的唤起。锁状态的定义，如何获取锁以及如何释放锁，都是需要相应的同步机制自己实现的。 什么情况下会用到：在日常的编程中我们经常会碰到并发的情况。有并发，就有资源共享；有资源共享就需要处理资源同步访问。处理同步">
<meta property="og:type" content="article">
<meta property="og:title" content="同步的一些内容">
<meta property="og:url" content="https://sounio.github.io/2023/05/04/%E5%90%8C%E6%AD%A5%E3%80%81%E9%94%81%E4%B8%8E%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Sounio">
<meta property="og:description" content="###AbstractQueuedSynchronizer AQS是一个基于先进先出等待队列来实现阻塞锁和相关同步器的框架。 AQS作为基础类，主要解决了在锁不能获取的情况下的等待，以及锁释放后的唤起。锁状态的定义，如何获取锁以及如何释放锁，都是需要相应的同步机制自己实现的。 什么情况下会用到：在日常的编程中我们经常会碰到并发的情况。有并发，就有资源共享；有资源共享就需要处理资源同步访问。处理同步">
<meta property="og:locale">
<meta property="og:image" content="https://pics7.baidu.com/feed/42a98226cffc1e17c1dd2eb13ee85d0b728de955.png@f_auto?token=119485b520bd32fb495070b2b10de00a">
<meta property="og:image" content="https://pics6.baidu.com/feed/a686c9177f3e6709581b64d256bf3435f8dc5500.png@f_auto?token=1d12d8cf05396c6754a46ea388cb64d8">
<meta property="og:image" content="https://pics2.baidu.com/feed/2fdda3cc7cd98d10f8dd53e64d4713067aec9059.png@f_auto?token=5888e9e64916dbe648c26b01794cd812">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/0894ed62c588d7ad6dbd4640d407e356.png">
<meta property="og:image" content="https://camo.githubusercontent.com/8224f690269cfcd9af6899b48f681e098b42c4adfda3a5c6527990f97ee4631f/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545372542412542462545372541382538422545362542312541302545352538462538322545362539352542302545352538352542332545372542332542422d4a676a6c57552e706e67">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/801f9038979ba89405141affda430217.png">
<meta property="article:published_time" content="2023-05-04T06:32:19.000Z">
<meta property="article:modified_time" content="2023-06-08T14:08:31.795Z">
<meta property="article:author" content="sounio">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pics7.baidu.com/feed/42a98226cffc1e17c1dd2eb13ee85d0b728de955.png@f_auto?token=119485b520bd32fb495070b2b10de00a">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sounio.github.io/2023/05/04/同步、锁与线程/"/>





  <title>同步的一些内容 | Sounio</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sounio</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sounio.github.io/2023/05/04/%E5%90%8C%E6%AD%A5%E3%80%81%E9%94%81%E4%B8%8E%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sounio">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">同步的一些内容</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-05-04T14:32:19+08:00">
                2023-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>###AbstractQueuedSynchronizer</p>
<p>AQS是一个基于先进先出等待队列来实现阻塞锁和相关同步器的框架。</p>
<p>AQS作为基础类，主要解决了在<u>锁不能获取的情况下的等待，以及锁释放后的唤起</u>。锁状态的定义，如何获取锁以及如何释放锁，都是需要相应的同步机制自己实现的。</p>
<p>什么情况下会用到：在日常的编程中我们经常会碰到并发的情况。有并发，就有资源共享；有资源共享就需要处理资源同步访问。处理同步的时候，就要处理<u><strong>竞争发生时候的等待问题</strong></u>以及<u><strong>竞争解除后的唤起的问题</strong></u>。AQS就是一个便于我们实现这种同步机制的框架。我们日常中使用到的ReentrantLock、ReentrantReadWriteLock以及ArrayBlockingQueue等都是基于AQS实现的。</p>
<p>主要实现方法：</p>
<ul>
<li>tryAcquire()，获取排他锁</li>
<li>tryRelease()，释放排他锁</li>
<li>tryAcquireShared()，获取共享锁</li>
<li>tryReleaseShared()，释放共享锁</li>
<li>isHeldExclusively()，是不是持有排他锁</li>
</ul>
<p>使用state来标识锁的状态，state &#x3D; 0表示锁没有被获取，当state &gt; 0表示锁已经被获取了。</p>
<p>AQS流程：<code>AQS</code>为加锁和解锁过程提供了统一的模板函数，加锁与解锁的模板流程是，获取锁失败的线程，会进入<code>CLH</code>队列阻塞，其他线程解锁会唤醒<code>CLH</code>队列线程，如下图所示（简化流程）</p>
<p><img src="https://pics7.baidu.com/feed/42a98226cffc1e17c1dd2eb13ee85d0b728de955.png@f_auto?token=119485b520bd32fb495070b2b10de00a" alt="img"></p>
<p>上图中，线程释放锁时，会唤醒<code>CLH</code>队列阻塞的线程，重新竞争锁，要注意，此时可能还有非<code>CLH</code>队列的线程参与竞争，所以非公平就体现在这里，非<code>CLH</code>队列线程与<code>CLH</code>队列线程竞争，各凭本事，不会因为你是<code>CLH</code>队列的线程，排了很久的队，就把锁让给你。</p>
<p>###ReentrantLock</p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1702822534980452383&wfr=spider&for=pc">通俗易懂的ReentrantLock (baidu.com)</a></p>
<p><code>ReentrantLock</code>是可重入的互斥锁，虽然具有与<code>synchronized</code>相同功能，但是会比<code>synchronized</code>更加灵活（<strong>具有更多的方法</strong>）。</p>
<p><code>ReentrantLock</code>底层基于<code>AbstractQueuedSynchronizer</code>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span>;</span><br><span class="line"><span class="comment">//Sync继承AbstractQueuedSynchronizer提供释放资源的实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在<code>ReentrantLock</code>中，它对<code>AbstractQueuedSynchronizer</code>的<code>state</code>状态值定义为线程获取该锁的重入次数，<code>state</code>状态值为<code>0</code>表示当前没有被任何线程持有，<code>state</code>状态值为<code>1</code>表示被其他线程持有，因为支持可重入，如果是持有锁的线程，再次获取同一把锁，直接成功，并且<code>state</code>状态值<code>+1</code>，线程释放锁<code>state</code>状态值<code>-1</code>，同理重入多次锁的线程，需要释放相应的次数。</p>
<p>非公平锁：</p>
<p><img src="https://pics6.baidu.com/feed/a686c9177f3e6709581b64d256bf3435f8dc5500.png@f_auto?token=1d12d8cf05396c6754a46ea388cb64d8" alt="img"></p>
<p>公平锁：</p>
<p><img src="https://pics2.baidu.com/feed/2fdda3cc7cd98d10f8dd53e64d4713067aec9059.png@f_auto?token=5888e9e64916dbe648c26b01794cd812" alt="img"></p>
<p>使用<code>独占方式</code>获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源，就会标记是这个线程获取到了，其他线程再尝试操作state获取资源时会发现当前该资源不是自己持有的，就会在获取失败后被阻塞。</p>
<p>对应的<code>共享方式</code>的资源与具体线程是不相关的，当多个线程去请求资源时通过CAS方式竞争获取资源，当一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源还能满足它的资源，则当前线程只需要使用CAS方式进行获取即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryAcquire 具体的子类去实现，并维护state的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 如果失败标记状态，入队</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryRelease 具体的子类是实现，并设置state的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 调用unpark唤醒队列的线程，并调用tryAcquire尝试，看是否需要，如果不需要，继续挂起</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关于ReentrantLock可重入性的实现"><a href="#关于ReentrantLock可重入性的实现" class="headerlink" title="关于ReentrantLock可重入性的实现"></a>关于ReentrantLock可重入性的实现</h4><p>ReentrantLock具备可重入的能力，即同一个线程多次获取锁，不引起阻塞。</p>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁。</p>
<p><strong>设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</strong></p>
<p>###乐观锁与悲观锁</p>
<p>####互斥锁</p>
<p>多个线程访问一个对象的时候，会想到使用互斥锁进行协调，互斥锁是一个<strong>悲观</strong>锁，也就是操作系统会认为，<strong>如果不严格的同步线程调用，那么一定会产生异常</strong>，所以这里进行锁定，是的对象只供一个线程调用。</p>
<p>缺陷：1.可能大部分请求都是读操作，不需要上锁。</p>
<p>​	2.可能同步代码块执行的耗时远远小于线程切换的耗时。</p>
<p>####CAS</p>
<p>需要实现原子性，各个架构都提供了CAS原子性的实现方法，可以直接让CPU实现，不用锁来实现线程同步。</p>
<p>所谓CSA 就是线程调用的时候先判断old值是不是符合期望，如果符合就修改，这时另外的线程来访问就需要进行自旋(次数可配置，默认10,<strong>自旋不需要加载上下文</strong>)，等到这个线程结束。这里就是所谓的<strong>乐观锁</strong>，其实乐观锁不是一种锁，是靠原子性实现的一种<strong>无锁同步机制</strong>，只是名字相对于悲观锁被沿用了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0894ed62c588d7ad6dbd4640d407e356.png" alt="img"></p>
<p>####偏向锁</p>
<p><strong>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价</strong>（偏向于这个线程）</p>
<p>适用场景：始终只有一个线程在执行代码块，在它没有执行完释放锁之前，没有其它线程去执行同步快，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁, 导致stop the word操作，有锁竞争时会降低效率，应当禁用。</p>
<p>####轻量级锁</p>
<p><strong>轻量级锁是指当锁是偏向锁的时候，被另一个线程锁访问，偏向锁就会升级为轻量级锁，其他线程会通过自选的形式尝试获取锁，不会阻塞，提高性能。</strong></p>
<p>####重量级锁</p>
<p><strong>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</strong></p>
<p>###公平锁与非公平锁</p>
<p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p>
<p>优点：所有的线程都能得到资源，不会饿死在队列中。<br>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</p>
<p>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p>
<p>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。<br>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</p>
<h3 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h3><ul>
<li><strong>共享锁：</strong>对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后。</li>
<li><strong>排他锁：</strong>对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作。</li>
</ul>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><strong>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</strong></p>
<p><strong>如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适用使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cpu的线程又不能获取到cpu，造成cpu的浪费。</strong></p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>简单点说就是确保读的时候读到的是最新值，保证线程可见性。</p>
<p>两个特性：<code>内存可见性</code>、<code>禁止重排序</code></p>
<p>禁止重排序：<strong>不管是编译器还是JVM还是CPU，都会对一些指令进行重排序，目的是为了提高程序运行的速度，提高程序的性能，毫无疑问，在单线程下没毛病，多线程就似乎生病了。</strong></p>
<p>volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层是基于<code>内存屏障</code>实现的。</p>
<ul>
<li>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</li>
<li>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步，所以就不会有可见性问题。<ul>
<li>对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；</li>
<li>对 volatile 变量进行读操作时，会在写操作后加一条 load 屏障指令，从主内存中读取共享变量；</li>
</ul>
</li>
</ul>
<p>很难做出准确、全面的评价，例如 “X 总是比 Y 快”，尤其是对 JVM 内在的操作而言。（例如，某些情况下 JVM 也许能够完全删除锁机制，这使得我们难以抽象地比较 <code>volatile</code> 和 <code>synchronized</code> 的开销。）就是说，在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。</p>
<p>关于禁止重排序的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来一波双重校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Test</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;				<span class="comment">// 多了一层判断，不让每次进来都阻塞，提高了性能</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// instance类变量前面修饰的volatile？是吧？</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    <span class="comment">//1. 分配对象的内存空间 </span></span><br><span class="line">ctorInstance(memory);  <span class="comment">//2. 初始化对象 </span></span><br><span class="line">instance = memory;     <span class="comment">//3. 设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>

<p>上面三个指令中，步骤2依赖步骤1，但是步骤3不依赖步骤2，所以JVM可能针对他们进行指令重拍序优化，重排后的指令如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    <span class="comment">//1. 分配对象的内存空间 </span></span><br><span class="line">instance = memory;     <span class="comment">//3. 设置instance指向刚分配的内存地址</span></span><br><span class="line">ctorInstance(memory);  <span class="comment">//2. 初始化对象 </span></span><br></pre></td></tr></table></figure>

<p>这样优化之后，内存的初始化被放到了instance分配内存地址的后面，这样的话当线程1执行步骤3这段赋值指令后，刚好有另外一个线程2进入getInstance方法判断instance不为null，这个时候线程2拿到的instance对应的内存其实还未初始化，这个时候拿去使用就会导致出错。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>假如想实现<u><strong>每一个线程都有自己的专属本地变量</strong></u>该如何解决呢？ JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。</p>
<p>ThreadLocal叫做<em><strong>线程变量</strong></em>，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是<strong>隔离</strong>的，也就是说该变量是当前线程独有的变量，<code>不存在多线程间共享的问题</code>。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即<code>变量在线程间隔离而在方法或类间共享的场景</code>。</p>
<p>一句话理解ThreadLocal，threadlocl是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry<code>（threadlocl,value）</code>，虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在<strong>同一个线程中这个value变量地址是一样</strong>的。</p>
<p>使用时可以使用<code>get（）</code>和<code>set（）</code>方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>####关于ThreadLocal的内存泄漏</p>
<p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的<code>弱</code>引用,而 value 是<code>强</code>引用。如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。</p>
<p>ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用<code>remove()</code>方法。</p>
<p>###Synchonized</p>
<p>synchronized的用处是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p>
<p>synchronized的作用主要有三个：</p>
<ol>
<li>原子性：确保线程<code>互斥地访问</code>同步代码；</li>
<li>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操	作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要<code>重新从主内存</code>中load操作或assign操作初始化变量值” 来保证的；</li>
<li>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；</li>
</ol>
<p>synchronized的3种使用方式：</p>
<ul>
<li>修饰实例方法：作用于当前实例加锁</li>
<li>修饰静态方法：作用于当前类对象加锁</li>
<li>修饰代码块：指定加锁对象，对给定对象加锁</li>
</ul>
<p>synchronized关键字不能继承，当然子类调用父类同步方法也是同步的。</p>
<p>synchronized在JVM里的实现都是基于进入和退出<code>Monitor对象</code>来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<p><code>MonitorEnter</code>指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；</p>
<p><code>MonitorExit</code>指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；</p>
<p>什么是Monitor？可以把它理解为 一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</p>
<p>###ThreadLocal与Synchronized的区别</p>
<p>ThreadLocal和Synchonized都用于解决多线程并发访问。</p>
<p>但是ThreadLocal与synchronized有本质的区别：</p>
<p>1、Synchronized用于线程间的数据<code>共享</code>，而ThreadLocal则用于线程间的数据<code>隔离</code>。</p>
<p>2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的<code>副本</code>，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享,而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据<code>共享</code>。</p>
<p>###ReentrantReadWriteLock</p>
<p>ReentrantReadWriteLock称为读写锁，它提供一个<code>读锁</code>，支持<code>多个线程共享同一把锁</code>。它也提供了一把<code>写锁</code>，是<code>独占锁</code>，和其他读锁或者写锁互斥，表明只有一个线程能持有锁资源。通过两把锁的协同工作，能够最大化的提高读写的性能，特别是读多写少的场景，而往往大部分的场景都是读多写少的。</p>
<h4 id="可重入性的实现"><a href="#可重入性的实现" class="headerlink" title="可重入性的实现"></a>可重入性的实现</h4><p>这个问题需要引入两个概念，<code>锁升级</code>，<code>锁降级</code>。</p>
<ul>
<li>锁升级：从读锁变成写锁。</li>
<li>锁降级：从写锁变成读锁。</li>
</ul>
<p>重入时锁升级不支持：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</p>
<p>重入时锁降级支持：持有写锁的情况下去获取读锁，造成只有当前线程会持有读锁，因为写锁会互斥其他的锁</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>缓存：缓存更新时，是先清缓存还是先更新数据库？</p>
<p>先清缓存：可能造成<code>刚清理缓存还没有更新数据库</code>，高并发下，<code>其他线程</code>直接<code>查询了数据库过期数据到缓存中</code>，这种情况非常严重，直接导致<code>后续所有的请求缓存和数据库不一致</code>。<br>先更新据库：可能造成<code>刚更新数据库，还没清空缓存就有线程从缓存拿到了旧数据</code>，这种情况概率比较小，影响范围有限，只对这一次的查询结果有问题。</p>
<p>显而易见，通常情况下，<code>先更新数据库，然后清空缓存</code>。</p>
<p>###线程</p>
<h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p>结论：t.join()方法会使所有线程都暂停并等待t的执行完毕后再执行</p>
<p>实现: join之所以可以实现线程等待是因为调用wait方法。而wait方法会让<strong>当前线程</strong>陷入等待。注意，是<strong>当前线程</strong>！在执行tA.join()这句代码的时候，当前线程是main主线程。在tA.join()当中的wait(0)方法是让<code>main线程陷入了无尽的等待</code>中。正是因为如此，在tA.join()之前的代码都会正常从上往下执行，而在tA.join()之后的代码都随着main线程陷入等待而无法继续执行。这样便达到了网上说的 “t.join()方法会使所有线程都暂停并等待t的执行完毕后再执行”。同时<code>线程在die的时候会自动调用自身的notifyAll方法，来释放所有因为该锁陷入等待的资源和锁</code>。</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>场景</p>
<p>在主线程中开启多个线程去<code>并行</code>任务，并且<code>主线程</code>需要<code>等待所有子线程执行完毕</code>后再进行汇总的场景.</p>
<p>原理</p>
<p>首先状态变量state：state用来表示计数器当前的值，当线程调用CountDownLatch对象的await方法后，当前线程会被阻塞，直到下面的情况之一发生才返回：</p>
<p>当所有线程都调用了CountDownLatch对象的countDown(减去计数器的值)方法后，也就是计数器的值为0时：其他线程调用了当前线程的interrupt()方法中断了当前线程，当前线程就会抛出InterruptedException异常。</p>
<h4 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h4><p>一种在物理处理器上实现多线程执行的技术。也就是让每一个处理器核心模拟多个处理器,使得一个处理器可以同时执行多个线程.</p>
<h4 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h4><p>虚拟线程是一种编程模型或操作系统的概念，用于实现并发执行和任务调度</p>
<h3 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h3><p><strong>Java锁机制可归为Sychornized锁和Lock锁两类。Synchronized是基于JVM来保证数据同步的，而Lock则是硬件层面，依赖特殊的CPU指令来实现数据同步的。</strong></p>
<ul>
<li>Synchronized是一个非公平、悲观、独享、互斥、可重入的重量级锁。</li>
<li>ReentrantLock是一个默认非公平但可实现公平的、悲观、独享、互斥、可重入、重量级锁。</li>
<li>ReentrantReadWriteLock是一个默认非公平但可实现公平的、悲观、写独享、读共享、读写、可重入、重量级锁。</li>
</ul>
<h3 id="线程池（高频）"><a href="#线程池（高频）" class="headerlink" title="线程池（高频）"></a>线程池（高频）</h3><p>为什么使用线程池？</p>
<ul>
<li><strong>降低资源消耗</strong>。通过<code>重复利用</code>已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以<code>不需要等到线程创建</code>就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是<code>稀缺资源</code>，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>有哪些线程池？</p>
<p><strong>newFixedThreadPool</strong>（固定线程池）、<strong>newSingleThreadExecutor</strong>（单个线程的线程池）、<strong>newCachedThreadPool</strong>（缓存线程的线程池）、<strong>newScheduledThreadPool</strong>（带定时器的线程池）</p>
<p>####线程池参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize：核心线程数线程数定义了<code>最小可以同时运行</code>的线程数量</li>
<li>maximumPoolSize：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为<code>最大线程数</code></li>
<li>keepAliveTime：当线程数大于<code>核心线程数</code>时，多余的<code>空闲线程存活的最长时间</code></li>
<li>TimeUnit：时间单位</li>
<li>BlockingQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li>
<li>ThreadFactory：线程工厂，用来创建线程，一般默认即可</li>
<li>RejectedExecutionHandler：拒绝策略</li>
</ul>
<p><img src="https://camo.githubusercontent.com/8224f690269cfcd9af6899b48f681e098b42c4adfda3a5c6527990f97ee4631f/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545372542412542462545372541382538422545362542312541302545352538462538322545362539352542302545352538352542332545372542332542422d4a676a6c57552e706e67" alt="线程池参数关系"></p>
<h4 id="核心线程和普通线程的区别"><a href="#核心线程和普通线程的区别" class="headerlink" title="核心线程和普通线程的区别"></a>核心线程和普通线程的区别</h4><ul>
<li><strong>创建和销毁</strong>：核心线程在线程池<code>初始化时就会创建</code>，并且不会被销毁；普通线程在需要处理任务时动态创建，并在任务执行完毕后根据空闲时间和线程池配置决定是否<code>销毁</code>。</li>
<li><strong>空闲处理</strong>：核心线程处于空闲状态时不会被销毁，保持线程池的基本线程数量；普通线程在空闲一定时间后，根据线程池配置和策略决定是否销毁，以控制线程池的大小。</li>
<li><strong>任务处理</strong>：核心线程主要用于处理短时间的任务，保证任务能够得到及时处理；普通线程用于处理任务数量超过核心线程数的情况，根据任务的到达率动态调整线程池的大小。</li>
</ul>
<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><ul>
<li>AbortPolicy：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li>CallerRunsPolicy：调用执行自己的线程运行任务(主线程同时处理自己的任务和该任务)。但是这种策略会<code>降低</code>对于新任务<code>提交速度</code>，<code>影响</code>程序的<code>整体性能</code>。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你任务<code>不能丢弃任何一个任务请求</code>的话，你可以选择这个策略。（说白了，谁管理任务的，谁就负责帮忙）</li>
<li>DiscardPolicy：不处理新任务，直接丢弃掉。</li>
<li>DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h4 id="线程池线程数量"><a href="#线程池线程数量" class="headerlink" title="线程池线程数量"></a>线程池线程数量</h4><p>如何确定？</p>
<ol>
<li>一般来说，如果是CPU密集型应用，则线程池大小设置为N+1。（N是CPU的核心数）</li>
<li>一般来说，如果是IO密集型应用，则线程池大小设置为2N+1。</li>
<li>在IO优化中，线程等待时间（IO时间）所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越少线程。这样的估算公式可能更适合：最佳线程数目 &#x3D; （（线程等待时间+线程CPU时间）&#x2F;线程CPU时间 ）* CPU数目</li>
</ol>
<h4 id="线程池中线程的状态"><a href="#线程池中线程的状态" class="headerlink" title="线程池中线程的状态"></a>线程池中线程的状态</h4><p>线程池中的线程可以处于不同的状态，常见的线程状态包括：</p>
<ol>
<li><strong>New（新建）</strong>：线程被<code>创建</code>但还未开始执行。</li>
<li><strong>Runnable（可运行）</strong>：线程处于<code>就绪</code>状态，等待分配CPU时间片来执行。在可运行状态下，线程可能正在执行，也可能正在等待执行。</li>
<li><strong>Blocked（阻塞）</strong>：线程被<code>阻塞</code>，无法继续执行。常见的阻塞原因包括等待锁、等待输入&#x2F;输出、等待其他线程通知等。</li>
<li><strong>Waiting（等待）</strong>：线程处于<code>等待</code>状态，等待其他线程的特定条件满足。进入等待状态的线程需要其他线程的显式通知来唤醒。</li>
<li><strong>Timed Waiting（计时等待）</strong>：线程处于计时等待状态，等待一定的时间或者等待特定的条件满足。</li>
<li><strong>Terminated（终止）</strong>：线程已经执行完毕，终止运行。</li>
</ol>
<p>等待锁或者io操作就是阻塞,等待特定条件满足就是等待.<code>阻塞是被动的,等待是主动的</code>,等待需要其他程序来唤醒.</p>
<h4 id="shutdown和shutdownNow"><a href="#shutdown和shutdownNow" class="headerlink" title="shutdown和shutdownNow"></a>shutdown和shutdownNow</h4><p>shutdown是等待所有线程执行任务完毕之后退出。</p>
<p>shutdownNow是立马中断所有的线程，关闭线程池。</p>
<h4 id="submit和execute"><a href="#submit和execute" class="headerlink" title="submit和execute"></a>submit和execute</h4><p>区别：</p>
<ol>
<li>execute只能提交Runnable类型的任务，没有返回值，而submit既能提交Runnable类型任务也能提交Callable类型任务，返回Future类型。</li>
<li>execute方法提交的任务异常是直接抛出的，而submit方法是是捕获了异常的，当调用FutureTask的get方法时，才会抛出异常。</li>
</ol>
<img src="https://img-blog.csdnimg.cn/img_convert/801f9038979ba89405141affda430217.png" alt="img" style="zoom:50%;" />

<p>execute是Executor接口的方法，而submit是ExecutorService的方法，并且ExecutorService接口继承了Executor接口。</p>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>一个线程池实现,专门用于分治任务,也就是将一个大任务分为多个并行执行的小任务.同时采用了<code>工作窃取</code>的算法,也就是在自己任务队列空的时候,去别的任务队列获取任务执行,实现一种负载均衡.</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue</p>
<p>BlockingQueue 继承了 Queue 接口，是队列的一种。</p>
<p>阻塞队列（BlockingQueue）是一个在队列基础上又支持了两个附加操作的队列，两个附加操作（实现阻塞功能）:</p>
<p>支持阻塞的<code>插入方法put</code>: 队列满时，队列会<code>阻塞插入元素的线程</code>，直到队列不满。<br>支持阻塞的<code>移除方法take</code>: 队列空时，获取元素的线程会<code>等待队列变为非空</code></p>
<ul>
<li><p>BlockingQueue实现被设计为主要用于生产者 - 消费者队列</p>
</li>
<li><p>BlockingQueue实现是线程安全的。所有排队方法使用内部锁或其他形式的并发控制在<code>原子</code>上实现其效果。</p>
</li>
<li><p>BlockingQueue方法有四种形式，具有不同的操作方式，不能立即满足，但可能在将来的某个时间点满足：</p>
<ul>
<li>一个抛出异常</li>
<li>返回一个特殊值（ null或false ，具体取决于操作）</li>
<li>第三个程序将无限期地阻止当前线程，直到操作成功为止</li>
<li>在放弃之前只有给定的最大时限。</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/04/27/%E5%85%B3%E4%BA%8EJAVA%E5%AF%B9%E8%B1%A1/" rel="next" title="关于JAVA对象">
                <i class="fa fa-chevron-left"></i> 关于JAVA对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/05/04/%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="prev" title="关于引用">
                关于引用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EReentrantLock%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">关于ReentrantLock可重入性的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E9%94%81"><span class="nav-number"></span> <span class="nav-text">分段锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E4%B8%8E%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-number"></span> <span class="nav-text">共享锁与排他锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number"></span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number"></span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number"></span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">可重入性的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">join方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">4.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">超线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">虚拟线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%80%BB%E7%BB%93"><span class="nav-number"></span> <span class="nav-text">锁总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">线程池（高频）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">核心线程和普通线程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">2.</span> <span class="nav-text">拒绝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">线程池线程数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">4.</span> <span class="nav-text">线程池中线程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown%E5%92%8CshutdownNow"><span class="nav-number">5.</span> <span class="nav-text">shutdown和shutdownNow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#submit%E5%92%8Cexecute"><span class="nav-number">6.</span> <span class="nav-text">submit和execute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ForkJoinPool"><span class="nav-number">7.</span> <span class="nav-text">ForkJoinPool</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">阻塞队列</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sounio</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
