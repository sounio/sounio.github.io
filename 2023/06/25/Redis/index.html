<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Redis," />










<meta name="description" content="RedisKey的通用命令redis命令不区分大小写，但是key是区分大小写的。没有返回值的命令执行成功会返回1，失败返回0。 **KEYS *** 查看所有的key，返回值是一个数组   EXISTS EXISTS key [key ...]：返回给定的key中已存在的个数，一个都不存在返回0。   DEL del key [key ...]：删除给定的key，返回值为删除的个数	原子,还有一个">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://sounio.github.io/2023/06/25/Redis/index.html">
<meta property="og:site_name" content="Sounio">
<meta property="og:description" content="RedisKey的通用命令redis命令不区分大小写，但是key是区分大小写的。没有返回值的命令执行成功会返回1，失败返回0。 **KEYS *** 查看所有的key，返回值是一个数组   EXISTS EXISTS key [key ...]：返回给定的key中已存在的个数，一个都不存在返回0。   DEL del key [key ...]：删除给定的key，返回值为删除的个数	原子,还有一个">
<meta property="og:locale">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_205002.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_204837.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_205440.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_211917.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_210006.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_215157.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_221342.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_221630.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_005049.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_010246.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230406012146601.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_222939.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_224947.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_225406.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_230537.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_232643.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_234446.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_000031.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_001053.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_002335.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_002704.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_014722.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/InWMfeD.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_051330.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_064933.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_194926.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_052827.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_054714.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_062102.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_062833.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_204113.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_063939.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_200230.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_205240.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_210818.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_212624.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_214201.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/1652941995945.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/1652942027719.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_013020.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_001928.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_013751.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_005809.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_014536.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_014841.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_015539.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_015823.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_024911.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_030549.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_043514.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_040923.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_052026.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_053352.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_095412.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_113723.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_215248.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_005458.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_010353.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_010905.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_012107.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_040833.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_191915.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_180150.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_044438.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_045728.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_185848.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_181243.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_181658.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230408193813874.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_200015.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_202047.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_232347.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-09_000056.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-09_051719.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/stream%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-11_225736.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_025908.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-11_222730.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-11_223005.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_010123.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_010220.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_025125.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_034032.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230412032737462.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_050612.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_053017.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_060804.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_071956.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_073207.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_074803.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/aof%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_005226.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_010054.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_014123.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_015330.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_021448.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_020726.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_030844.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_215044.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_221127.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_224853.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_230814.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_231329.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_001017.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_001151.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_052056.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_055012.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_202754.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053032.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053304.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053407.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053526.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053736.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_055701.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054025.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054232.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054622.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054759.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_113140.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_105932.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_110313.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_111840.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_113853.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_114241.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_221538.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_223633.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_235542.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/sentinel.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_030538.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_035110.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_040008.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_041926.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_043016.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_044818.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_045331.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_045716.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_065615.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_055113.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_052907.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_062500.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230415063454674.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_064629.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/%E5%93%A8%E5%85%B5%E9%80%89%E4%B8%BE.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/cluster.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/redis%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%8E%AF.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_125434.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_124752.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_130446.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_224005.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_232003.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_232246.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_021649.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_233204.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_234248.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_000001.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_000849.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_002143.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_002446.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_002814.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_011920.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_011706.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_014559.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_015556.png">
<meta property="og:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_020413.png">
<meta property="article:published_time" content="2023-06-25T02:55:05.000Z">
<meta property="article:modified_time" content="2023-07-10T13:09:59.018Z">
<meta property="article:author" content="sounio">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_205002.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sounio.github.io/2023/06/25/Redis/"/>





  <title>Redis | Sounio</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sounio</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sounio.github.io/2023/06/25/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sounio">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-06-25T10:55:05+08:00">
                2023-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Key的通用命令"><a href="#Key的通用命令" class="headerlink" title="Key的通用命令"></a>Key的通用命令</h2><p>redis命令不区分大小写，但是key是区分大小写的。没有返回值的命令执行成功会返回1，失败返回0。</p>
<h4 id="KEYS"><a href="#KEYS" class="headerlink" title="**KEYS ***"></a>**KEYS ***</h4><blockquote>
<p>查看所有的key，返回值是一个数组</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_205002.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_205002.png" alt="2023-04-05_205002"></a></p>
<h4 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a><strong>EXISTS</strong></h4><blockquote>
<p><code>EXISTS key [key ...]</code>：返回给定的key中已存在的个数，一个都不存在返回0。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_204837.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_204837.png" alt="2023-04-05_204837"></a></p>
<h4 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a><strong>DEL</strong></h4><blockquote>
<p><code>del key [key ...]</code>：删除给定的key，返回值为删除的个数	<code>原子</code>,还有一个unlink也是删除，不过是异步命令</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_205440.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_205440.png" alt="2023-04-05_205440"></a></p>
<h4 id="EXPIRE"><a href="#EXPIRE" class="headerlink" title="EXPIRE"></a><strong>EXPIRE</strong></h4><blockquote>
<p><code>expire key second</code>：给key设置一个过期时间second，单位为秒，比如expire name 10，表示name这个键10秒后过期</p>
</blockquote>
<h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a><strong>TTL</strong></h4><blockquote>
<p><code>ttl key</code>：查看key的过期时间，不设置过期时间的话默认是永不过期(返回值-1)，过期则返回-2。time to live的缩写。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_211917.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_211917.png" alt="2023-04-05_211917"></a></p>
<h4 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a><strong>TYPE</strong></h4><blockquote>
<p><code>type key</code>：返回key的类型，如果key不存在返回null</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_210006.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_210006.png" alt="2023-04-05_210006"></a></p>
<h4 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a><strong>DBSIZE</strong></h4><blockquote>
<p>查看当前数据库有多少个key</p>
</blockquote>
<h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a><strong>SELECT</strong></h4><blockquote>
<p><code>select index</code>：切换数据库，redis默认一共16个数据库，对应索引为0~15，默认的数据库是0号库</p>
</blockquote>
<h4 id="MOVE"><a href="#MOVE" class="headerlink" title="MOVE"></a><strong>MOVE</strong></h4><blockquote>
<p><code>move key index</code>：将指定key移入指定数据库中</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_215157.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_215157.png" alt="2023-04-05_215157"></a></p>
<h4 id="FLUSHDB"><a href="#FLUSHDB" class="headerlink" title="FLUSHDB"></a><strong>FLUSHDB</strong></h4><blockquote>
<p>清空当前库的key</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushdb		# 输入fushdb回车即可清空当前库的所有键，此操作慎用</span><br></pre></td></tr></table></figure>



<h4 id="FLUSHALL"><a href="#FLUSHALL" class="headerlink" title="FLUSHALL"></a><strong>FLUSHALL</strong></h4><blockquote>
<p>清空所有库的key</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushall	# 输入flushall会清空所有库的键，此操作慎用</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="help"><a href="#help" class="headerlink" title="help"></a><strong>help</strong></h4><blockquote>
<p>help命令可以查看redis命令或数据类型的使用说明，注意该命令要在redis客户端才能使用。</p>
</blockquote>
<ul>
<li>help 命令：查看命令的使用说明</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_221342.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_221342.png" alt="2023-04-05_221342"></a></p>
<ul>
<li>help @数据类型：查看redis数据类型的使用说明</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_221630.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_221630.png" alt="2023-04-05_221630"></a></p>
<hr>
<h4 id="CONFIG"><a href="#CONFIG" class="headerlink" title="CONFIG"></a>CONFIG</h4><blockquote>
<p>查看配置文件指定信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG get dir			# 查看RDB文件存放目录</span><br><span class="line">1) &quot;dir&quot;							</span><br><span class="line">2) &quot;/opt/redis-7.0.10&quot;</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get save			# 查看RDB触发条件</span><br><span class="line">1) &quot;save&quot;</span><br><span class="line">2) &quot;7 3&quot;</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get appendonly	# 查看AOF是否开启</span><br><span class="line">1) &quot;appendonly&quot;</span><br><span class="line">2) &quot;yes&quot;</span><br></pre></td></tr></table></figure>



<h2 id="Redis十大数据类型"><a href="#Redis十大数据类型" class="headerlink" title="Redis十大数据类型"></a>Redis十大数据类型</h2><p>redis中的数据都是用k-v键值对存储的，所有的key都是String类型，所说的十大&#x3D;&#x3D;数据类型指的是value值的数据类型&#x3D;&#x3D;。</p>
<p>准确来说这十大数据类型只有&#x3D;&#x3D;六大数据类型&#x3D;&#x3D;，分别是&#x3D;&#x3D;String、List、Hash、Set、Zset、Stream&#x3D;&#x3D;。 其余的四种是对这数据类型封装出来的数据结构，分别是Bitmap(String)、HyperLogLog(String)、Geospatial(Zset)、BitField(String)。</p>
<hr>
<h3 id="一-Stirng"><a href="#一-Stirng" class="headerlink" title="一. Stirng"></a>一. Stirng</h3><blockquote>
<p><strong>字符串</strong></p>
<p>String类型，也就是字符串类型，是Redis中最简单的存储类型，单key单value结构。 其value是字符串，不过根据字符串的格式不同，又可以分为3类： String：普通字符串 int：整数类型，可以做自增、自减操作 float：浮点类型，可以做自增、自减操作</p>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p>
</blockquote>
<hr>
<p><em><strong>String类型的常用命令：</strong></em></p>
<h4 id="SET和GET"><a href="#SET和GET" class="headerlink" title="SET和GET"></a><strong>SET和GET</strong></h4><p>**<code>set key value [可选参数]</code>**：添加或者修改一个String类型的键值对</p>
<p>**<code>get key</code>**：根据key获取String类型的value，不存在返回nil</p>
<blockquote>
<p>可选参数：</p>
<p>EX：以秒为单位设置过期时间</p>
<p>PX：以毫秒为单位设置过期时间</p>
<p>EXAT：设置以秒为单位的时间戳为过期时间(使用unix时间戳，有时候可以节约一步换算)</p>
<p>PXAT：设置以毫秒为单位的时间戳为过期时间</p>
<p>NX：键<code>不存在</code>的时候添加键值对，存在返回nil</p>
<p>XX：键<code>存在</code>的时候设置键值，也就是覆盖，不存在返回nil</p>
<p>GET：返回指定键<code>原本</code>的值，若不存在返回nil</p>
<p>KEEPTTL：<code>保留</code>键之前的生存时间，即在覆盖键值时过期时间还是之前的过期时间，也就是现在计算的过期时间不变，然后改变设定</p>
<p>提示：set命令使用EX、PX、NX参数，效果等同于SETEX、SETPX、SETNX。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set name Tom	# 设置name=Tom</span><br><span class="line">set name Bob get # 重新设置name值并返回原来的name值</span><br><span class="line">set name Bob ex 20 get # 重新设置name值并设置过期时间20秒，并返回之前的name值 </span><br><span class="line">get name	# 获取name的值</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_005049.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_005049.png" alt="2023-04-06_005049"></a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name Marry keepttl	<span class="comment"># 表示保持之前的过期时间</span></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_010246.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_010246.png" alt="2023-04-06_010246"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set name Mike XX	# name已存在时才创建(覆盖)</span><br><span class="line">set name Mike NX	# name不存在时创建，已存在时不创建</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/image-20230406012146601.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230406012146601.png" alt="image-20230406012146601"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set name Mike EXAT 1680715582	# 设置以秒为单位的时间戳的过期时间</span><br><span class="line">set name Mike PXAT 1680715582123	# 设置以毫秒为单位的时间戳的过期时间</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="MSET和MGET"><a href="#MSET和MGET" class="headerlink" title="MSET和MGET"></a><strong>MSET和MGET</strong></h4><blockquote>
<p>M是multi的缩写，表示<code>多个</code>的意思。</p>
</blockquote>
<p>**<code>mset key value [key value ...]</code>**：批量添加多个String类型的键值对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset name Tom age 18 sex man	# 设置name=Tom，age=18，sex=man</span><br></pre></td></tr></table></figure>



<p>**<code>mget key [key ...]</code>**：批量获取String类型的value</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget name age sex	# 获取name、age、sex的值</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_222939.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_222939.png" alt="2023-04-05_222939"></a></p>
<hr>
<h4 id="INCR、INCRBY"><a href="#INCR、INCRBY" class="headerlink" title="INCR、INCRBY"></a><strong>INCR、INCRBY</strong></h4><blockquote>
<p>increase的缩写，表示自增</p>
</blockquote>
<p>**<code>incr key</code>**：让一个整型的key自增1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set age 20</span><br><span class="line">incr age	# 让age自增1</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_224947.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_224947.png" alt="2023-04-05_224947"></a></p>
<p>**<code>incrby key step</code>**：指定步长step，让一个整型的key自增step</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby age 2	# 让age自增2</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_225406.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_225406.png" alt="2023-04-05_225406"></a></p>
<p>**<code>incrbyfloat key step</code>**：让一个浮点类型的数字指定步长自增（浮点类型只能指定步长自增，incrbyfloat也是用整型）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set weight 66.6</span><br><span class="line">INCRBYFLOAT weight 0.2	# 让weight自增0.2</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_230537.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_230537.png" alt="2023-04-05_230537"></a></p>
<ul>
<li><p><strong>DECR、DECRBY、DECRBYFLOAT</strong></p>
<p>自减，操作和上述自增一样。</p>
</li>
</ul>
<hr>
<h4 id="SETNX和SETEX"><a href="#SETNX和SETEX" class="headerlink" title="SETNX和SETEX"></a><strong>SETNX和SETEX</strong></h4><blockquote>
<p>setnx：已存在就不会改变键的值。NX是not exists的缩写。</p>
<p>setex：设定键的过期时间。EX是expire的缩写。</p>
</blockquote>
<p>**<code>setnx key value</code>**：如果key不存在则创建一个String类型的键值对，如果key存在，则不执行。创建成功返回1，失败返回0。</p>
<p>**<code>setex key second</code>**：创建一个String类型的键值对，并设置过期时间，second为秒数</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_232643.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_232643.png" alt="2023-04-05_232643"></a></p>
<hr>
<h4 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a><strong>MSETNX</strong></h4><p>**<code>msetnx key value [key value ...]</code>**：批量添加多个String类型的键值对。</p>
<p>当且仅当要创建的所有key都不存在时才创建成功。只要有一个键已存在，则都创建失败。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_234446.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_234446.png" alt="2023-04-05_234446"></a></p>
<hr>
<h4 id="SETRANGE和GETRANGE"><a href="#SETRANGE和GETRANGE" class="headerlink" title="SETRANGE和GETRANGE"></a><strong>SETRANGE和GETRANGE</strong></h4><p>**<code>setrange key offset value</code>**：从指定位置替换值的内容，offset表示偏移量，如果为1表示从第二个字符开始。value为替换的内容。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_000031.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_000031.png" alt="2023-04-06_000031"></a></p>
<p>**<code>getrange key start end</code>**：获取key值指定范围的内容，start表示开始索引，end表示结束索引。0到-1表示获取全部。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_001053.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_001053.png" alt="2023-04-06_001053"></a></p>
<hr>
<h4 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a><strong>STRLEN</strong></h4><p>**<code>strlen key</code>**：获取key值的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen str # 获取str值的长度</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_002335.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_002335.png" alt="2023-04-06_002335"></a></p>
<hr>
<h4 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a><strong>APPEND</strong></h4><p>**<code>append key value</code>**：在key值后追加内容value</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append str hijklmn	# 在str值后追加内容hijklmn</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_002704.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_002704.png" alt="2023-04-06_002704"></a></p>
<hr>
<h4 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a>GETSET</h4><p>**<code>getset key value</code>**：设置键值对时先获取原先的key值再设置新的key值，等价于set key get。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_014722.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_014722.png" alt="2023-04-06_014722"></a></p>
<hr>
<h4 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a><strong>key的结构</strong></h4><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p>
<p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就冲突了该怎么办？</p>
<p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>



<p>这个格式并非固定，也可以根据自己的需求设计。这样我们就可以把不同类型的数据区分开了，从而避免了key的冲突问题。</p>
<p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li>user相关的key：<strong>heima:user:1</strong></li>
<li>product相关的key：<strong>heima:product:1</strong></li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody><tr>
<td>heima:user:1</td>
<td>{“id”:1, “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1, “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody></table>
<p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/InWMfeD.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/InWMfeD.png" alt="InWMfeD"></a></p>
<hr>
<hr>
<h3 id="二-List"><a href="#二-List" class="headerlink" title="二. List"></a>二. List</h3><blockquote>
<p><strong>列表</strong></p>
<p>Redis的List类型是一个<code>单Key多Value</code>的集合，其value值是有序可重复的。</p>
<p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个<code>双向</code>链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>如果键不存在，创建新的链表；</p>
<p>如果键已存在，新增内容，可重复；</p>
<p>如果值全移除，对应的键也就消失了。</p>
<p>特征与LinkedList类似：①有序 ②可重复 ③插入和删除速度快 ④查询速度一般</p>
<p>常用来存储一个有序数据，例如朋友圈点赞列表，评论列表等等。</p>
</blockquote>
<hr>
<p><em><strong>List类型常用命令：</strong></em></p>
<h4 id="LPUSH和RPUSH"><a href="#LPUSH和RPUSH" class="headerlink" title="LPUSH和RPUSH"></a>LPUSH和RPUSH</h4><blockquote>
<p>向列表头部或尾部插入元素。返回值为执行命令后列表的长度。当key不存在时则创建key。</p>
</blockquote>
<p>**<code>LPUSH key element [element ...]</code>**：在列表key左边添加一个或多个元素，也就是在列表的头部添加元素。</p>
<p>**<code>RPUSH key element [element ...]</code>**：在列表key右边添加一个或多个元素，也就是在列表的尾部添加元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lpush list A B	# 创建一个列表，key为list</span><br><span class="line">lpush list C D E	# 在列表左边（前面）追加C、D、E三个元素</span><br><span class="line">rpush list X Y Z	# 在列表右边（后面）追加X、Y、Z三个元素</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_051330.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_051330.png" alt="2023-04-06_051330"></a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_064933.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_064933.png" alt="2023-04-06_064933"></a></p>
<hr>
<h4 id="LPUSHX和RPUSHX"><a href="#LPUSHX和RPUSHX" class="headerlink" title="LPUSHX和RPUSHX"></a>LPUSHX和RPUSHX</h4><blockquote>
<p>仅当列表存在时入栈，返回值为执行命令后列表的长度。</p>
</blockquote>
<p>**<code>LPUSHX key vlaue</code>**：将value值插入到列表Key的表头，当且仅当 key存在并且是一个列表。当key不存在，执行失败，返回0。</p>
<p>**<code>RPUSHX key value</code>**：将值 value插入到列表key的表尾，当且仅当 key存在并且是一个列表。当key不存在，执行失败，返回0。<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_194926.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_194926.png" alt="2023-04-06_194926"></a></p>
<hr>
<h4 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h4><p>没有RRANGE。</p>
<p>**<code>LRANGE key start stop</code>**：返回列表 key中指定区间内的元素，区间以偏移量(索引) <code>start</code> 和 <code>stop</code> 指定。</p>
<blockquote>
<p>0表示第一个元素，1表示列表第二个元素；-1表示列表最后一个元素，-2表示列表倒数第二个元素，以此类推。</p>
<p>如果start的下标比列表最大的下标end(LLEN list减一)还大，那么Lrange返回一个空列表。</p>
<p>如果stop的下标比end的下标还要大，Redis将stop的值设置为end。<code>0到-1表示列表的所有元素</code>。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_052827.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_052827.png" alt="2023-04-06_052827"></a></p>
<hr>
<h4 id="LPOP和RPOP"><a href="#LPOP和RPOP" class="headerlink" title="LPOP和RPOP"></a>LPOP和RPOP</h4><blockquote>
<p>弹出列表最左端或最右端的元素。</p>
</blockquote>
<p>**<code>LPOP key [count]</code>**：移除列表最左侧的元素并返回该元素，没有则返回nil，count为移除的个数。</p>
<p>**<code>RPOP key [count]</code>**：移除列表最右侧的元素并返回该元素，没有则返回nil，count为移除的个数。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_054714.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_054714.png" alt="2023-04-06_054714"></a></p>
<hr>
<h4 id="BLPOP和BRPOP"><a href="#BLPOP和BRPOP" class="headerlink" title="BLPOP和BRPOP"></a>BLPOP和BRPOP</h4><blockquote>
<p>B是blocking的缩写，表示阻塞的意思。</p>
<p>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil。</p>
</blockquote>
<p>**<code>BLPOP key [key ...] timeout</code>**：移除列表第一个元素并返回该元素，如果列表没有元素会阻塞队列直到等待超时或发现可弹出元素为止</p>
<p>**<code>BRPOP key [key ...] timeout</code>**：移除列表最后一个元素并返回该元素，如果列表没有元素会阻塞队列直到等待超时或发现可弹出元素为止</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_062102.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_062102.png" alt="2023-04-06_062102"></a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_062833.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_062833.png" alt="2023-04-06_062833"></a></p>
<hr>
<h4 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a>RPOPLPUSH</h4><p>**<code>RPOPLPUSH source destination</code>**：将列表source中的尾元素弹出插入到列表destination的头部，并返回该元素。</p>
<blockquote>
<p>如果source不存在，返回nil。 如果source和destination相同，则列表中的表尾元素被移动到表头，并返回该元素，这种情况可以视为列表的旋转操作。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_204113.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_204113.png" alt="2023-04-06_204113"></a></p>
<p>Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 LPUSH命令将消息放入队列中，而另一个客户端通过 RPOP或者 BRPOP命令取出队列中等待时间最长的消息。</p>
<p>上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。</p>
<p>使用RPOPLPUSH命令(或者它的阻塞版本 BRPOPLPUSH )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 LREM 命令将这个消息从备份表删除。</p>
<p>最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。</p>
<hr>
<h4 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h4><p>**<code>LINDEX key index</code>**：通过索引获取列表元素。</p>
<p>下标(index)参数 <code>start</code> 和 <code>stop</code> 都以 <code>0</code> 为底，也就是说，以 <code>0</code> 表示列表的第一个元素，以 <code>1</code> 表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以 <code>-1</code> 表示列表的最后一个元素， <code>-2</code> 表示列表的倒数第二个元素，以此类推。</p>
<p>如果 <code>index</code> 参数的值不在列表的区间范围内(out of range)，返回 <code>nil</code> 。如果 <code>key</code> 不是列表类型，返回一个错误。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_063939.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_063939.png" alt="2023-04-06_063939"></a></p>
<hr>
<h4 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h4><p>**<code>LLEN key</code>**：返回列表key的长度。</p>
<blockquote>
<p>如果key不存在，则key被解释为一个空列表，返回0。</p>
<p>如果key不是一个列表类型返回一个错误。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_200230.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_200230.png" alt="img"></a></p>
<hr>
<h4 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a>LREM</h4><blockquote>
<p>remove的缩写，移除指定元素。</p>
<p>返回值：被移除元素的数量。不存在的 <code>key</code> 被视作空表(empty list)，所以当 <code>key</code> 不存在时， LREM命令总是返回 0 。</p>
</blockquote>
<p>**<code>LREM key count value</code>**：根据count的值，移除列表中与参数value相等的元素。</p>
<blockquote>
<p><code>count</code> 的值可以是以下几种：</p>
<ul>
<li><code>count &gt; 0</code> : 从表头开始向表尾搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 。</li>
<li><code>count &lt; 0</code> : 从表尾开始向表头搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 的绝对值。</li>
<li><code>count = 0</code> : 移除表中所有与 <code>value</code> 相等的值。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_205240.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_205240.png" alt="2023-04-06_205240"></a></p>
<hr>
<h4 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h4><blockquote>
<p>对一个列表进行修剪(trim)，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>
</blockquote>
<p>**<code>LTRIM key start stop</code>**：让列表key只保留<code>start</code>-<code>stop</code>区间的元素。成功返回ok，若key不是列表类型返回错误。</p>
<blockquote>
<p>下标(index)参数 <code>start</code> 和 <code>stop</code> 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_210818.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_210818.png" alt="2023-04-06_210818"></a></p>
<hr>
<h4 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h4><p>**<code>LSET key index value</code>**：将列表key下标为index的元素的值设置为value。操作成功返回ok。</p>
<blockquote>
<p>当index参数超出范围，或对一个空列表(key不存在)进行LSET时，返回一个错误。关于更多的下标信息，参考LINDEX。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_212624.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_212624.png" alt="2023-04-06_212624"></a></p>
<hr>
<h4 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a>LINSERT</h4><p>**<code>LINSERT key BEFORE|AFTER element value</code>**：将值value插入到列表key中element元素之前或之后。</p>
<blockquote>
<p>当<code>element</code>不存在列表<code>key</code>中时，不执行任何操作。当<code>key</code>不存在时，也不执行任何操作。若<code>key</code>不是列表类型，返回一个错误。</p>
<p>返回值： 如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到 <code>element</code> ，返回 <code>-1</code> 。 如果 <code>key</code> 不存在或为空列表，返回 <code>0</code> 。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_214201.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_214201.png" alt="2023-04-06_214201"></a></p>
<hr>
<hr>
<h3 id="三-Hash"><a href="#三-Hash" class="headerlink" title="三. Hash"></a>三. Hash</h3><blockquote>
<p><strong>哈希表</strong></p>
<p>hash类型，也叫做散列。其value是一个无序字典，类似于java中的HashMap结构。</p>
<p>K-V模式不变，但v又是一个键值对：Map&lt;key,Map&lt;key,value&gt;&gt;</p>
</blockquote>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/1652941995945.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/1652941995945.png" alt="img"></a></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD，下面是两个哈希表：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/1652942027719.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/1652942027719.png" alt="img"></a></p>
<hr>
<p><em><strong>Hash类型的常用命令：</strong></em></p>
<h4 id="HSET和HGET"><a href="#HSET和HGET" class="headerlink" title="HSET和HGET"></a>HSET和HGET</h4><p>**<code>HSET key field value [field value ...]</code>**：将hash表key中的域field的值设置为value，支持同时设置多个域-值对。</p>
<blockquote>
<p>如果key不存在，一个新的hash表被创建并执行HSET操作。 如果域field不存在，表示新增<code>field-value</code>(域值对)，如果域field已经存在哈希表key中，其旧值将被覆盖。</p>
<p>返回值： 如果 field 是哈希表中的一个<code>新建域</code>，并且值设置成功，返回 1 。多个则返回对应的个数。 如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_013020.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_013020.png" alt="img"></a></p>
<p>**<code>HGET key field </code>**：根据给定域field返回对应的value值。当key不存在或者field不存在，返回nil。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_001928.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_001928.png" alt="2023-04-07_001928"></a></p>
<hr>
<h4 id="HMSET和HMGET"><a href="#HMSET和HMGET" class="headerlink" title="HMSET和HMGET"></a>HMSET和HMGET</h4><p>**<code>HMSET key field value [field value ...]</code>**：同时将多个<code>field-value</code>（域-值对）设置到哈希表key中。</p>
<blockquote>
<p>此命令会覆盖哈希表中已存在的域，如果key不存在，一个空的哈希表被创建并执行HMSET操作。</p>
<p>返回值：执行成功返回ok；若key不是hash类型，返回一个错误。</p>
<p>HSET在Redis版本迭代后也支持同时设置多个值到哈希表中，与HMSET操作完全相同，HMSET今后可能被淘汰。</p>
</blockquote>
<p>**<code>HMGET key field [field ...]</code>**：返回哈希表key中一个或多个给定的域值。</p>
<blockquote>
<p>如果给定的域不存在于哈希表，那么返回一个 <code>nil</code> 值。key不存在时也返回一个<code>nil</code>值。key不是Hash类型时报错。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_013751.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_013751.png" alt="img"></a></p>
<hr>
<h4 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h4><p>**<code>HGETALL key</code>**：返回哈希表key中所有的<code>field</code>和<code>value</code> 。</p>
<blockquote>
<p>在返回值里，紧跟着域名后的是域的值，所以返回值的长度是哈希表大小的两倍。</p>
<p>返回值：以列表形式返回哈希表的域和值，若key不存在，返回空列表。若key不是hash类型则报错。</p>
<p>若在Redis客户端这样显示的数据就是列表： 1）”AA” 2）”BB” 3）”CC” …</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_005809.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_005809.png" alt="2023-04-07_005809"></a></p>
<hr>
<h4 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h4><p>**<code>HDEL key field [field ...]</code>**：删除哈希表 <code>key</code> 中的一个或多个指定域，不存在的域将被忽略。</p>
<blockquote>
<p>返回值：被成功移除的域的数量，不包括被忽略的域。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_014536.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_014536.png" alt="img"></a></p>
<hr>
<h4 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h4><p>**<code>HLEN key</code>**：返回哈希表 <code>key</code> 中域的数量。</p>
<blockquote>
<p>返回值：返回哈希表中域的数量，当key不存在时返回0，若key不是hash类型则报错。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_014841.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_014841.png" alt="img"></a></p>
<hr>
<h4 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h4><p>**<code>HEXISTS key field</code>**：查看哈希表key中，给定域field是否存在。</p>
<blockquote>
<p>如果哈希表中存在给定域，返回 <code>1</code> 。 如果哈希表中不存在给定域，或 <code>key</code> 不存在，返回 <code>0</code> 。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_015539.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_015539.png" alt="2023-04-07_015539"></a></p>
<hr>
<h4 id="HKEYS和HVALS"><a href="#HKEYS和HVALS" class="headerlink" title="HKEYS和HVALS"></a>HKEYS和HVALS</h4><p>**<code>HKEYS key</code>**：获取哈希表key中所有的<code>field</code></p>
<blockquote>
<p>返回值：返回哈希表中所有field的<code>数组</code>，若key不存在返回一个空数组。若key不是hash类型返回错误。</p>
</blockquote>
<p>**<code>HVALS key</code>**：获取哈希表key中所有field对应的<code>value</code>值。</p>
<blockquote>
<p>返回值：返回哈希表中所有field对应的value的<code>数组</code>，若key不存在返回一个空数组。若key不是hash类型返回错误。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_015823.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_015823.png" alt="2023-04-07_015823"></a></p>
<hr>
<h4 id="HINCR、HINCRBYFLOAT"><a href="#HINCR、HINCRBYFLOAT" class="headerlink" title="HINCR、HINCRBYFLOAT"></a>HINCR、HINCRBYFLOAT</h4><p>**<code>HINCRBY key field increment</code>**：为哈希表 <code>key</code> 中的域 <code>field</code> 的值加上增量 <code>increment</code> 。只适用整型字符串</p>
<p>**<code>HINCRBYFLOAT key field increment</code>**：为哈希表 <code>key</code> 中的域 <code>field</code> 加上浮点数增量 <code>increment</code> 。只适用浮点型字符串</p>
<blockquote>
<p>增量也可以为负数，相当于对给定域进行减法操作。</p>
<p>如果哈希表 <code>key</code> 不存在，那么会先创建一个哈希表，再创建域 <code>field</code> ，最后再执行<code>HINCRBY</code> 或 <code>HINCRBYFLOAT</code>操作。</p>
<p>如果域 <code>field</code> 不存在，那么在执行命令前，域的值被初始化为 <code>0</code> ，然后后执行<code>HINCRBY</code> 或 <code>HINCRBYFLOAT</code>操作。</p>
<p>对一个储存<code>非整型字符串</code>的域 field 执行 <code>HINCRBY</code> 命令将造成一个错误。</p>
<p>对一个储存<code>非数值型字符串</code>的域 field 执行 <code>HINCRBYFLOAT</code> 命令将造成一个错误。</p>
<p>本操作的值被限制在 64 位(bit)有符号数字表示之内。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_024911.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_024911.png" alt="img"></a></p>
<hr>
<h4 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h4><p>**<code>HSETNX key field value</code>**：向哈希表key中添加<code>field-value</code>，当且仅当域field不存在。</p>
<blockquote>
<p>若field已存在，则该操作无效；若key不存在，则创建该哈希表并执行HSETNX操作。</p>
<p>返回值：添加成功，返回1；如果给定域已经存在返回 0 。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_030549.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_030549.png" alt="2023-04-07_030549"></a></p>
<hr>
<hr>
<h3 id="四-Set"><a href="#四-Set" class="headerlink" title="四. Set"></a>四. Set</h3><blockquote>
<p><strong>集合</strong></p>
<p>Redis的Set类型是一个和List一样的单key多value的集合，与List不同的是Set的value是无序且不可重复的。</p>
<p>Redis的set相当于Java语言里面的HashSet，它内部键值对是无序的、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值NULL，可以看做是一个value为null的HashMap。</p>
<p>具备与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p><em>应用场景</em>： 微信抽奖小程序。（SRANDMEMBER） 微信朋友圈共友点赞。（SINTER） QQ推荐可能认识的人。（SDIFF）</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_043514.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_043514.png" alt="2023-04-07_043514"></a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_040923.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_040923.png" alt="img"></a></p>
<hr>
<p><em><strong>Set类型的常用命令：</strong></em></p>
<h4 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h4><p>**<code>SADD key member [member ...]</code>**：将一个或多个 <code>member</code> 元素加入到set集合 <code>key</code> 当中，已经存在于集合的 <code>member</code> 元素将被忽略。</p>
<blockquote>
<p>假如 <code>key</code> 不存在，则创建一个只包含 <code>member</code> 元素作成员的集合。</p>
<p>当 <code>key</code> 不是Set集合类型时，返回一个错误。</p>
<p><strong>返回值</strong>：被添加到集合中的新元素的数量，不包括被忽略的元素。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_052026.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_052026.png" alt="2023-04-07_052026"></a></p>
<hr>
<h4 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h4><p>**<code>SMEMBERS key</code>**：返回集合<code>key</code>中所有的成员。</p>
<blockquote>
<p>若key不存在，返回空数组；若key不是Set集合，返回错误。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_053352.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_053352.png" alt="2023-04-07_053352"></a></p>
<hr>
<h4 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h4><blockquote>
<p>S表示Set集合，ISMEMBER表示is member？</p>
</blockquote>
<p><strong>SISMEMBER key member</strong>：判断 <code>member</code> 元素是否是集合 <code>key</code> 的成员。</p>
<blockquote>
<p>如果 <code>member</code> 元素是集合的成员，返回 <code>1</code> 。</p>
<p>如果 <code>member</code> 元素不是集合的成员，或 <code>key</code> 不存在，返回 <code>0</code> 。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_095412.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_095412.png" alt="2023-04-07_095412"></a></p>
<hr>
<h4 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h4><p>**<code>SCARD key</code>**：返回集合key中成员的个数。当key不存在时，返回0。若key不是Set集合类型，返回错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCARD course	# 获取集合course中元素的个数</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h4><p>**<code>SREM key member [member ...]</code>**：移除集合key中的一个或多个member元素并返回移除的个数，不存在的member元素会被忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SREM course C++		# 移除C++</span><br><span class="line">(integer) 1		# 成功移除一个</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h4><p>**<code>SRANDMEMBER key [count]</code>**：随机返回集合中一个[或多个]元素。仅仅返回随机元素，而不对集合进行任何改动。</p>
<blockquote>
<p>SRANDMEMBER命令可选的 <code>count</code> 参数：</p>
<ul>
<li>如果 <code>count</code> 为正数，且小于集合基数，那么命令返回一个包含 <code>count</code> 个元素的数组，数组中的元素<strong>各不相同</strong>。 如果 <code>count</code> 大于等于集合基数，那么返回整个集合。</li>
<li>如果 <code>count</code> 为负数，那么命令返回一个数组，数组中的元素<strong>可能会重复出现多次</strong>，而数组的长度为 <code>count</code> 的绝对值。</li>
</ul>
<p>返回值: 只提供 <code>key</code> 参数时，返回一个元素；如果集合为空，返回 <code>nil</code> 。 如果提供了 <code>count</code> 参数，那么返回一个数组；如果集合为空，返回空数组。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_113723.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_113723.png" alt="img"></a></p>
<hr>
<h4 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h4><p><strong><code>SPOP key [count] </code></strong> ：移除并返回集合中的一个[或多个]随机元素。</p>
<blockquote>
<p>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER命令。</p>
<p>返回值：被移除的随机元素。当 <code>key</code> 不存在或 <code>key</code> 是空集时，返回 <code>nil</code> 。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_215248.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_215248.png" alt="2023-04-07_215248"></a></p>
<hr>
<h4 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h4><p>**<code>SMOVE source destination member</code>**：将 <code>member</code> 元素从 <code>source</code> 集合移动到 <code>destination</code> 集合。</p>
<blockquote>
<p>SMOVE是原子性操作。</p>
<p>如果 <code>source</code> 集合不存在或不包含指定的 <code>member</code> 元素，则 SMOVE 命令不执行任何操作，仅返回 <code>0</code> 。</p>
<p>当 <code>destination</code> 集合已经包含 <code>member</code> 元素时， SMOVE 命令只是简单地将 <code>source</code> 集合中的 <code>member</code> 元素删除。</p>
<p>当 <code>source</code> 或 <code>destination</code> 不是集合类型时，返回一个错误。</p>
<p><strong>返回值:</strong></p>
<p>如果 <code>member</code> 元素被成功移除，返回 <code>1</code> 。</p>
<p>如果 <code>member</code> 元素不是 <code>source</code> 集合的成员，并且没有任何操作对 <code>destination</code> 集合执行，那么返回 <code>0</code> 。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers course					# 集合course有三个成员</span><br><span class="line">1) &quot;Go&quot;</span><br><span class="line">2) &quot;Python&quot;</span><br><span class="line">3) &quot;Java&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers subject				# 集合subject有四个成员</span><br><span class="line">1) &quot;Chinese&quot;</span><br><span class="line">2) &quot;Physics&quot;</span><br><span class="line">3) &quot;English&quot;</span><br><span class="line">4) &quot;Math&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMOVE subject course Physics	# 将集合subject的成员Physics移动到集合course中</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS course					# 集合course中新增成员Physics</span><br><span class="line">1) &quot;Physics&quot;</span><br><span class="line">2) &quot;Go&quot;</span><br><span class="line">3) &quot;Python&quot;</span><br><span class="line">4) &quot;Java&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS subject				# 集合subject中少了一个成员</span><br><span class="line">1) &quot;Chinese&quot;</span><br><span class="line">2) &quot;English&quot;</span><br><span class="line">3) &quot;Math&quot;</span><br><span class="line">127.0.0.1:6379&gt; SADD subject Go					# 新增成员Go到集合subject</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMOVE subject course Go			# 移动成员Go从subject到course(Go在两个集合中都存在)</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS subject				# 自身减少了一个成员</span><br><span class="line">1) &quot;Chinese&quot;</span><br><span class="line">2) &quot;English&quot;</span><br><span class="line">3) &quot;Math&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS course					# course本身就已有Go成员，所以不执行任何操作(也可以理解为覆盖了)</span><br><span class="line">1) &quot;Physics&quot;</span><br><span class="line">2) &quot;Go&quot;</span><br><span class="line">3) &quot;Python&quot;</span><br><span class="line">4) &quot;Java&quot;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><h5 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a>SDIFF</h5><p>**<code>SDIFF key key2 ...</code>**：返回给定集合的差集。</p>
<blockquote>
<p>sdiff A B：返回属于集合A但不属于集合B的元素 sdiff B A：返回属于集合B但不属于集合A的元素</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_005458.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_005458.png" alt="2023-04-08_005458"></a></p>
<h5 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h5><p>**<code>SUNION key [key ...]</code>**：返回给定集合的并集。</p>
<blockquote>
<p>比如<code>sunion A B</code>表示返回集合A和集合B的所有元素，公共的只取一份。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_010353.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_010353.png" alt="2023-04-08_010353"></a></p>
<h5 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a>SINTER</h5><p>**<code>SINTER key [key ...]</code>**：返回给定集合的交集。</p>
<blockquote>
<p>比如<code>sinter A B</code>表示即返回集合A和集合B共有的元素。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_010905.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_010905.png" alt="2023-04-08_010905"></a></p>
<p><strong><code>SINTERCARD numkeys key [key ...] [LIMIT limit]</code></strong> ：返回给定集合交集的个数。</p>
<blockquote>
<p>numkeys为key的个数。</p>
<p>LIMIT为限制返回的个数的最大值，比如交集个数有10个，但是LIMIT为5，则返回5。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_012107.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_012107.png" alt="2023-04-08_012107"></a></p>
<hr>
<hr>
<h3 id="五-SortedSet"><a href="#五-SortedSet" class="headerlink" title="五. SortedSet"></a>五. SortedSet</h3><blockquote>
<p><strong>有序集合</strong></p>
<p>SortedSet也叫<code>ZSet</code>。在Set的基础上，每个member前面加个score属性。</p>
<p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。</p>
<p>SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>score的值是一个<em>整型数值或者浮点数值</em> 的数，是可重复的。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。比如商品销售排行榜。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_040833.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_040833.png" alt="img"></a></p>
<hr>
<p><em><strong>Zset类型的常用命令：</strong></em></p>
<h4 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h4><p>**<code>ZADD key score member [[score member] [score member] ...]</code>**：将一个或多个元素及其<code>score</code>值添加到有序集合<code>key</code>中。</p>
<blockquote>
<p>如果某个 <code>member</code> 已经是有序集的成员，那么更新这个 <code>member</code> 的 <code>score</code> 值，并通过重新插入这个 <code>member</code> 元素，来保证该 <code>member</code> 在正确的位置上。</p>
<p><code>score</code>是一个用于排序的属性，它的值是整数值或双精度浮点数，<code>score</code>写在<code>member</code>的前面。</p>
<p>如果 <code>key</code> 不存在，则创建一个空的有序集并执行 <code>ZADD</code> 操作。当 <code>key</code> 存在但不是有序集类型时，返回一个错误。</p>
<p>当然还可以加其他参数比如<code>NX</code>、<code>XX</code>、<code>INCR</code>等等，对有序集的更多介绍参见 <a target="_blank" rel="noopener" href="http://redis.io/topics/data-types#sorted-sets">sorted set</a> 。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD userZset 10 Alice 20 Bob 30 Cindy 40 Davie	# 添加四个成员</span><br><span class="line">(integer) 4		# 返回添加成功的个数</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h4><p>**<code>ZCARD key </code>**：返回有序集 <code>key</code> 中成员的个数。当key不存在时返回0，若key不是有序集类型，返回错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZCARD userZset		# 获取有序集userZset中成员的个数</span><br><span class="line">(integer) 4		# 四个</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h4><p>**<code>ZCOUNT key min max</code>**：返回有序集 <code>key</code> 中， <code>score</code> 值在 <code>min</code> 和 <code>max</code> 之间(默认包括 <code>score</code> 值等于 <code>min</code> 或 <code>max</code> )的成员的数量。</p>
<blockquote>
<p>默认情况下，区间的取值使用闭区间(小于等于或大于等于)，也可以通过给参数前增加 <code>(</code> 符号将其改变为开区间。 比如 <code>(1 5</code> 表示 1&lt;score&lt;&#x3D;5，<code>(1 (5</code> 表示 1&lt;score&lt;5。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_191915.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_191915.png" alt="2023-04-08_191915"></a></p>
<hr>
<h4 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h4><p>**<code>ZSOCRE key member</code>**：返回有序集 <code>key </code>中指定成员 <code>member</code> 的 <code>score</code> 值。</p>
<blockquote>
<p>如果 <code>member</code> 元素不是有序集 <code>key</code> 的成员，或 <code>key</code> 不存在，返回 <code>nil</code> 。</p>
<p>返回值：<code>member</code> 成员的 <code>score</code> 值，以字符串形式表示。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_180150.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_180150.png" alt="2023-04-08_180150"></a></p>
<hr>
<h4 id="ZRANGE和ZREVRANGE"><a href="#ZRANGE和ZREVRANGE" class="headerlink" title="ZRANGE和ZREVRANGE"></a>ZRANGE和ZREVRANGE</h4><p>**<code>ZRANGE key start stop [WITHSCORES]</code>*<em>：返回有序集合key中指定区间的成员。</em>从小到大排序*</p>
<blockquote>
<p>其中成员的位置是按score值从小到大排序，具有相同score的车成员按字典序来排列。区间(下标参数)这里不再赘述。</p>
<p><code>WITHSCORES</code> 选项，表示让成员和它的 <code>score</code> 值一并返回，返回列表以 <code>member1,score1, ..., memberN,scoreN</code> 的格式表示。 可能会返回一些更复杂的数据类型，比如数组、元组等。</p>
<p>如果需要按score值从大到小排序，可以适用<code>ZREVRANGE</code>命令。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_044438.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_044438.png" alt="2023-04-08_044438"></a></p>
<p>**<code>ZREVRANGE key start stop [WITHSCORES]</code>*<em>：返回有序集合key中指定区间的成员。</em>从大到小排序*</p>
<blockquote>
<p>成员的位置是按照<code>score</code>值从大到小排序，其余都和<code>ZRANGE</code>一样。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_045728.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_045728.png" alt="2023-04-08_045728"></a></p>
<hr>
<h4 id="ZRANGEBYSCORE和ZREVRANGEBYSCORE"><a href="#ZRANGEBYSCORE和ZREVRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE和ZREVRANGEBYSCORE"></a>ZRANGEBYSCORE和ZREVRANGEBYSCORE</h4><p>**<code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code>*<em>：返回有序集 <code>key</code> 中所有 <code>score</code> 值介于 <code>min</code> 和 <code>max</code> 之间(包括等于 <code>min</code> 或 <code>max</code> )的成员。按score值</em>从小到大排序*</p>
<blockquote>
<p>默认情况下，区间的取值使用闭区间(小于等于或大于等于)，也可以通过给参数前增加 <code>(</code> 符号来使用可选的开区间(小于或大于)。 比如 <code>(1 5</code> 表示 1&lt;score&lt;&#x3D;5，<code>(1 (5</code> 表示 1&lt;score&lt;5。</p>
<p><code>LIMIT</code> 参数限制返回结果的区间(就像SQL中的 <code>SELECT ... LIMIT offset, count</code> )，offset为下标偏移量，count为个数。</p>
<p><code>WITHSCORES</code> 表示将有序集成员及其 <code>score</code> 值一起返回。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_185848.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_185848.png" alt="2023-04-08_185848"></a></p>
<p>**<code>ZREVRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code>*<em>：返回有序集 <code>key</code> 中所有 <code>score</code> 值介于 <code>min</code> 和 <code>max</code> 之间(包括等于 <code>min</code> 或 <code>max</code> )的成员。按score值</em>从大到小排序*，其余参考ZRANGEBYSCORE。</p>
<hr>
<h4 id="ZRANK和ZREVRANK"><a href="#ZRANK和ZREVRANK" class="headerlink" title="ZRANK和ZREVRANK"></a>ZRANK和ZREVRANK</h4><p>**<code>ZRANK key member</code>*<em>：返回有序集 <code>key</code> 中指定成员 <code>member</code> 的排名。</em>从小到大*</p>
<blockquote>
<p>排名按 <code>score</code> 值递增(从小到大)顺序排列。排名以 <code>0</code> 为底，也就是说<code>score</code> 值最小的成员排名为 <code>0</code> 。</p>
<p>使用 <code>ZREVRANK</code> 命令可以获得成员按 <code>score</code> 值递减(从大到小)排列的排名。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_181243.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_181243.png" alt="img"></a></p>
<p>**<code>ZREVRANK key member</code>*<em>：返回有序集 <code>key</code> 中指定成员 <code>member</code> 的排名。</em>从大到小*</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_181658.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_181658.png" alt="2023-04-08_181658"></a></p>
<hr>
<h4 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h4><p>**<code>ZREM key member [member ...]</code>**：移除有序集key中一个或多个成员，不存在的成员将被忽略。</p>
<blockquote>
<p>当key不存在时返回0；当key存在但不是有序集时返回一个错误。</p>
<p>移除成功返回移除成员的数量。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD testZset 10 A 20 B 30 C 40 D 50 E</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; ZREM testZset C D E		# 移除三个成员</span><br><span class="line">(integer) 3		# 移除成功返回3</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h4><p>**<code>ZINCRBY key increment member</code>**：为有序集 <code>key</code> 的成员 <code>member</code> 的 <code>score</code> 值加上增量 <code>increment</code></p>
<blockquote>
<p>可以通过传递一个负数值 ，让 <code>score</code> 减去相应的值，比如 <code>ZINCRBY key -5 member</code> ，就是让 <code>member</code> 的 <code>score</code> 值减去 <code>5</code> 。</p>
<p><strong>返回值</strong>：返回<code>member</code> 成员的新 <code>score</code> 值，以字符串形式表示。 当 <code>key</code> 不是有序集类型时，返回一个错误。 当 <code>key</code> 不存在，或 <code>member</code> 不是 <code>key</code> 的成员时， <code>ZINCRBY key increment member</code> 等同于 <code>ZADD key increment member</code> 。</p>
<p><code>score</code> 值可以是整数值或双精度浮点数。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/image-20230408193813874.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230408193813874.png" alt="image-20230408193813874"></a></p>
<hr>
<h4 id="ZPOPMAX和ZPOPMIN"><a href="#ZPOPMAX和ZPOPMIN" class="headerlink" title="ZPOPMAX和ZPOPMIN"></a>ZPOPMAX和ZPOPMIN</h4><p>**<code>ZPOPMAX key [count]</code>**：删除并返回有序集<code>key</code>中<code>score</code>值最大的一个[或多个]成员。</p>
<p>**<code>ZPOPMIN key [count]</code>**：删除并返回有序集<code>key</code>中<code>score</code>值最小的一个[或多个]成员。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_200015.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_200015.png" alt="2023-04-08_200015"></a></p>
<hr>
<h4 id="ZMPOP"><a href="#ZMPOP" class="headerlink" title="ZMPOP"></a>ZMPOP</h4><p>**<code>ZMPOP numkeys key [key ...] &lt;MIN | MAX&gt; [COUNT count] </code>**：从所提供的键名列表中的第一个非空排序集中弹出一个[或多个]元素，这些元素是成员分数对。</p>
<blockquote>
<p>这个指令就是ZPOPMAX和ZPOPMIN的升级版，可以对多个有序集合进行操作。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_202047.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_202047.png" alt="2023-04-08_202047"></a></p>
<hr>
<h4 id="集合运算-1"><a href="#集合运算-1" class="headerlink" title="集合运算"></a>集合运算</h4><p>集合运算参考Set的集合运算，这里不再赘述。</p>
<blockquote>
<p>ZDIFF：求差集 ZINTER：求交集 ZUNION：求并集</p>
</blockquote>
<hr>
<hr>
<h3 id="六-Bitmap"><a href="#六-Bitmap" class="headerlink" title="六. Bitmap"></a>六. Bitmap</h3><blockquote>
<p><strong>位图</strong></p>
<p>用String类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>位图本质是数组，该数组由多个二进制位组成，其值只能是1或0，默认0，每个二进制位都对应一个偏移量(我们称之为一个索引)。</p>
<p>Bitmap支持的最大位数是2^32位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息。 (512<em>1024</em>1024<em>8&#x3D;2^9</em>2^10<em>2^10</em>2^3&#x3D;2^32)</p>
<p>一个字节占有8位，若在一个bitmap类型的key中，偏移量(索引)为8的位置存入1，前面7位会默认设置为0，那么该key占用两个字节，因为偏移量为8的那一位属于第二个字节了。</p>
<p><em>&#x3D;&#x3D;应用&#x3D;&#x3D;</em> ：由于offset值得范围是[0,2^32-1]，这个数非常大，可以将用户id和偏移量形成映射关系来存储很多二值数据： 通常先将用户存储到哈希表中，通过field值来标识每一位用户，然后再将field值和偏移量形成映射关系，比如 <code>HSET user 1 uid1001 2 uid1002</code> ：1代表uid1001，2代表uid1002 <code>SETBIT sign:Monday 1 1</code> 偏移量1的位置值为1，偏移量1对应用户uid1001（1表示已签到，0表示未签到） <code>SETBIT sign:Monday 2 1</code> 偏移量2的位置值为1，偏移量2对应用户uid1002 …… <code>SETBIT sign:Monday n 1</code> 再通过<code>BITCOUNT sign:Monday</code>就很容易获取Monday签到的用户数量了。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_232347.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_232347.png" alt="2023-04-08_232347"></a></p>
<hr>
<p><em><strong>Bitmap结构的常用命令：</strong></em></p>
<h4 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h4><p>**<code>SETBIT key offset value</code>**：设置key的value(字符串)在offset处的bit值。</p>
<blockquote>
<p>offset：偏移量，从0开始，最大值2^32-1 </p>
<p>返回值：<code>在offset处原来的bit值。</code></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-09_000056.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-09_000056.png" alt="2023-04-09_000056"></a></p>
<hr>
<h4 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h4><p>**<code>GETBIT key offset</code>**：返回key对应的value在offset处的bit值。</p>
<blockquote>
<p>当offset超出了字符串长度的时候，超出的部分就被假定为由0比特填充的连续空间。 当key不存在的时候，它就认为是一个空字符串，所以offset总是超出范围，然后value也被认为是由0比特填充的连续空间。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETBIT mybit 2		# 获取offset为2的值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GETBIT mybit 100	# 获取offset为100的值，100已经超出了该字符串的长度，默认超出的比特位都是0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; STRLEN mybit		# 获取mybit的长度(占用字节数)，因为只存储5位，不够一个字节，所以占用一个字节</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SETBIT mybit 5 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT mybit 6 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT mybit 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT mybit 8 1	# 偏移量8，属于第二个字节了，所以mybit的长度为2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; STRLEN mybit</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h4><p>**<code>BITCOUNT key [start end [byte|bit]]</code>**：统计value中比特位为1的个数。</p>
<blockquote>
<p>可以指定特定的比特位区间或字节区间，只统计该区间上比特位为1的个数。 byte表示一个字节为一个偏移量，bit表示一个位为一个偏移量。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BITCOUNT mybit	# 统计整个字符串value中比特位为1的个数</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT mybit 3 6 bit	# 统计比特位区间[3,6]中比特位为1的个数</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT mybit 1 -1 byte	# 统计第二个字节及以后的字节中比特位为1的个数</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h4><p>**<code>BITOP operation destkey key [key ...]</code>**：对一个或多个保存二进制位的字符串key进行位运算，并将结果保存到destkey中。</p>
<blockquote>
<p>operation有四种操作：AND、OR、NOT、XOR</p>
<ul>
<li><code>BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN</code> ：对一个或多个 key 求按位与（同一列都为1则为1）</li>
<li><code>BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN</code>：对一个或多个 key 求按位或（同一列有一个1即为1）</li>
<li><code>BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN</code>：对一个或多个 key 求按位异或（不同则为1）</li>
<li><code>BITOP NOT destkey srckey</code>：对给定 key 求按位取反（1变0，0变1）</li>
</ul>
<p>返回值：保存到destkey的字符串的长度（多少字节）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 设置一个bitmap类型的bitmap1，存储1 0 1 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap1 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap1 1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap1 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap1 3 0</span><br><span class="line">(integer) 0</span><br><span class="line"># 设置一个bitmap类型的bitmap2，存储1 0 1 1</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap2 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap2 1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap2 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap2 3 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"># 将这两个key做按位与运算，并将结果存到bitmap12中</span><br><span class="line">127.0.0.1:6379&gt; BITOP and bitmap12 bitmap1 bitmap2</span><br><span class="line">(integer) 1		# 返回bitmap12的长度，1个字节</span><br><span class="line"># 获取bitmap12的值</span><br><span class="line">127.0.0.1:6379&gt; GETBIT bitmap12 0	</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GETBIT bitmap12 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; GETBIT bitmap12 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GETBIT bitmap12 3</span><br><span class="line">(integer) 0</span><br><span class="line">可以看到得出的数是1 0 1 0</span><br><span class="line"></span><br><span class="line"># 将bitmap1做按位取反运算</span><br><span class="line">127.0.0.1:6379&gt; BITOP not destkey1 bitmap1</span><br><span class="line">(integer) 1</span><br><span class="line"># 获取destkey1的值</span><br><span class="line">127.0.0.1:6379&gt; GETBIT destkey1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; GETBIT destkey1 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GETBIT destkey1 2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; GETBIT destkey1 3</span><br><span class="line">(integer) 1</span><br><span class="line">可以看到取反后的数为0 1 0 1</span><br></pre></td></tr></table></figure>



<hr>
<hr>
<h3 id="七-HyperLogLog"><a href="#七-HyperLogLog" class="headerlink" title="七. HyperLogLog"></a>七. HyperLogLog</h3><blockquote>
<p><strong>基数统计</strong></p>
<p>HyperLogLog是一种<code>概率</code>数据结构，用于计数唯一的事物(技术上这是指估计一个集合的基数)。 (基数就是一个数据集中<code>去除重复数据后总的个数</code>)</p>
<p>HyperLogLog的数据类型还是String。在Redis中的HyperLogLog，虽然技术上是不同的数据结构，但被编码为Redis字符串。</p>
<p>在Redis里面每个HyperLogLog键只需要花费12kb内存就可以统计接近2^64个不同元素的基数。</p>
<p>HyperLogLog只会根据输入的元素来计算奇数，不会存储输入的元素本身，所以HyperLogLog不能像集合那样返回输入的元素。</p>
</blockquote>
<hr>
<p><em><strong>HyperLogLog结构的常用命令：</strong></em></p>
<h4 id="PFADD"><a href="#PFADD" class="headerlink" title="PFADD"></a>PFADD</h4><p>**<code>PFADD key element [element ...]</code>**：将元素element添加到HyperLogLog结构的key中。</p>
<blockquote>
<p>如果 HyperLogLog 的内部被修改了,那么返回 1,否则返回 0 。</p>
<p>如果在调用该命令时仅提供变量名而不指定元素也是可以的，如果这个变量名存在，则不会有任何操作。如果不存在，则会创建一个数据结构（返回1）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD hll a b c c d d f f g g	# 添加10个元素</span><br><span class="line">(integer) 1		# 添加了10个元素，返回1</span><br><span class="line">127.0.0.1:6379&gt; PFADD hll a b c c d d f f g g	# 重复添加，HLL内部没有改变，返回0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="PFCOUNT"><a href="#PFCOUNT" class="headerlink" title="PFCOUNT"></a>PFCOUNT</h4><p>**<code>PFCOUNT key [key ...]</code>**：返回给定HyperLogLog结构的key的基数。</p>
<blockquote>
<p>当参数为一个key时，返回存储在HyperLogLog结构体的该key的近似基数，如果该变量不存在，则返回0。</p>
<p>当参数为多个key时，返回这些HyperLogLog并集的近似基数，这个值是将所给定的所有key的HyperLoglog结构合并到一个临时的HyperLogLog结构中计算而得到的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD hll a b c c d d f f g g</span><br><span class="line">(integer) 0	</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT hll		# 统计hll的基数（去重统计）</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="PFMERGE"><a href="#PFMERGE" class="headerlink" title="PFMERGE"></a>PFMERGE</h4><p>**<code>PFMERGE destkey [sourcekey [sourcekey ...]]</code>**：将多个HyperLogLog合并成一个HyperLogLog。</p>
<blockquote>
<p>destkey是合并后的HyperLogLog结构。</p>
<p>这个命令可以用PFCOUNT命令实现。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD hll1 a a b b c c d e f	# 创建一个HyperLogLog结构的hll1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFADD hll2 d e f g g h h i i	# 创建一个HyperLogLog结构的hll2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE hll3 hll1 hll2			# 合并这两个HyperLogLog结构的key</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT hll3					# 统计合并后HyperLogLog结构的hll3的基数</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT hll1 hll2				# 直接统计hll1和hll2</span><br><span class="line">(integer) 9</span><br></pre></td></tr></table></figure>



<hr>
<hr>
<h3 id="八-Geospatial"><a href="#八-Geospatial" class="headerlink" title="八. Geospatial"></a>八. Geospatial</h3><blockquote>
<p><strong>地理空间</strong></p>
<p>Redis<code>地理空间</code>索引可以存储坐标并搜索它们。此数据结构用于在给定半径或包围框内查找附近点。</p>
<p>Geopatial的数据类型是Zset，相当于由之前的<code>score</code>变成了<code>longitude</code>和<code>latitude</code>，可以使用Zset的命令对其进行操作。</p>
</blockquote>
<hr>
<p><em><strong>Geospatial结构的常用命令：</strong></em></p>
<h4 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h4><p><strong><code>GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]</code></strong></p>
<blockquote>
<p>将指定的地理空间项(经度、纬度、名称)添加到地理空间结构的key中。</p>
<p>数据以有序集的形式存储到键中，这样就可以使用GEOSEARCH命令查询项。</p>
<p>规定如下：</p>
<ul>
<li>有效的经度从-180度到180度。</li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
</ul>
<p>当坐标位置超出上述指定范围时，该命令将会返回一个错误。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD city 116.403963 39.915119 &quot;天安门&quot; 116.403414 39.924091 &quot;故宫&quot; 116.024067 40.362639 &quot;长城&quot;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-09_051719.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-09_051719.png" alt="2023-04-09_051719"></a></p>
<p>注意：使用–raw启动客户端后，返回数据的类型以及编号不会显示了</p>
<hr>
<h4 id="GEOPOS"><a href="#GEOPOS" class="headerlink" title="GEOPOS"></a>GEOPOS</h4><p>**<code>GEOPOS key member [member ...]</code>**：从给定的key里返回所有指定member的位置(经度和纬度)，不存在的member返回nil。</p>
<blockquote>
<p>GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。给定的位置元素不存在时， 对应的数组项为空值。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOPOS city 天安门 故宫 长城</span><br><span class="line">116.40396326780319214</span><br><span class="line">39.91511970338637383</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line">116.02406591176986694</span><br><span class="line">40.36263993239462167</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h4><p>**<code>GEOHASH key member [member ...]</code>**：获取一个或多个<code>member</code>的geohash值。</p>
<blockquote>
<p>通常使用表示位置的元素使用不同的技术，使用Geohash位置52点整数编码。 由于编码和解码过程中所使用的初始最小和最大坐标不同，编码的编码也不同于标准。此命令返回一个标准的Geohash。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOHASH city 天安门 故宫 长城</span><br><span class="line">wx4g0f6f2v0</span><br><span class="line">wx4g0gfqsj0</span><br><span class="line">wx4t85y1kt0</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h4><p>**<code>GEODIST key member1 member2 [M | KM | FT | MI]</code>**：返回两个给定<code>member</code>之间的距离。</p>
<blockquote>
<p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>如果用户没有显式地指定单位参数， 那么 <code>GEODIST</code> 默认使用M作为单位。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEODIST city 天安门 长城</span><br><span class="line">59338.9814		# 天安门距离长城59338.9814米</span><br><span class="line">127.0.0.1:6379&gt; GEODIST city 天安门 长城 km</span><br><span class="line">59.3390			# 天安门距离长城59.3390千米</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="GEORADIUS"><a href="#GEORADIUS" class="headerlink" title="GEORADIUS"></a>GEORADIUS</h4><p><strong><code>GEORADIUS key longitude latitude radius &lt;M | KM | FT | MI&gt; [WITHCOORD] [WITHDIST] [WITHHASH] </code></strong> <strong><code>[COUNT count [ANY]] [ASC | DESC] [STORE key] [STOREDIST key]</code></strong></p>
<blockquote>
<p>以给定的经纬度为中心， 返回key包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p>
<p>radius：半径</p>
<p>WITHDIST：在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</p>
<p>WITHCOORD： 将位置元素的经度和维度也一并返回。</p>
<p>WITHHASH：将geohash值一并返回。</p>
<p>COUNT ：限定返回的记录数。</p>
<p>ASC：由近到远返回（升序）</p>
<p>DESC：由远到近返回（降序）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">假设当前位置北京王府井(116.418017 39.914402)</span><br><span class="line"># 由近到远排序</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS city 116.418017 39.914402 10 km withdist withcoord withhash count 10</span><br><span class="line">天安门					  # member</span><br><span class="line">1.2016					# 天安门距离北京王府井1.2km</span><br><span class="line">4069885555089531		# geohash值</span><br><span class="line">116.40396326780319214	# 经度值</span><br><span class="line">39.91511970338637383	# 纬度值</span><br><span class="line">故宫</span><br><span class="line">1.6470					# 故宫距离北京王府井1.6km</span><br><span class="line">4069885568908290</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line"># 由远到近排序</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS city 116.418017 39.914402 10 km withdist withcoord withhash count 10 desc</span><br><span class="line">故宫</span><br><span class="line">1.6470</span><br><span class="line">4069885568908290</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line">天安门</span><br><span class="line">1.2016</span><br><span class="line">4069885555089531</span><br><span class="line">116.40396326780319214</span><br><span class="line">39.91511970338637383</span><br><span class="line"># 将半径改为70km，这样长城也在范围内</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS city 116.418017 39.914402 70 km withdist withcoord withhash count 10 desc</span><br><span class="line">长城</span><br><span class="line">60.0642					# 长城距离北京王府井60km</span><br><span class="line">4069895262981475</span><br><span class="line">116.02406591176986694</span><br><span class="line">40.36263993239462167</span><br><span class="line">故宫</span><br><span class="line">1.6470</span><br><span class="line">4069885568908290</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line">天安门</span><br><span class="line">1.2016</span><br><span class="line">4069885555089531</span><br><span class="line">116.40396326780319214</span><br><span class="line">39.91511970338637383</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="GEORADIUSBYMEMBER"><a href="#GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUSBYMEMBER"></a>GEORADIUSBYMEMBER</h4><p><strong><code>GEORADIUSBYMEMBER key member radius &lt;M | KM | FT | MI&gt; [WITHCOORD] [WITHDIST] [WITHHASH] </code></strong> <strong><code>[COUNT count [ANY]] [ASC | DESC] [STORE key] [STOREDIST key]</code></strong></p>
<blockquote>
<p>以给定的位置元素为中心点，找出位于指定范围内的元素。其他和GEORADIUS命令一样。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 获取距离天安10km范围内的位置元素</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER city 天安门 10 km withdist withcoord withhash count 10 desc</span><br><span class="line">故宫</span><br><span class="line">0.9988</span><br><span class="line">4069885568908290</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line">天安门</span><br><span class="line">0.0000</span><br><span class="line">4069885555089531</span><br><span class="line">116.40396326780319214</span><br><span class="line">39.91511970338637383</span><br></pre></td></tr></table></figure>



<hr>
<hr>
<h3 id="九-Stream"><a href="#九-Stream" class="headerlink" title="九. Stream"></a>九. Stream</h3><blockquote>
<p><strong>流</strong></p>
<p>Redis流是一种数据结构（Stream类型），它的作用类似于只能追加的日志。您可以使用流来实时记录和同时聚合事件。</p>
<p>Redis流用例示例包括:</p>
<ul>
<li>事件来源(例如，跟踪用户操作、点击等)</li>
<li>传感器监测(例如，来自现场设备的读数)</li>
<li>通知(例如，在单独的流中存储每个用户通知的记录)</li>
</ul>
<p>Redis为每个流消息生成一个唯一的ID，可以使用这些id检索它们关联的消息，或者读取和处理流中的所有后续消息。</p>
<p>四种和ID有关的特殊符号： <code>-</code>和<code>+</code>：当前流中最小ID和最大ID <code>$</code>：表示大于当前流中最大的id，用于新添加的消息 <code>&gt;</code>：用于XREANGROUP命令，表示迄今没有发送给组中使用者的信息，会更新消费者组的最后ID <code>*</code>：用于XADD命令中，表示让系统自动生成ID</p>
</blockquote>
<p>Stream流就是Redis版的MQ消息中间件+阻塞队列，它能实现消息队列，它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/stream%E5%8E%9F%E7%90%86.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/stream%E5%8E%9F%E7%90%86.png" alt="stream原理"></a></p>
<blockquote>
<p>Message Content：消息内容</p>
<p>Consumer group：消费组，通过XGROUP CREATE 命令创建，同一个消费组可以有多个消费者</p>
<p>Last_delivered_id：游标，每个消费组会有个游标 last_delivered_id，任意一消费者读取了消息都会使游标 last_delivered_id 往前移动。</p>
<p>Consumer：消费者，消费组中的消费者</p>
<p>Pending_ids：消费者会有一个状态变量，用于记录被当前消费已读取但未ack的消息Id，如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack它就开始减少。这个pending_ids变量在Redis官方被称之为 PEL(Pending Entries List)，记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</p>
</blockquote>
<hr>
<p><em><strong>Stream类型的常用命令：</strong></em></p>
<h4 id="XADD"><a href="#XADD" class="headerlink" title="XADD"></a>XADD</h4><p><strong><code>XADD key [NOMKSTREAM] [&lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count]] &lt;\* | id&gt; field value [field value ...] </code></strong></p>
<blockquote>
<p>将消息追加到指定流<code>key</code>的末尾，添加的消息ID要比上个消息的ID大。如果key不存在，将自动创建流key然后执行XADD操作。</p>
<p>ID用于标识给定消息，如果指定的ID参数是字符<code>*</code>，<code>XADD</code>命令会自动生成一个唯一的ID。ID是由时间戳-序列号两部分组成，当自动生成ID时，第一部分是生成ID的Redis实例的毫秒格式的Unix时间。 第二部分是一个序列号，用来区分同一毫秒内生成的ID的。序列号是64位长度(18446744073709551615)，理论上在同一毫秒内生成的数据量无法到达这个级别，因此不用担心序列号会不够用。</p>
<p>该命令返回添加的消息的ID。如果ID参数传的是<code>*</code>，那么ID是自动生成的， 否则，命令仅返回用户在插入期间指定的相同的ID。</p>
<p>通常使用命令<code>XADD ID filed value [field value ...]</code>，其他的花里胡哨的参数了解即可。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XADD mystream * name tom age 20	# 添加一条消息到mystream队列末尾，自动生成id</span><br><span class="line">&quot;1681002319038-0&quot;	# 返回生成消息的id</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681002319038-0 name tom age 20	# 如果添加消息的id不比上一消息id大，则报错</span><br><span class="line">(error) ERR The ID specified in XADD is equal or smaller than the target stream top item</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681002319038-1 name tom age 20	# 比上一消息id大，添加成功，返回添加消息的id</span><br><span class="line">&quot;1681002319038-1&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XRANGE"><a href="#XRANGE" class="headerlink" title="XRANGE"></a>XRANGE</h4><p>**<code>XRANGE key start end [COUNT count]</code>**：返回给定id范围内流key的消息。</p>
<blockquote>
<p>id范围由[start,end]指定。特殊ID：<code>-</code> 表示流中最小的消息id，<code>+</code>表示流中最大的消息id。</p>
<p>返回的消息由id从小到大排序。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XADD mystream * name Alice age 20</span><br><span class="line">&quot;1681003546319-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream * name Bob age 21</span><br><span class="line">&quot;1681003556153-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream * name Cindy age 22</span><br><span class="line">&quot;1681003570177-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream * name Davie age 23</span><br><span class="line">&quot;1681003595504-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +		# - + 表示返回流mystream中所有的消息，且根据id从小到大排序</span><br><span class="line">1) 1) &quot;1681003546319-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Alice&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">2) 1) &quot;1681003556153-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Bob&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br><span class="line">3) 1) &quot;1681003570177-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br><span class="line">4) 1) &quot;1681003595504-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;23&quot;</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - + count 2		# 限制返回两个</span><br><span class="line">1) 1) &quot;1681003546319-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Alice&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">2) 1) &quot;1681003556153-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Bob&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XREVRANGE"><a href="#XREVRANGE" class="headerlink" title="XREVRANGE"></a>XREVRANGE</h4><p>**<code>XREVRANGE key end start [COUNT count]</code>**：返回给定id范围内流key的消息。</p>
<blockquote>
<p>在<code>XREVRANGE</code>中，要先指定结束ID，再指定开始ID，返回消息的顺序是根据id从大到小排序。其余和XRANGE一样。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREVRANGE mystream + -</span><br><span class="line">1) 1) &quot;1681003595504-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;23&quot;</span><br><span class="line">2) 1) &quot;1681003570177-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br><span class="line">3) 1) &quot;1681003556153-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Bob&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br><span class="line">4) 1) &quot;1681003546319-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Alice&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREVRANGE mystream + - count 2</span><br><span class="line">1) 1) &quot;1681003595504-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;23&quot;</span><br><span class="line">2) 1) &quot;1681003570177-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XDEL"><a href="#XDEL" class="headerlink" title="XDEL"></a>XDEL</h4><p>**<code>XDEL key id [id ...]</code>**：从流key中删除指定id(消息)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XDEL mystream 1681003595504-0 1681003556153-0	# 删除Bob和Davie对应的id</span><br><span class="line">(integer) 2		# 成功删除两个</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1681003546319-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Alice&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">2) 1) &quot;1681003570177-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XLEN"><a href="#XLEN" class="headerlink" title="XLEN"></a>XLEN</h4><p>**<code>XLEN mystream</code>**：返回流key中消息的条数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XLEN mystream	# 流mystream中有两条消息</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XTRIM"><a href="#XTRIM" class="headerlink" title="XTRIM"></a>XTRIM</h4><p>**<code>XTRIM key &lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count]</code>**：将流消息裁剪为指定数量的消息。</p>
<blockquote>
<p>MAXLEN：表示允许最大的消息长度(个数)，超过此数量会优先删除id较小的消息。</p>
<p>MINID：表示允许最小的id，比此id还小的消息会被删除。</p>
<p>返回值：删除消息的数量。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 创建五条消息存入流mystream中</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-0 name Alice age 18</span><br><span class="line">&quot;1681006080120-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-1 name Bob age 19</span><br><span class="line">&quot;1681006080120-1&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-2 name Cindy age 20</span><br><span class="line">&quot;1681006080120-2&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-3 name Davie age 21</span><br><span class="line">&quot;1681006080120-3&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-4 name Eric age 22</span><br><span class="line">&quot;1681006080120-4&quot;</span><br><span class="line">127.0.0.1:6379&gt; XTRIM mystream maxlen 3		# 获取最近的3条消息，id较小的被删除（id是递增的）</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1681006080120-2&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">2) 1) &quot;1681006080120-3&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br><span class="line">3) 1) &quot;1681006080120-4&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Eric&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;	</span><br><span class="line">127.0.0.1:6379&gt; XTRIM mystream minid 1681006080120-3	# 获取id不小于1681006080120-3的消息</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1681006080120-3&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br><span class="line">2) 1) &quot;1681006080120-4&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Eric&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XREAD"><a href="#XREAD" class="headerlink" title="XREAD"></a>XREAD</h4><p><strong><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id  [id ...]</code></strong></p>
<blockquote>
<p>从一个或者多个流中读取数据，仅返回id大于对应流中最大id的消息（也就是新添加的消息）。</p>
<p>count：最多读取多少条</p>
<p>block：是否以阻塞的方式读取，如果开启且milliseconds设为0，表示永远阻塞直到读取到消息。</p>
<p>id：表示读取ID大于指定id的消息。</p>
<p>特殊ID：符号<code>$</code>。表示以当前Stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，因此此时返回nil。一般用于阻塞队列获取新消息。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># 数据准备，创建两个流stream1和stream2</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-0 name Alice</span><br><span class="line">&quot;1681006080120-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-1 name Bob</span><br><span class="line">&quot;1681006080120-1&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-2 name Cindy</span><br><span class="line">&quot;1681006080120-2&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-3 name Davie</span><br><span class="line">&quot;1681006080120-3&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-4 name Eric</span><br><span class="line">&quot;1681006080120-4&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-0 1 one</span><br><span class="line">&quot;1681008731850-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-1 2 two</span><br><span class="line">&quot;1681008731850-1&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-2 3 three</span><br><span class="line">&quot;1681008731850-2&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-3 4 four</span><br><span class="line">&quot;1681008731850-3&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-4 5 five</span><br><span class="line">&quot;1681008731850-4&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-5 6 six</span><br><span class="line">&quot;1681008731850-5&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 streams stream1 0-0	# count 3表示只获取3个，0-0表示从最小的ID开始获取Stream中的消息</span><br><span class="line">1) 1) &quot;stream1&quot;</span><br><span class="line">   2) 1) 1) &quot;1681006080120-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Alice&quot;</span><br><span class="line">      2) 1) &quot;1681006080120-1&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Bob&quot;</span><br><span class="line">      3) 1) &quot;1681006080120-2&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Cindy&quot;</span><br><span class="line">            </span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 streams stream1 0		# 使用0也可以表示从最小的ID开始获取Stream中的消息，000也可以</span><br><span class="line">1) 1) &quot;stream1&quot;</span><br><span class="line">   2) 1) 1) &quot;1681006080120-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Alice&quot;</span><br><span class="line">      2) 1) &quot;1681006080120-1&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Bob&quot;</span><br><span class="line">      3) 1) &quot;1681006080120-2&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Cindy&quot;</span><br><span class="line">            </span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 streams stream1 $		# $表示读取大于当前流中最大的id的消息</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 读取stream1中id大于1681006080120-2的三条消息，读取stream2中id大于1681008731850-3的三条消息</span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 block 0 streams stream1 stream2 1681006080120-2 1681008731850-3</span><br><span class="line">1) 1) &quot;stream1&quot;					# 读取到了stream1中id大于1681006080120-2的3条消息（如果有多条则读取最新的消息）</span><br><span class="line">   2) 1) 1) &quot;1681006080120-3&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Davie&quot;</span><br><span class="line">      2) 1) &quot;1681006080120-4&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Eric&quot;</span><br><span class="line">      3) 1) &quot;1681008731850-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Jack&quot;</span><br><span class="line">2) 1) &quot;stream2&quot;					# stream2中有两条id大于1681008731850-3的消息</span><br><span class="line">   2) 1) 1) &quot;1681008731850-4&quot;</span><br><span class="line">         2) 1) &quot;5&quot;</span><br><span class="line">            2) &quot;five&quot;</span><br><span class="line">      2) 1) &quot;1681008731850-5&quot;</span><br><span class="line">         2) 1) &quot;6&quot;</span><br><span class="line">            2) &quot;six&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 加入阻塞选项，此时开启另一个redis客户端存入消息到stream1中，观察当前客户端的变化</span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 block 0 streams stream1 $</span><br><span class="line">1) 1) &quot;stream1&quot;</span><br><span class="line">   2) 1) 1) &quot;1681008731850-0&quot;	# 读取到了一条消息</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Jack&quot;</span><br><span class="line">(53.24s)	# 等待了53.24s</span><br></pre></td></tr></table></figure>



<hr>
<p><em><strong>消费组相关指令</strong></em></p>
<h4 id="XGROUP"><a href="#XGROUP" class="headerlink" title="XGROUP"></a>XGROUP</h4><p>**<code>XGROUP CREATE key group &lt;id | $&gt; </code>**：创建消费者组。</p>
<blockquote>
<p>最后一个参数是要考虑已传递的流中最后一项的ID。</p>
<p>$表示从Stream尾部开始消费，在这种情况下，从该消费者组获取数据的消费者只能看到到达流的新元素。</p>
<p>0表示从Stream头部开始消费，消费者组可以获取整个流的历史记录。</p>
<p>创建消费者组的时候必须指定 ID, ID 为 0 表示从头开始消费，为 $ 表示只消费新的消息。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建消费者组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create mystream1 groupA $</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create mystream1 groupB 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>



<p>**<code>XGROUP CREATECONSUMER key group consumer</code>**：创建消费者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP CREATECONSUMER mystream1 groupA consumerA	#在流mystream1的groupA中创建消费者consumerA</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XINFO CONSUMERS mystream1 groupA	# 查看流mystream1的消费组groupA的消费者信息</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;consumerA&quot;	# 消费者名称</span><br><span class="line">   3) &quot;pending&quot;		</span><br><span class="line">   4) (integer) 0	# 消费者读取消息的数量（此时还未读取消息，所以为0）</span><br><span class="line">   5) &quot;idle&quot;</span><br><span class="line">   6) (integer) 26277</span><br></pre></td></tr></table></figure>



<p>**<code>XGROUP DESTORY key group</code>**：删除流key中指定的消费组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP create mystream1 groupC 0	# 在流stream1中创建消费组groupC</span><br><span class="line">OK</span><br><span class="line"># 删除消费组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP DESTROY mystream1 groupC	# 删除流stream1中的消费组groupC</span><br><span class="line">(integer) 1		# 返回删除的个数</span><br></pre></td></tr></table></figure>



<p>**<code>XGROUP DELCONSUMER key group consumer</code>**：删除流key中消费组group的指定消费者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP CREATECONSUMER mystream1 groupA consumerA</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XGROUP DELCONSUMER mystream1 groupA consumerA</span><br><span class="line">(integer) 0		</span><br><span class="line">127.0.0.1:6379&gt; XINFO CONSUMERS mystream1 groupA</span><br><span class="line">(empty array)	# 消费者consumerA已经被删除</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XREADGROUP"><a href="#XREADGROUP" class="headerlink" title="XREADGROUP"></a>XREADGROUP</h4><p><strong><code>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]</code></strong></p>
<blockquote>
<p>读取消费者组中的消息。</p>
<p>消费者不存在则自动创建该消费者。</p>
<p>特殊ID：<code>&gt;</code>表示从第一条未被消费的消息开始读取。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 创建消费组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create stream1 groupA 0</span><br><span class="line">ok</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create stream1 groupB 0</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 消费组groupA内的消费者consumer1从stream1消息队列中读取所有信息</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer1 STREAMS stream1  &gt;	# &gt;表示从第一条未被消费的消息开始读取。</span><br><span class="line">1) 1) &quot;stream1&quot;</span><br><span class="line">   2) 1) 1) &quot;1681006080120-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Alice&quot;</span><br><span class="line">      2) 1) &quot;1681006080120-1&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Bob&quot;</span><br><span class="line">      3) 1) &quot;1681006080120-2&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Cindy&quot;</span><br><span class="line">      4) 1) &quot;1681006080120-3&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Davie&quot;</span><br><span class="line">      5) 1) &quot;1681006080120-4&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Eric&quot;</span><br><span class="line">      6) 1) &quot;1681008731850-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Jack&quot;</span><br><span class="line"># 消费组groupA中消费者consumer1一口气读取完所有消息，组中其他消费者就不能读取消息了（同一个消费组里的消费者不能消费同一条消息）</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer2 STREAMS stream1  &gt;	</span><br><span class="line">(nil)	# 已经被消费者cumstomer1消费完了，所以返回nil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建消费组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create stream2 groupA 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create stream2 groupB 0</span><br><span class="line">OK</span><br><span class="line"># 让组内的多个消费者共同分担读取消息，所以让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer1 count 3 STREAMS stream2 &gt;		# 限制读取3个</span><br><span class="line">1) 1) &quot;stream2&quot;</span><br><span class="line">   2) 1) 1) &quot;1681008731850-0&quot;</span><br><span class="line">         2) 1) &quot;1&quot;</span><br><span class="line">            2) &quot;one&quot;</span><br><span class="line">      2) 1) &quot;1681008731850-1&quot;</span><br><span class="line">         2) 1) &quot;2&quot;</span><br><span class="line">            2) &quot;two&quot;</span><br><span class="line">      3) 1) &quot;1681008731850-2&quot;</span><br><span class="line">         2) 1) &quot;3&quot;</span><br><span class="line">            2) &quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer2 count 3 STREAMS stream2 &gt;		# 读取另外三个</span><br><span class="line">1) 1) &quot;stream2&quot;</span><br><span class="line">   2) 1) 1) &quot;1681008731850-3&quot;</span><br><span class="line">         2) 1) &quot;4&quot;</span><br><span class="line">            2) &quot;four&quot;</span><br><span class="line">      2) 1) &quot;1681008731850-4&quot;</span><br><span class="line">         2) 1) &quot;5&quot;</span><br><span class="line">            2) &quot;five&quot;</span><br><span class="line">      3) 1) &quot;1681008731850-5&quot;</span><br><span class="line">         2) 1) &quot;6&quot;</span><br><span class="line">            2) &quot;six&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer3 count 3 STREAMS stream2 &gt;</span><br><span class="line">(nil)		# 已经没有消息可读，返回nil</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XPENDING"><a href="#XPENDING" class="headerlink" title="XPENDING"></a>XPENDING</h4><p>**<code>XPENDING key group</code>**：返回待处理消息相关信息。（读取到的消息没有经过XACK确认即为待处理消息）</p>
<blockquote>
<p>返回一组数据，包括消费组待处理消息的数量、所有消费者读取的消息最小id、所有消费者所读取id的最大值、每个消费者待处理消息的数量。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XPENDING stream1 groupA</span><br><span class="line">1) (integer) 6			# 待处理消息数</span><br><span class="line">2) &quot;1681006080120-0&quot;	# 待处理消息最小id</span><br><span class="line">3) &quot;1681008731850-0&quot;	# 待处理消息最大id</span><br><span class="line">4) 1) 1) &quot;consumer1&quot;	# 消费者consumer1</span><br><span class="line">      2) &quot;6&quot;			# 消费者consumer1有6条待处理消息</span><br><span class="line">127.0.0.1:6379&gt; XPENDING stream2 groupA</span><br><span class="line">1) (integer) 6			# 待处理消息数</span><br><span class="line">2) &quot;1681008731850-0&quot;	# 待处理消息最小id</span><br><span class="line">3) &quot;1681008731850-5&quot;	# 待处理消息最大id</span><br><span class="line">4) 1) 1) &quot;consumer1&quot;	# 消费者consumer1</span><br><span class="line">      2) &quot;3&quot;			# 消费者consumer1有3条待处理消息</span><br><span class="line">   2) 1) &quot;consumer2&quot;	# 消费者consumer2</span><br><span class="line">      2) &quot;3&quot;			# 消费者consumer2有3条待处理消息</span><br></pre></td></tr></table></figure>



<p>**<code>XPENDING key group start end count consumer</code>**：查看指定消费者具体读取了哪些数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看消费者consumer1具体读取了哪些数据</span><br><span class="line">127.0.0.1:6379&gt; XPENDING stream2 groupA - + 5 consumer1	# 查看groupA组consumer1具体读取了哪些数据，设置最大返回5条</span><br><span class="line">1) 1) &quot;1681008731850-0&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) (integer) 2089450</span><br><span class="line">   4) (integer) 1</span><br><span class="line">2) 1) &quot;1681008731850-1&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) (integer) 2089450</span><br><span class="line">   4) (integer) 1</span><br><span class="line">3) 1) &quot;1681008731850-2&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) (integer) 2089450</span><br><span class="line">   4) (integer) 1</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XACK"><a href="#XACK" class="headerlink" title="XACK"></a>XACK</h4><p>**<code>XACK key group id [id ...]</code>**：向消息队列确认id对应的消息已处理完成，XACK会从待处理消息列表中删除该消息。</p>
<blockquote>
<p>返回值：该命令返回成功确认的消息数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XACK stream1 groupA 1681006080120-0	# 确认id1681006080120-0处理完成</span><br><span class="line">(integer) 1		# 成功确认一条</span><br><span class="line">127.0.0.1:6379&gt; XPENDING stream1 groupA</span><br><span class="line">1) (integer) 5	# 待确认消息数减1</span><br><span class="line">2) &quot;1681006080120-1&quot;</span><br><span class="line">3) &quot;1681008731850-0&quot;</span><br><span class="line">4) 1) 1) &quot;consumer1&quot;</span><br><span class="line">      2) &quot;5&quot;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="XINFO"><a href="#XINFO" class="headerlink" title="XINFO"></a>XINFO</h4><p>**<code>XINFO stream key</code>**：获取流key的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XINFO stream stream2 	# 获取流stream2的详细信息</span><br><span class="line"> 1) &quot;length&quot;</span><br><span class="line"> 2) (integer) 6</span><br><span class="line"> 3) &quot;radix-tree-keys&quot;</span><br><span class="line"> 4) (integer) 1</span><br><span class="line"> 5) &quot;radix-tree-nodes&quot;</span><br><span class="line"> 6) (integer) 2</span><br><span class="line"> 7) &quot;last-generated-id&quot;</span><br><span class="line"> 8) &quot;1681008731850-5&quot;</span><br><span class="line"> 9) &quot;max-deleted-entry-id&quot;</span><br><span class="line">10) &quot;0-0&quot;</span><br><span class="line">11) &quot;entries-added&quot;</span><br><span class="line">12) (integer) 6</span><br><span class="line">13) &quot;recorded-first-entry-id&quot;</span><br><span class="line">14) &quot;1681008731850-0&quot;</span><br><span class="line">15) &quot;groups&quot;</span><br><span class="line">16) (integer) 2</span><br><span class="line">17) &quot;first-entry&quot;</span><br><span class="line">18) 1) &quot;1681008731850-0&quot;</span><br><span class="line">    2) 1) &quot;1&quot;</span><br><span class="line">       2) &quot;one&quot;</span><br><span class="line">19) &quot;last-entry&quot;</span><br><span class="line">20) 1) &quot;1681008731850-5&quot;</span><br><span class="line">    2) 1) &quot;6&quot;</span><br><span class="line">       2) &quot;six&quot;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>



<p>**<code>XINFO GROUPS key</code>**：获取流key中消费组信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XINFO GROUPS stream2	# 获取流stream2中的消费组信息</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;groupA&quot;		# 消费组groupA</span><br><span class="line">    3) &quot;consumers&quot;</span><br><span class="line">    4) (integer) 2</span><br><span class="line">    5) &quot;pending&quot;</span><br><span class="line">    6) (integer) 6</span><br><span class="line">    7) &quot;last-delivered-id&quot;</span><br><span class="line">    8) &quot;1681008731850-5&quot;</span><br><span class="line">    9) &quot;entries-read&quot;</span><br><span class="line">   10) (integer) 6</span><br><span class="line">   11) &quot;lag&quot;</span><br><span class="line">   12) (integer) 0</span><br><span class="line">2)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;groupB&quot;		# 消费组groupB</span><br><span class="line">    3) &quot;consumers&quot;</span><br><span class="line">    4) (integer) 1</span><br><span class="line">    5) &quot;pending&quot;</span><br><span class="line">    6) (integer) 3</span><br><span class="line">    7) &quot;last-delivered-id&quot;</span><br><span class="line">    8) &quot;1681008731850-2&quot;</span><br><span class="line">    9) &quot;entries-read&quot;</span><br><span class="line">   10) (integer) 3</span><br><span class="line">   11) &quot;lag&quot;</span><br><span class="line">   12) (integer) 3</span><br></pre></td></tr></table></figure>



<p>**<code>XINFO CONSUMERS key group</code>**：获取流key中消费组group中消费者信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XINFO CONSUMERS stream2 groupA	# 获取流stream2中消费组groupA中的消费者信息</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) &quot;pending&quot;</span><br><span class="line">   4) (integer) 3</span><br><span class="line">   5) &quot;idle&quot;</span><br><span class="line">   6) (integer) 30195569</span><br><span class="line">2) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;consumer2&quot;</span><br><span class="line">   3) &quot;pending&quot;</span><br><span class="line">   4) (integer) 3</span><br><span class="line">   5) &quot;idle&quot;</span><br><span class="line">   6) (integer) 30166362</span><br></pre></td></tr></table></figure>



<hr>
<hr>
<h3 id="十-Bitfield"><a href="#十-Bitfield" class="headerlink" title="十. Bitfield"></a>十. Bitfield</h3><blockquote>
<p><strong>位域</strong></p>
<p>Bitfield结构的底层也是String类型。<code>是一个操作位数据的数据结构,用于压缩数据，节省内存</code></p>
<p>Redis位字段允许设置、递增和获取任意位长度的整数值。例如可以对从无符号1位整数到有符号63位整数的任何数字进行操作。</p>
<p>这些值使用二进制编码的Redis字符串存储。位字段支持原子读、写和递增操作，这使它们成为管理计数器和类似数值的好选择。</p>
<p>例如 hello 等价于 0110100001100101011011000110110001101111，每八位对应一个字母，也对应一个十进制值。可以修改每一位的数字从而改变对应的数值从而改变对应的字母。</p>
</blockquote>
<hr>
<p><em><strong>Bitfield结构的常用命令：</strong></em></p>
<h4 id="BITFIELD"><a href="#BITFIELD" class="headerlink" title="BITFIELD"></a>BITFIELD</h4><p><strong><code>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] </code></strong> <strong><code>[OVERFLOW WRAP|SAT|FAIL]</code></strong></p>
<blockquote>
<p>此命令会把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。</p>
<p>下面是已支持的命令列表：</p>
<ul>
<li>GET ：返回指定的位域的数值。</li>
<li>SET ： 设置指定位域的数值并返回它的原值。</li>
<li>INCRBY ： 自增或自减（如果increment为负数）指定位域的值并返回它的新值。</li>
</ul>
<p>type表示多少位的有符号还是无符号整型。有符号整型需在位数前加<code>i</code>，无符号在位数前加<code>u</code>。例如，<code>u8</code>是一个8位的无符号整型，<code>i16</code>是一个16位的有符号整型。offset表示偏移量，比如i4表示以4个比特位为一个偏移量。</p>
<p>还有一个命令通过设置溢出行为来改变调用<code>INCRBY</code>指令的后序操作：OVERFLOW [WRAP|SAT|FAIL] wrap：使用回环方式处理有符号整数和无符号整数的溢出情况。 sat：使用饱和计算方式处理溢出，下溢计算的结果为最小的整数值，上溢计算的结果为最大的整数值。 fail：命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行。</p>
<p>有符号整型最大支持64位，而无符号整型最大支持63位。对无符号整型的限制，是由于当前Redis协议不能在响应消息中返回64位无符号整数。</p>
</blockquote>
<table>
<thead>
<tr>
<th>字母</th>
<th>数值</th>
<th>二进制（高位-&gt;低位）</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>104</td>
<td>0110 1000</td>
</tr>
<tr>
<td>e</td>
<td>101</td>
<td>0110 0101</td>
</tr>
<tr>
<td>l</td>
<td>108</td>
<td>0110 1100</td>
</tr>
<tr>
<td>l</td>
<td>108</td>
<td>0110 1100</td>
</tr>
<tr>
<td>o</td>
<td>111</td>
<td>0110 1111</td>
</tr>
<tr>
<td>x</td>
<td>120</td>
<td>0111 1000</td>
</tr>
</tbody></table>
<ul>
<li><strong>GET和SET选项</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set mybitfield hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 0	# 以8位位一组，偏移量0表示第一个字符</span><br><span class="line">1) (integer) 104	# 返回该字符对应的十进制值数值</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 8	# 偏移量8表示第二个字符</span><br><span class="line">1) (integer) 101</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 16</span><br><span class="line">1) (integer) 108</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 24</span><br><span class="line">1) (integer) 108</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 32</span><br><span class="line">1) (integer) 111</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield set i8 32 120	#将偏移量为32的那一组的数值替换为120(字母x)</span><br><span class="line">1) (integer) 111</span><br><span class="line">127.0.0.1:6379&gt; get mybitfield</span><br><span class="line">hellx</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>INCRBY选项</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set fieldkey hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1	# 从第三个比特位开始，对接下来的4位无符号数加1</span><br><span class="line">1) (integer) 11		# 返回指定域增加后的数值</span><br><span class="line">127.0.0.1:6379&gt; get fieldkey	# 因为比特位的数值发生了变化，所以对应的数值也会发生变化，对应的字母也就变了</span><br><span class="line">lello</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1</span><br><span class="line">1) (integer) 12</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1</span><br><span class="line">1) (integer) 13</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1</span><br><span class="line">1) (integer) 14</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1</span><br><span class="line">1) (integer) 15</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1	# 4位表示最大的数为15，溢出控制默认为wrap（循环溢出），超出后从0开始</span><br><span class="line">1) (integer) 0	# 从0开始</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>OVERFLOW选项</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set fieldkey2 a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey2 overflow sat set i8 0 126	# 从偏移量0开始后八位对应的数值改为126</span><br><span class="line">1) (integer) 97		# 返回之前的数值</span><br><span class="line">127.0.0.1:6379&gt; get fieldkey2</span><br><span class="line">&quot;~&quot;					# 126对应这个~符号</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey2 overflow sat set i8 0 128	# 将数值改为128（超出了8位表示的最大值127）</span><br><span class="line">1) (integer) 126	# 返回之前的数值</span><br><span class="line">127.0.0.1:6379&gt; get fieldkey2</span><br><span class="line">&quot;\x7f&quot;				# 127对应的编码</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey2 overflow sat set i8 0 128	# 再次改为128</span><br><span class="line">1) (integer) 127	# 使用sat溢出控制，超出了最大值的表示范围会取最大值127</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey2 overflow fail set i8 0 128	# 使用fail溢出控制，再次改为128</span><br><span class="line">1) (nil)			# 使用fail溢出控制，超出了最大值的表示范围返回nil</span><br></pre></td></tr></table></figure>



<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis持久化(Redis persistence)是指将数据写入持久存储，如固态硬盘(SSD)。</p>
<p>Redis提供了一系列持久性选项。这些包括:</p>
<ul>
<li><strong>RDB</strong>（redis 数据库）：RDB持久化方式能够在指定的时间间隔对数据进行快照存储。</li>
<li><strong>AOF</strong>（追加文件）：AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</li>
<li><strong>No persistence</strong>（没有持久化）：可以完全禁用持久性，这有时在缓存时使用。</li>
<li><strong>RDB+AOF</strong>：可以同时开启两种持久化方式，在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
</ul>
<hr>
<h3 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h3><blockquote>
<p>Redis Database缩写。在<code>指定的时间间隔</code>，对数据进行<code>快照存储</code>。RDB保存到磁盘的文件叫dump.rdb。	<code>全量快照</code></p>
</blockquote>
<h4 id="1-1-快照"><a href="#1-1-快照" class="headerlink" title="1.1 快照"></a>1.1 快照</h4><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。也可以通过调用 SAVE或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p>
<p>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集: save 60 1000</p>
<h4 id="1-2-RDB优缺点"><a href="#1-2-RDB优缺点" class="headerlink" title="1.2 RDB优缺点"></a>1.2 RDB优缺点</h4><ul>
<li><strong>RDB的优点</strong><ul>
<li>RDB是一个非常<code>紧凑</code>的文件，它保存了某个时间点得数据集，非常适用于数据集的备份，比如可以在每个小时报保存一下过去24小时内的数据，同时每天保存过去30天的数据,这样即使出了问题也可以根据需求恢复到<code>不同版本</code>的数据集。</li>
<li>RDB是一个紧凑的单一文件，很方便传送到另一个远端数据中心，非常适用于<code>灾难恢复</code>。</li>
<li>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个<code>子进程</code>，接下来的工作全部由子进程来做，<code>父进程不需要再做其他IO操作</code>，所以RDB持久化方式可以最大化redis的性能。</li>
<li>与AOF相比，在恢复大的数据集的时候，RDB方式会<code>更快</code>一些。</li>
</ul>
</li>
<li><strong>RDB缺点</strong><ul>
<li>如果希望在redis<code>意外停止工作</code>（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合，虽然可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作)，但是Redis要完整的保存整个数据集是一个比较繁重的工作，通常会每隔5分钟或者更久做一次完整的保存，万一在Redis意外宕机，<code>可能会丢失几分钟的数据</code>。</li>
<li>RDB 需要经常fork子进程来保存数据集到硬盘上，当<code>数据集比较大</code>的时候，<code>fork</code>的过程是非常耗时的，可能会导致Redis在一些毫秒级内<code>不能响应</code>客户端的请求。如果数据集巨大并且CPU性能不是很好的情况下，这种情况会持续1秒，AOF也需要fork，但是可以调节重写日志文件的频率来提高数据集的耐久度。</li>
</ul>
</li>
</ul>
<h4 id="1-3-RDB配置"><a href="#1-3-RDB配置" class="headerlink" title="1.3 RDB配置"></a>1.3 RDB配置</h4><ul>
<li><p>配置dump.rdb文件保存路径</p>
<blockquote>
<p>下面是设置到了redis安装目录，当然也可以设置到其他目录下。默认是<code>./</code></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-11_225736.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-11_225736.png" alt="2023-04-11_225736"></a></p>
</li>
<li><p>修改快照文件名</p>
<blockquote>
<p>快照文件名默认为dump.rdb，可以对其进行修改</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_025908.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_025908.png" alt="2023-04-12_025908"></a></p>
</li>
</ul>
<h4 id="1-4-触发RDB快照和恢复"><a href="#1-4-触发RDB快照和恢复" class="headerlink" title="1.4 触发RDB快照和恢复"></a>1.4 触发RDB快照和恢复</h4><h5 id="1-4-1-自动触发"><a href="#1-4-1-自动触发" class="headerlink" title="1.4.1 自动触发"></a>1.4.1 自动触发</h5><ul>
<li><p>设置redis.config文件中的自动触发时间：save</p>
<ul>
<li><p>修改为7秒内3次修改：save 7 3</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-11_222730.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-11_222730.png" alt="2023-04-11_222730"></a></p>
</li>
<li><p>添加数据触发快照</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-11_223005.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-11_223005.png" alt="2023-04-11_223005"></a></p>
</li>
</ul>
</li>
<li><p>FLUSHDB和FLUSHALL命令</p>
<blockquote>
<p>执行flushdb或者flushall命令也会<code>触发</code>RDB快照，不过里面是空的，以便下次启动redis服务是读取到的就是空文件。</p>
</blockquote>
</li>
<li><p>SHUTDOWN命令</p>
<blockquote>
<p>执行shutdown命令之前会将当前的数据进行一次快照保存。</p>
</blockquote>
</li>
</ul>
<h5 id="1-4-2-手动触发"><a href="#1-4-2-手动触发" class="headerlink" title="1.4.2 手动触发"></a>1.4.2 手动触发</h5><ul>
<li><p>SAVE命令</p>
<blockquote>
<p>SAVE命令在主程序中执行会<code>阻塞当前进程</code>，直到持久化工作完成，redis才能处理其他命令。**<code>工作中禁止</code>**使用该命令。 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name Alice</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; save		# 立马将数据保存到快照中，如果数据量大会造成阻塞</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_010123.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_010123.png" alt="2023-04-12_010123"></a></p>
</li>
<li><p>BGSAVE命令</p>
<blockquote>
<p>BGSAVE命令会<code>fork一个子进程</code>在后台<code>异步进行</code>持久化工作，持久化期间redis可以执行其他命令。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name Cindy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started		# 在后台执行持久化</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_010220.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_010220.png" alt="2023-04-12_010220"></a></p>
</li>
</ul>
<p><strong>LASTSAVE</strong>命令可以获取最后一次成功执行快照的时间。得到的是一个时间戳，可以通过<code>date -d @时间戳</code>命令获取对应的时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LASTSAVE</span><br><span class="line">(integer) 1681223083</span><br><span class="line">127.0.0.1:6379&gt; quit</span><br><span class="line">[root@redis ~]# date -d @1681223083</span><br><span class="line">2023年 04月 11日 星期二 22:24:43 CST</span><br></pre></td></tr></table></figure>



<h5 id="1-4-3-修复快照数据"><a href="#1-4-3-修复快照数据" class="headerlink" title="1.4.3 修复快照数据"></a>1.4.3 修复快照数据</h5><blockquote>
<p>有些情况下快照保存的数据不完整导致无法读取快照数据，可以使用<code>redis-check-rdb</code>命令对rdb文件进行修复。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@redis redis-7.0.10]# redis-check-rdb dump.rdb </span><br><span class="line">[offset 0] Checking RDB file dump.rdb</span><br><span class="line">[offset 27] AUX FIELD redis-ver = &#x27;7.0.10&#x27;</span><br><span class="line">[offset 41] AUX FIELD redis-bits = &#x27;64&#x27;</span><br><span class="line">[offset 53] AUX FIELD ctime = &#x27;1681233313&#x27;</span><br><span class="line">[offset 68] AUX FIELD used-mem = &#x27;1104992&#x27;</span><br><span class="line">[offset 80] AUX FIELD aof-base = &#x27;0&#x27;</span><br><span class="line">[offset 82] Selecting DB ID 0</span><br><span class="line">[offset 155] Checksum OK</span><br><span class="line">[offset 155] \o/ RDB looks OK! \o/</span><br><span class="line">[info] 8 keys read</span><br><span class="line">[info] 0 expires</span><br><span class="line">[info] 0 already expired</span><br></pre></td></tr></table></figure>



<h5 id="1-4-4-恢复快照数据"><a href="#1-4-4-恢复快照数据" class="headerlink" title="1.4.4 恢复快照数据"></a>1.4.4 恢复快照数据</h5><blockquote>
<p>redis在启动服务时会读取配置的快照保存路径中的dump.rdb文件，所以只需要将备份的rdb文件放到配置的保存路径中，然后启动redis服务即可还原快照中的数据。</p>
</blockquote>
<h4 id="1-5-禁用RDB快照"><a href="#1-5-禁用RDB快照" class="headerlink" title="1.5 禁用RDB快照"></a>1.5 禁用RDB快照</h4><p><code>redis-cli config set save &quot;&quot;</code>：将save的值设置为空，即禁用了快照功能。</p>
<blockquote>
<p>在redis客户端则直接执行config set save “”即可。</p>
</blockquote>
<hr>
<hr>
<h3 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2. AOF"></a>2. AOF</h3><blockquote>
<p>Append Only File缩写。<code>记录</code>每次对服务器的<code>写操作</code>，当服务器重启的时候会<code>重新执行这些命令</code>来恢复原始的数据。</p>
</blockquote>
<h4 id="2-1-AOF优缺点"><a href="#2-1-AOF优缺点" class="headerlink" title="2.1 AOF优缺点"></a>2.1 AOF优缺点</h4><ul>
<li><strong>AOF优点：</strong><ul>
<li>使用AOF 会让Redis更加耐久：可以使用不同的写回(fsync)策略：no、everysec、always。使用默认的everysec策略，Redis的性能依然很好(fsync是由后台线程进行处理的，主线程会尽力处理客户端请求)，一旦出现故障，<code>最多丢失1秒</code>的数据。</li>
<li>AOF文件是一个<code>只进行追加</code>的日志文件，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，也也可使用redis-check-aof工具修复这些问题。</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行<code>重写</code>： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 如果不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li>
</ul>
</li>
<li><strong>AOF缺点：</strong><ul>
<li>对于相同的数据集来说，AOF 文件的<code>体积</code>通常要<code>大</code>于 RDB 文件的体积。</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会<code>慢</code>于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入时，RDB 可以提供更有保证的最大延迟时间。</li>
</ul>
</li>
</ul>
<h4 id="2-2-AOF配置"><a href="#2-2-AOF配置" class="headerlink" title="2.2 AOF配置"></a>2.2 AOF配置</h4><ul>
<li><p>开启AOF</p>
<blockquote>
<p>AOF默认是关闭的，需要将配置文件中appendonly设置为yes。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_025125.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_025125.png" alt="2023-04-12_025125"></a></p>
</li>
<li><p>配置aof文件保存路径</p>
<blockquote>
<p>aof文件的保存路径和rdb的保存路径是同一个，只不过AOF会在该路径下创建一个appendonlydir文件夹，然后将aof文件保存在该文件夹下。<code>Redis7</code>的aof文件分为三个文件： <code>appendonly.aof.1.base.rdb</code> <code>基本</code>文件：存储aof<strong>重写后的数据</strong> <code>appendonly.aof.1.incre.aof</code> <code>追加</code>文件：存储aof<strong>追加的数据</strong>，达到一定大小后触发AOF重写。 <code>appendonly.aof.manifest</code> <code>清单</code>文件：<strong>追踪管理</strong>aof。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_034032.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_034032.png" alt="2023-04-12_034032"></a></p>
</li>
<li><p>修改aof文件名和目录名</p>
<blockquote>
<p>生成的aof目录名默认为appendonlydir，文件名默认为appendonly.aof，可以在配置文件中修改。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/image-20230412032737462.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230412032737462.png" alt="image-20230412032737462"></a></p>
</li>
</ul>
<h4 id="2-3-三种写回策略"><a href="#2-3-三种写回策略" class="headerlink" title="2.3 三种写回策略"></a>2.3 三种写回策略</h4><p> <strong>AOF有三种写回策略</strong>：</p>
<ul>
<li><strong>Always</strong>：同步写回，每个写命令执行完立刻同步地将日志写入磁盘。</li>
<li><strong>Everysec</strong>：每秒写回，每个写命令执行完，先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区的内容写入磁盘。</li>
<li><strong>No</strong>：操作系统控制的写回，每个写命令执行完，先把日志写到AOF的内存缓冲区，由操作系统决定何时将缓冲区内容写入磁盘。</li>
</ul>
<table>
<thead>
<tr>
<th>配置项</th>
<th>写回时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td><code>同步</code>写回</td>
<td>可靠性高，数据基本不丢失</td>
<td>每个写命令都要同步记录，<code>性能影响</code>较大</td>
</tr>
<tr>
<td>Everysec</td>
<td><code>每秒</code>写回（默认）</td>
<td>性能适中</td>
<td>宕机时<code>丢失一秒</code>内的数据</td>
</tr>
<tr>
<td>No</td>
<td>操作系统<code>控制</code>的写回</td>
<td>性能好</td>
<td>宕机时<code>丢失</code>数据<code>较多</code></td>
</tr>
</tbody></table>
<h4 id="2-4-AOF的恢复和修复"><a href="#2-4-AOF的恢复和修复" class="headerlink" title="2.4 AOF的恢复和修复"></a>2.4 AOF的恢复和修复</h4><ul>
<li><p>AOF文件数据恢复</p>
<blockquote>
<p>在同时开启RDB和AOF持久化时，重启redis服务只会加载aof文件，不会加载rdb文件，即使启动时没有appendonlydir目录，也会创建一个新的appendonlydir目录。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_050612.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_050612.png" alt="2023-04-12_050612"></a></p>
</li>
<li><p>AOF文件数据修复</p>
<blockquote>
<p>在开启了AOF后，当AOF文件出现异常时，redis服务无法正常启动。可以使用<code>redis-check-aof --fix 文件名</code>命令修复文件。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_053017.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_053017.png" alt="2023-04-12_053017"></a></p>
</li>
<li><p>AOF紧急恢复</p>
<blockquote>
<p>如果误执行了FLUSHALL操作，先停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。因为FLUSHALL或者FLUSHDB也是写命令，会被追加到aof文件中。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_060804.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_060804.png" alt="2023-04-12_060804"></a></p>
</li>
</ul>
<h4 id="2-5-触发AOF日志重写"><a href="#2-5-触发AOF日志重写" class="headerlink" title="2.5 触发AOF日志重写"></a>2.5 触发AOF日志重写</h4><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。</p>
<p>举个例子， 如果对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要记录100 条记录。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p>
<p>为了处理这种情况， Redis 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建，即自动执行BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4后则可以自动触发 AOF 重写。</p>
<h5 id="2-5-1-自动触发"><a href="#2-5-1-自动触发" class="headerlink" title="2.5.1 自动触发"></a>2.5.1 自动触发</h5><blockquote>
<p>自动触发需要满足配置文件中的设置，官方默认设置是： <code>auto-aof-rewrite-percentage 100</code>：根据上次重写后的aof大小，判断当前aof大小是不是增长了1倍。100%表示一倍。 <code>auto-aof-rewrite-min-size 64mb</code>：重写时满足的文件大小，即incr.aof文件超过了64兆才会重写。</p>
<p>注意同时满足这两个条件才会触发。</p>
</blockquote>
<p>下面将auto-aof-rewrite-min-size改为1kb，测试AOF日志重写</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_071956.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_071956.png" alt="2023-04-12_071956"></a></p>
<p>rdb文件的内容是无法查看的，所以还是无法确定重写后的数据是否保存到了base.rdb文件中，可以先将<code>aof-use-rdb-preamble</code>设置为no，表示禁用aof+rdb混合模式，删除appendonlydir目录然后重启redis服务，这样就不会生成base.rdb文件，而是生成base.aof文件，重复上面的写操作，最后查看aof文件内容。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_073207.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_073207.png" alt="2023-04-12_073207"></a></p>
<p>可以看到，重写的数据确实写入了base文件，并且base.rdb文件大小比base.aof文件大小小得多，所以通常建议开启aof+rdb混合模式。</p>
<h5 id="2-5-2-手动触发"><a href="#2-5-2-手动触发" class="headerlink" title="2.5.2 手动触发"></a>2.5.2 手动触发</h5><blockquote>
<p>执行命令<code>BGREWRITEAOF</code>即可执行AOF重写。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_074803.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_074803.png" alt="2023-04-12_074803"></a></p>
<h4 id="2-6-AOF工作流程"><a href="#2-6-AOF工作流程" class="headerlink" title="2.6 AOF工作流程"></a>2.6 AOF工作流程</h4><p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/aof%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/aof%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="aof工作流程"></a></p>
<p>①Client作为命令的来源，会有多个源头以及源源不断的请求命令。</p>
<p>②在这些命令到达Redis Server 以后并不是直接写入AOF文件，会将其这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些<code>命令达到一定量</code>以后再<code>写入</code>磁盘，避免频繁的磁盘IO操作。</p>
<p>③AOF缓冲会根据AOF缓冲区同步文件的<code>三种写回策略</code>将命令<code>写入</code>磁盘上的<code>AOF文件</code>。</p>
<p>④随着写入AOF内容的增加为<code>避免文件膨胀</code>，会根据规则进行<code>命令的合并</code>(又称AOF重写)，从而起到AOF<code>文件压缩</code>的目的。</p>
<p>⑤当Redis Server 服务器重启的时候会<code>从AOF文件载入数据</code>。</p>
<h4 id="2-7-AOF重写原理"><a href="#2-7-AOF重写原理" class="headerlink" title="2.7 AOF重写原理"></a>2.7 AOF重写原理</h4><ol>
<li>在重写开始前，redis会fork一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li>
<li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</li>
<li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</li>
<li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中。</li>
<li>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</li>
</ol>
<h3 id="3-AOF-RDB混合模式"><a href="#3-AOF-RDB混合模式" class="headerlink" title="3. AOF+RDB混合模式"></a>3. AOF+RDB混合模式</h3><p>首先开启AOF：<code>appendonly yes</code>，默认是关闭的。</p>
<p>开启AOF+RDB混合模式：<code>aof-use-rdb-preamble yes</code>，默认是开启的。</p>
<p>同时开启AOF和RDB持久化，当Redis重启时会<code>优先加载AOF</code>文件来恢复原始的数据，因为在通常情况下，AOF保存的数据集要比RDB文件保存的数据集要<code>完整</code>。</p>
<p>在持久化时，<code>先使用RDB进行快照存储</code>，然后使用AOF持久化记录所有写的操作，当重写策略满足或者手动触发<code>重写</code>的时候，将<code>最新的数据存储为新的RDB记录</code>。这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据的完整性，又提高了恢复数据的性能</p>
<h3 id="4-纯缓存模式"><a href="#4-纯缓存模式" class="headerlink" title="4. 纯缓存模式"></a>4. 纯缓存模式</h3><p>纯缓存模式即同时关闭AOF和RDB，这样可以<code>最大化</code>redis的<code>读写性能</code>，但无法保证数据的安全性。禁用了自动，手动依然可以。</p>
<p>关闭RDB：修改配置文件<code>save &quot;&quot;</code></p>
<blockquote>
<p>禁用RDB持久化模式，仍然可以使用命令save、bgsave生成rdb文件。</p>
</blockquote>
<p>关闭AOF：修改配置文件<code>appendonly no</code></p>
<blockquote>
<p>禁用AOF持久化模式，仍然可以使用命令bgrewriteaof生成aof文件。</p>
</blockquote>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务（Transaction）是<code>一组</code> Redis 命令的集合，这些命令被当作一个整体，按顺序地<code>串行化执行</code>，而不会被其他命令插入。</p>
<p>Redis 事务使用 MULTI、EXEC、WATCH、DISCARD 和 UNWATCH 这些命令来实现。</p>
<hr>
<h3 id="1-Redis事务特性"><a href="#1-Redis事务特性" class="headerlink" title="1. Redis事务特性"></a>1. Redis事务特性</h3><ul>
<li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，<code>不会被其他客户端发送来的命令请求所打断</code>。</li>
<li>不保证原子性：Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，<code>没有</code>执行到一半进行<code>回滚</code>的能力。</li>
<li>排他性：Redis会<code>保证</code>一个事务内的命令<code>依次</code>执行，不会被其他命令插入。</li>
</ul>
<h3 id="2-Redis事务命令"><a href="#2-Redis事务命令" class="headerlink" title="2. Redis事务命令"></a>2. Redis事务命令</h3><blockquote>
<p><code>MULTI</code>：开启事务</p>
<p><code>EXEC</code>：执行事务</p>
<p><code>DISCARD</code>：取消事务</p>
<p><code>WATCH key [key ...]</code>：监控指定的key</p>
<p><code>UNWATCH </code>：取消监控。</p>
</blockquote>
<h4 id="MULTI"><a href="#MULTI" class="headerlink" title="MULTI"></a>MULTI</h4><blockquote>
<p>标记一个事务块的开始。执行的命令都会放到一个队列中，通过EXEC命令统一执行。</p>
</blockquote>
<h4 id="EXEC"><a href="#EXEC" class="headerlink" title="EXEC"></a>EXEC</h4><blockquote>
<p>执行事务队列中的命令。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_005226.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_005226.png" alt="2023-04-13_005226"></a></p>
<h4 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a>DISCARD</h4><blockquote>
<p>放弃事务。在开启了事务后，若不想执行命令了，可以通过DISCARD命令来取消事务。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_010054.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_010054.png" alt="2023-04-13_010054"></a></p>
<h4 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h4><blockquote>
<p>监控指定的key的变化，要先开启监控，再开启事务。若监控的数据被篡改了，则事务中无法再对其修改，会返回nil。</p>
<p>执行完EXEC命令后，之前加的监控都会失效。</p>
<p>redis使用watch来提供乐观锁，类似于<code>CAS</code>(Check and Set)。</p>
<p>乐观锁(Optimistic Lock)， 顾名思义就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。如果有则取消当前操作让他人操作生效。乐观锁策略：提交版本要比当前记录版本高。</p>
<p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_014123.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_014123.png" alt="2023-04-13_014123"></a></p>
<h4 id="UNWATCH"><a href="#UNWATCH" class="headerlink" title="UNWATCH"></a>UNWATCH</h4><blockquote>
<p>取消监控。在对某个key监控后，已经发现了它被篡改过了，可以使用unwatch命令取消对该key的监控。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_015330.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_015330.png" alt="2023-04-13_015330"></a></p>
<h3 id="3-不保证原子性"><a href="#3-不保证原子性" class="headerlink" title="3. 不保证原子性"></a>3. 不保证原子性</h3><h4 id="”全体连坐“"><a href="#”全体连坐“" class="headerlink" title="”全体连坐“"></a>”全体连坐“</h4><blockquote>
<p>要么都执行，要么都不执行。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_021448.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_021448.png" alt="2023-04-13_021448"></a></p>
<h4 id="“冤头债主”"><a href="#“冤头债主”" class="headerlink" title="“冤头债主”"></a>“冤头债主”</h4><blockquote>
<p>错误的命令报错归报错，正确的命令依旧执行，即使在错误命令之后也会执行。		<code>因为放入队列的语句只进行语法检查</code></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_020726.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_020726.png" alt="2023-04-13_020726"></a></p>
<h3 id="4-事务执行流程"><a href="#4-事务执行流程" class="headerlink" title="4. 事务执行流程"></a>4. 事务执行流程</h3><p> （1）开启：以MULTI命令开启一个事务</p>
<p> （2）入队：将多个命令假如到事务队列中，接到这些命令并不会立即执行。</p>
<p> （3）执行：由EXEC命令执行事务队列中的命令。</p>
<h2 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h2><p>Redis 管道（Pipeline）是一种在客户端和 Redis 服务器之间建立的双向通道，它可以让客户端在一次请求中发送多个命令并一次性接收多个命令的响应结果。通过使用 Redis 管道，客户端可以减少网络通信的次数，从而提高 Redis 的吞吐量和性能。</p>
<p>在传统的 Redis 操作中，每个命令都需要通过网络发送到 Redis 服务器，然后等待 Redis 服务器返回响应结果后再进行下一个命令的操作，这样就会产生大量的<code>网络通信开销</code>。而使用 Redis 管道，客户端可以将<code>多个命令一次性发送</code>到 Redis 服务器，然后<code>一次性接收所有命令的响应结果</code>，从而减少网络通信的次数和开销。</p>
<hr>
<h3 id="1-pipeline的使用"><a href="#1-pipeline的使用" class="headerlink" title="1. pipeline的使用"></a>1. pipeline的使用</h3><blockquote>
<p>首先创建一个文件，写入需要执行的命令集。 在Linux终端使用<code>cat cmd.txt | redis-cli -a 123456 --pipe</code>命令将命令集传输到服务器。 (管道符”|“表示将前面命令的结果集作为参数传输给后面的命令)</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_030844.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_030844.png" alt="2023-04-13_030844"></a></p>
<h3 id="2-Pipeline小总结"><a href="#2-Pipeline小总结" class="headerlink" title="2. Pipeline小总结"></a>2. Pipeline小总结</h3><ul>
<li>Pipeline与原生批量命令对比：<ul>
<li>原生批量命令（例如mset、mget）具有原子性，pipeline是非原子性。</li>
<li>原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令。</li>
<li>原生批命令是redis服务端实现，而pipeline需要redis服务端和客户端共同完成。</li>
</ul>
</li>
<li>Pipeline与事务对比：<ul>
<li>事务具有原子性，<code>管道不具有原子性</code>。</li>
<li>管道一次性将命令发送给服务器，事务是一条一条的发，事务只有在接收到EXEC命令后才会执行。</li>
<li><code>执行事务时会阻塞其他命令的执行，而执行管道中的命令不会</code>。</li>
</ul>
</li>
<li>使用Pipeline注意事项：<ul>
<li>pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，还会继续执行后续的指令。</li>
<li>使用pipeline传输的<code>命令也不能太多</code>，如果数据量大客户端的阻塞时间可能会过久，同时服务端此时也被迫回复一个队列答复，占用很多内存。</li>
</ul>
</li>
</ul>
<h2 id="Redis发布和订阅-了解"><a href="#Redis发布和订阅-了解" class="headerlink" title="Redis发布和订阅(了解)"></a>Redis发布和订阅(了解)</h2><p>Redis 发布和订阅（Publish&#x2F;Subscribe，简称 Pub&#x2F;Sub）是一种消息传递模式，用于在 Redis 中实现消息的发布和订阅。</p>
<p>在 Redis 中，发布者（Publisher）可以将消息发送到一个或多个频道（Channel），订阅者（Subscriber）可以订阅一个或多个频道，以接收发布者发送的消息。当发布者在某个频道上发布一条消息时，所有订阅该频道的订阅者都会收到这条消息。</p>
<p>Redis Pub&#x2F;Sub 是基于消息传递的异步通信模型，可以用于构建实时系统、聊天室、实时广播等应用场景。</p>
<hr>
<h3 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h3><h4 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h4><p>**<code>SUBSCRIBE channel [channel ...]</code>**：订阅一个或多个频道</p>
<blockquote>
<p>一旦客户进入了订阅状态，客户端就只能接受订阅相关的命令SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE和PUNSUBSCRIBE，除了这些命令，其他命令一律失效。按Ctrl+C结束订阅状态。</p>
<p>返回值：发布类型、频道名称、第几个频道</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_215044.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_215044.png" alt="2023-04-13_215044"></a></p>
<h4 id="PUBLISH"><a href="#PUBLISH" class="headerlink" title="PUBLISH"></a>PUBLISH</h4><p>**<code>PUBLISH channel message</code>**：发布消息到指定频道。</p>
<blockquote>
<p>返回值为收到消息的客户端数量。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_221127.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_221127.png" alt="2023-04-13_221127"></a></p>
<h4 id="PSUBSCRIBE"><a href="#PSUBSCRIBE" class="headerlink" title="PSUBSCRIBE"></a>PSUBSCRIBE</h4><p>**<code>PSUBSCRIBE pattern [pattern ...]</code>**：按照匹配模式批量订阅。</p>
<blockquote>
<p>支持的模式有：?表示任意一个字符；<em>表示任意数量的任意字符；[]表示中括号中的指定字符。比如： h?llo：可以匹配hallo、hbllo、hello… h</em>llo：可以匹配hello、heeello、habcdello… h[abc]llo：只能匹配hallo、hbllo、hcllo</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_224853.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_224853.png" alt="2023-04-13_224853"></a></p>
<h4 id="PUBSUB"><a href="#PUBSUB" class="headerlink" title="PUBSUB"></a>PUBSUB</h4><p>PUBSUB 是自省命令，能够检测PUB&#x2F;SUB子系统的状态。</p>
<p>**<code>PUBSUB CHANNELS [pattern] </code>**：返回当前活跃的频道。</p>
<blockquote>
<p>只会统计使用SUBSCRIBE订阅的频道。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_230814.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_230814.png" alt="2023-04-13_230814"></a></p>
<p>**<code>PUBSUB NUMSUB channel [channel ...]</code>**：返回指定频道订阅者的个数。</p>
<blockquote>
<p>只会统计使用SUBSCRIBE订阅的订阅者个数。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_231329.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_231329.png" alt="2023-04-13_231329"></a></p>
<p>**<code>PUBSUB UNMPAT</code>**：返回订阅模式(PSUBSCRIBE)的数量。</p>
<blockquote>
<p>这个命令返回的不是订阅模式的订阅者数量， 而是所有Redis客户端(订阅者)订阅的所有模式的数量总和。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBSUB NUMPAT</span><br><span class="line">(integer) 2		# 包括了客户端1，客户端2，客户端3的订阅模式的数量</span><br></pre></td></tr></table></figure>



<h4 id="UNSUBSCRIBE"><a href="#UNSUBSCRIBE" class="headerlink" title="UNSUBSCRIBE"></a>UNSUBSCRIBE</h4><p>**<code>UNSUBSCRIBE channel [channel ...]</code>**：指示客户端退订指定频道，若没有指定频道则退订所有频道。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; UNSUBSCRIBE c2	# 退定频道c1</span><br><span class="line">1) &quot;unsubscribe&quot;</span><br><span class="line">2) &quot;c1&quot;</span><br><span class="line">3) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt; UNSUBSCRIBE		# 退订所有频道</span><br><span class="line">1) &quot;unsubscribe&quot;</span><br><span class="line">2) (nil)</span><br><span class="line">3) (integer) 0</span><br></pre></td></tr></table></figure>



<h4 id="PUNSUBSCRIBE"><a href="#PUNSUBSCRIBE" class="headerlink" title="PUNSUBSCRIBE"></a>PUNSUBSCRIBE</h4><p>**<code>PUNSUBSCRIBE pattern [pattern ...]</code>**：指示客户端退订指定模式，若没有提供模式则退定所有模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUNSUBSCRIBE c*		# 退定订阅模式c*</span><br><span class="line">1) &quot;punsubscribe&quot;</span><br><span class="line">2) &quot;c*&quot;</span><br><span class="line">3) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt; PUNSUBSCRIBE		# 退订所有订阅模式</span><br><span class="line">1) &quot;punsubscribe&quot;</span><br><span class="line">2) (nil)</span><br><span class="line">3) (integer) 0</span><br></pre></td></tr></table></figure>



<h3 id="2-小总结"><a href="#2-小总结" class="headerlink" title="2. 小总结"></a>2. 小总结</h3><ul>
<li>发布的<code>消息</code>在Redis系统<code>不能持久化</code>，因此必须先执行订阅，再等待消息发布，如果先发布了消息且该消息没有订阅者接收，那么该消息被直接丢弃。</li>
<li>消息只管发送，对于发布者而言消息是即发即失的，也<code>没有ACK机制</code>，无法保证消息是否消费成功。</li>
<li>Redis5.0新增了Stream数据结构，不但支持多播，还支持数据持久化，比Pub&#x2F;Sub更加强大。</li>
</ul>
<h2 id="Redis复制"><a href="#Redis复制" class="headerlink" title="Redis复制"></a>Redis复制</h2><p>Redis 复制（Replication）是 Redis 的一项核心功能，用于将一个 Redis 数据库的所有数据复制到另一个 Redis 实例上。Redis 复制可以提高系统的可用性、可靠性和扩展性，使得在发生故障时可以快速地恢复数据。</p>
<p>Redis 复制支持<code>主从复制</code>和<code>从从复制</code>两种方式，可以根据实际情况选择不同的方式来部署和管理 Redis 实例。<code>实现读写分离，就是主机复制写，从机负责读</code></p>
<ul>
<li><p><strong>主从复制</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_001017.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_001017.png" alt="2023-04-15_001017"></a></p>
</li>
<li><p><strong>从从复制</strong></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_001151.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_001151.png" alt="2023-04-15_001151"></a></p>
<hr>
<h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h3><p>（1）克隆两个虚拟机，一主二仆，Redis设主节点，Redis1和Redis2设从节点。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_052056.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_052056.png" alt="2023-04-14_052056"></a></p>
<p>（2）配置网络IP：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_055012.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_055012.png" alt="2023-04-14_055012"></a></p>
<p>（3）关闭防火墙：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_202754.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_202754.png" alt="2023-04-15_202754"></a></p>
<p>（4）修改redis.conf配置文件</p>
<ul>
<li><p><strong>基础配置</strong></p>
<ul>
<li>开启后台运行：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053032.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053032.png" alt="2023-04-14_053032"></a></li>
<li>注释bind 127.0.0.1：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053304.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053304.png" alt="2023-04-14_053304"></a></li>
<li>关闭保护模式：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053407.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053407.png" alt="2023-04-14_053407"></a></li>
<li>指定端口号：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053526.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053526.png" alt="2023-04-14_053526"></a></li>
<li>持久化文件保存目录：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053736.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053736.png" alt="2023-04-14_053736"></a></li>
<li>修改持久化文件名：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_055701.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_055701.png" alt="2023-04-14_055701"></a></li>
<li>设置日志文件名：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_054025.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054025.png" alt="2023-04-14_054025"></a></li>
<li>配置密码：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_054232.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054232.png" alt="2023-04-14_054232"></a></li>
</ul>
</li>
<li><p><strong>主要配置</strong></p>
<blockquote>
<p>”配从不配主“： 在从节点的redis.conf文件配置主节点的ip和端口号：<code>replicaof 主节点IP 主节点Redis服务端口号</code> 在从节点的redis.conf文件配置连接主节点Redis服务的密码：<code>masterauth 密码</code></p>
</blockquote>
<ul>
<li>配置从节点访问的主节点：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_054622.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054622.png" alt="2023-04-14_054622"></a></li>
<li>配置从节点访问的主节点的密码：<a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_054759.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054759.png" alt="2023-04-14_054759"></a></li>
</ul>
</li>
</ul>
<h3 id="2-基本命令"><a href="#2-基本命令" class="headerlink" title="2. 基本命令"></a>2. 基本命令</h3><p>从节点配置了需要连接的主节点后，打开Redis客户端即可自动连接到主节点。并且开始同步主节点的数据。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_113140.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_113140.png" alt="2023-04-14_113140"></a></p>
<p>**<code>INFO REPLICATION</code>**：查看主从关系和配置信息</p>
<ul>
<li>查看主节点信息</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_105932.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_105932.png" alt="2023-04-14_105932"></a></p>
<ul>
<li>查看从节点信息</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_110313.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_110313.png" alt="2023-04-14_110313"></a></p>
<p>**<code>replicaof 主节点IP 主节点端口</code>**：配置需要连接的主节点IP和端口。一般写入进redis.conf文件中</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_111840.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_111840.png" alt="2023-04-14_111840"></a></p>
<p>**<code>slaveof 主节点IP 主节点端口</code>**：临时更换需要连接的主节点IP和端口。</p>
<blockquote>
<p>这是一个临时的主从关系，每次与主节点断 开后都需要重新配置。</p>
<p>在运行期间修改slave节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原数据库的同步关系，开始和新配置的主数据库同步，并且清除原有的数据。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_113853.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_113853.png" alt="2023-04-14_113853"></a></p>
<p>将从节点redis2的追随的主节点更改为redis1后，查看redis1的信息：是redis的从节点，也是redis2的主节点。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_114241.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_114241.png" alt="2023-04-14_114241"></a></p>
<p>**<code>slaveof no one</code>**：停止当前从节点与主节点的的数据同步。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_221538.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_221538.png" alt="2023-04-14_221538"></a></p>
<h3 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h3><ul>
<li><p>slave可以执行写命令吗？</p>
<blockquote>
<p>slave不可以执行写命令。<code>master负责写命令，slave负责读命令，当然master也可以读命令</code>。</p>
<p>即使slave是另一台slave的master，也不能执行写命令。 </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_223633.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_223633.png" alt="2023-04-14_223633"></a></p>
</li>
<li><p>slave是从头开始复制还是从切入点开始复制?</p>
<blockquote>
<p>在 Redis 复制中，从节点（Slave）可以选择从头开始复制或者从切入点开始复制。</p>
<p>当从节点第一次连接主节点时，如果主节点没有持久化数据，从节点将从头开始复制。即主节点会将自己的全部数据发送给从节点，从节点将接收并保存全部数据。</p>
<p>当从节点与主节点已经建立了连接，并且已经有了初始数据同步，如果从节点断开与主节点的连接后重新连接，从节点可以选择从上次同步的位置（复制偏移量）继续同步数据，这样可以避免从头开始复制所带来的性能影响和数据冗余。 （master会检查backlog里面的offset，master和slave都会保存一个复制的offset和一个masterId）</p>
<p>需要注意的是，如果从节点断开与主节点的连接时间过长，主节点可能已经自动执行了 BGSAVE 命令，生成了新的 RDB 文件，此时从节点需要从头开始复制。此外，如果从节点的内存不足，也可能需要从头开始复制，以避免内存溢出。</p>
<p>比如master写到k3，slave启动后会同步k3及之前的数据，然后跟随master同步数据。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_235542.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_235542.png" alt="2023-04-14_235542"></a></p>
</li>
<li><p>主节点SHUTDOWN后，从节点会上位吗？</p>
<blockquote>
<p>主节点关闭后，从节点不会变成主节点，它们会<code>等待主节点重新启动</code>，但是从<code>节点的数据可以正常读取</code>。</p>
<p>主节点重启后，主从关系依旧存在。</p>
</blockquote>
</li>
</ul>
<h3 id="4-Redis复制流程"><a href="#4-Redis复制流程" class="headerlink" title="4. Redis复制流程"></a>4. Redis复制流程</h3><p>（1）从节点向主节点发送 SYNC 命令，请求<code>全量复制</code>。</p>
<p>（2）主节点接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件，并在生成过程中记录所有执行的写命令。</p>
<p>（3）主节点在 BGSAVE 命令执行完毕后，将<code>生成的 RDB 文件发送给从节点</code>，同时将在执行 BGSAVE 命令期间记录的<code>写命令发送给从节点</code>，让从节点进行执行。</p>
<p>（4）从节点接收到主节点发送的 RDB 文件和写命令，并执行相应的操作来保持与主节点的数据一致。</p>
<p>（5）从节点<code>持续监听</code>主节点发来的新命令，并将其执行，以保持与主节点的数据同步。</p>
<p>（6）为了保持主节点和从节点之间的通信，<code>master</code>会发出<code>PING包</code>的周期默认是10秒：<code>repl-ping-replica-period 10</code>（在661行）</p>
<p>（6）当主节点发生故障时，从节点会尝试与其他主节点建立连接，并<code>选举出一个新的主节点</code>，从而成为新的从节点，保证系统的可用性 和可靠性。</p>
<blockquote>
<p>需要注意的是，Redis 复制是异步的，因此从节点可能存在数据不一致的情况。为了避免数据不一致，可以设置 Redis 的<code>复制偏移量</code>（replication offset），当从节点与主节点<code>连接断开</code>后，从节点可以通过该偏移量<code>快速地同步</code>数据。<code>类似断点续传</code></p>
</blockquote>
<h3 id="5-Redis复制的缺点"><a href="#5-Redis复制的缺点" class="headerlink" title="5. Redis复制的缺点"></a>5. Redis复制的缺点</h3><p>（1）<em>数据同步延迟</em>：由于 Redis 复制是异步的，从节点的数据可能会与主节点存在一定的延迟，因此从节点可能无法实时获取到最新的 数据。</p>
<p>（2）<em>单点故障</em>：当主节点发生故障时，需要手动进行故障转移或者使用集群来保证系统的可用性。</p>
<p>（3）<em>网络通信问题</em>：当网络出现故障或者通信延迟过高时，复制的效率会受到影响，从节点可能无法及时接收到主节点发送的数据。</p>
<p>（4）<em>内存消耗问题</em>：当从节点处理不过来主节点发送过来的写命令时，从节点会自动触发执行全量复制，这会导致从节点内存消耗变大</p>
<p>（5）<em>数据安全问题</em>：当主节点的数据被误删或者篡改时，从节点也会受到影响，因此需要采取一定的措施来保证数据的安全性。</p>
<blockquote>
<p>需要注意的是，这些缺点并不是 Redis 复制本身的问题，而是分布式系统中常见的问题，需要根据实际情况进行综合考虑和处理。</p>
</blockquote>
<h2 id="Redis哨兵-Sentinel"><a href="#Redis哨兵-Sentinel" class="headerlink" title="Redis哨兵(Sentinel)"></a>Redis哨兵(Sentinel)</h2><p>Redis Sentinel（哨兵）是 Redis 的高可用性解决方案之一，它可以用于监控和管理 Redis 主从复制集群，并在主节点发生故障时自动将从节点升级为新的主节点，从而保证系统的高可用性和可靠性。</p>
<p>Redis Sentinel 的主要功能如下：</p>
<ol>
<li>监控 Redis 主节点和从节点的状态，包括节点的可用性、延迟等情况。</li>
<li>自动发现和识别 Redis 主从复制集群的拓扑结构。</li>
<li>在主节点发生故障时，自动将从节点升级为新的主节点，并将其他从节点重新连接到新的主节点。</li>
<li>支持 Redis 集群的自动故障转移、故障恢复和配置管理等功能。</li>
<li>提供监控和管理 Redis 集群的 API 和命令行工具。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/sentinel.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/sentinel.png" alt="sentinel"></a></p>
<hr>
<h3 id="1-环境配置-1"><a href="#1-环境配置-1" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h3><p><strong>（1）配置三个哨兵实例</strong></p>
<blockquote>
<p>三个哨兵实例需要三台虚拟机，考虑到机器性能有限，这里将三个哨兵实例配置到一台虚拟机上(这里配置到主节点的那台虚拟机)，配置三份不同的哨兵配置文件即可：sentinel26379.conf、sentinel26380.conf、sentinel26381.conf，将它们存放到&#x2F;myredis下。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_030538.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_030538.png" alt="2023-04-15_030538"></a></p>
<p><strong>（2）修改哨兵配置文件的内容</strong></p>
<ul>
<li><p><strong>基础配置</strong></p>
<ul>
<li>关闭保护模式：<code>protected-mode no</code></li>
<li>开启后台运行：<code>daemonize yes</code></li>
<li>配置哨兵服务端口号：<code>port 26379</code> （三个文件要不一样）</li>
<li>日志文件路径：<code>logfile &quot;/myredis/sentinel26379.log&quot;</code></li>
<li>pid文件路径：<code>pidfile /var/run/redis-sentinel26379.pid</code></li>
<li>工作目录：<code>dir /myredis</code></li>
</ul>
</li>
<li><p><strong>主要配置</strong></p>
<ul>
<li><p>设置要监控的master：**<code>master monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code>**</p>
<blockquote>
<p>master-name：给master取的名字。</p>
<p>quorum：同意故障迁移的法定票数。即表示有几个哨兵认可主观下线。达到一定票数后认定为客观下线(宕机、不可用)</p>
</blockquote>
</li>
<li><p>配置连接master服务的密码：**<code>sentinel-auth-pass &lt;master-name&gt; &lt;password&gt;</code>**</p>
</li>
</ul>
</li>
<li><p><strong>其他配置</strong>（使用默认即可）</p>
<ul>
<li><p><code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</code></p>
<blockquote>
<p>指定多少毫秒之后，主节点没有应答哨兵，此时哨兵主观上认为主节点下线</p>
</blockquote>
</li>
<li><p><code>sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;</code></p>
<blockquote>
<p>表示允许并行同步的slave个数，当master挂了后，哨兵会选出新的master，剩余的slave会向新的master发起同步数据</p>
</blockquote>
</li>
<li><p><code>sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</code></p>
<blockquote>
<p>故障转移的超时时间，进行故障转移时，如果超过设置的毫秒，表示故障转移失败</p>
</blockquote>
</li>
<li><p><code>sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; </code></p>
<blockquote>
<p>配置当某一事件发生时所需要执行的脚本</p>
</blockquote>
</li>
<li><p><code>sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code></p>
<blockquote>
<p>客户端重新配置主节点参数脚本</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>去除配置文件的注释，最终配置文件sentinel26379.conf的内容如下，sentinel26380.conf和sentinel26381.conf稍作修改即可</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">protected-mode</span> <span class="literal">no</span></span><br><span class="line"><span class="string">port</span> <span class="number">26379</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;/myredis/sentinel26379.log&quot;</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/var/run/redis-sentinel26379.pid</span></span><br><span class="line"><span class="string">dir</span> <span class="string">/myredis</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">192.168</span><span class="number">.101</span><span class="number">.110</span> <span class="number">6379 </span><span class="number">2</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">auth-pass</span> <span class="string">mymaster</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_035110.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_035110.png" alt="2023-04-15_035110"></a></p>
<p><strong>（3）配置主节点的访问密码</strong></p>
<blockquote>
<p>主节点宕机后，哨兵会选举一个从节点作为主节点，而之前的主节点会变成从节点，所以需要配置访问新主节点的密码。</p>
<p>这里所有节点都设置为同一密码，方便操作。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_040008.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_040008.png" alt="2023-04-15_040008"></a></p>
<h3 id="2-实操演示"><a href="#2-实操演示" class="headerlink" title="2. 实操演示"></a>2. 实操演示</h3><h4 id="2-1-启动三个redis实例"><a href="#2-1-启动三个redis实例" class="headerlink" title="2.1 启动三个redis实例"></a>2.1 启动三个redis实例</h4><p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_041926.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_041926.png" alt="2023-04-15_041926"></a></p>
<h4 id="2-2-启动三个哨兵实例"><a href="#2-2-启动三个哨兵实例" class="headerlink" title="2.2 启动三个哨兵实例"></a>2.2 启动三个哨兵实例</h4><blockquote>
<p>这里在redis(6379)那台机器上启动三个哨兵实例。</p>
<p>启动哨兵服务有两种方式：</p>
<ul>
<li>使用redis-sentinel程序启动：<code>redis-sentinel sentinel.conf</code></li>
<li>使用redis-server程序启动：<code>redis-server sentinel.conf --sentinel</code></li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_043016.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_043016.png" alt="2023-04-15_043016"></a></p>
<h4 id="2-3-测试主从复制"><a href="#2-3-测试主从复制" class="headerlink" title="2.3 测试主从复制"></a>2.3 测试主从复制</h4><p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_044818.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_044818.png" alt="2023-04-15_044818"></a></p>
<h4 id="2-4-查看sentinel日志文件"><a href="#2-4-查看sentinel日志文件" class="headerlink" title="2.4 查看sentinel日志文件"></a>2.4 查看sentinel日志文件</h4><p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_045331.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_045331.png" alt="2023-04-15_045331"></a></p>
<p>下面查看sentinel26379.log文件的主要内容：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_045716.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_045716.png" alt="2023-04-15_045716"></a></p>
<p>新配置保存到磁盘的意思就是新配置信息写入到sentinel.conf文件中，下面查看sentinel26379.conf文件新增的内容：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_065615.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_065615.png" alt="2023-04-15_065615"></a></p>
<h4 id="2-4-模拟master节点宕机"><a href="#2-4-模拟master节点宕机" class="headerlink" title="2.4 模拟master节点宕机"></a>2.4 模拟master节点宕机</h4><blockquote>
<p>关闭master节点后，哨兵会重新选举一个从节点作为新的主节点。</p>
<p>首先三个哨兵实例会投票选举一个哨兵实例作为领导者，然后由该哨兵实例来选举一个新的主节点并且进行故障迁移(failover)</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_055113.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_055113.png" alt="2023-04-15_055113"></a></p>
<ul>
<li><p>查看sentinel26379.log日志文件了解哨兵选举的过程：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_052907.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_052907.png" alt="2023-04-15_052907"></a></p>
</li>
<li><p>查看redis(6379)实例的redis.conf文件哨兵leader新增的内容：</p>
<blockquote>
<p>redis(6379)实例由之前的主节点变成从节点</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_062500.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_062500.png" alt="2023-04-15_062500"></a></p>
</li>
<li><p>查看redis1(6380)实例的redis.conf文件哨兵leader修改的内容：</p>
<blockquote>
<p>redis1(6380)实例由之前的从节点变成主节点</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/image-20230415063454674.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230415063454674.png" alt="image-20230415063454674"></a></p>
</li>
<li><p>查看redis2(6381)实例的redis.conf文件哨兵leader修改的内容：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_064629.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_064629.png" alt="2023-04-15_064629"></a></p>
</li>
</ul>
<hr>
<h3 id="3-哨兵选举的流程"><a href="#3-哨兵选举的流程" class="headerlink" title="3. 哨兵选举的流程"></a>3. 哨兵选举的流程</h3><ol>
<li><p><strong>哨兵检测到主节点不可用：当哨兵检测到主节点不可用时，会将主节点标记为下线状态(sdown)，并向其他哨兵发送通知，通知其他哨兵主节点已经下线，其他哨兵也标记主节点下线后(odown)，确定主节点不可用。</strong></p>
<blockquote>
<p><code>主观下线</code>(sdown)：指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。主观下线就是说如果服务器在<code>sentinel down-after-milliseconds</code>给定的毫秒数之内<code>没有回应PING命令或者返回一个错误消息</code>， 那么这个Sentinel会主观的(单方面的)认为这个master不可以用了。</p>
<p><code>客观下线</code>(odown)：客观下线需要<code>多个哨兵达成一致意见</code>才能认为主节点真正不可用。 quorum(票数)这个参数是进行客观下线的一个依据。法定人数&#x2F;法定票数(quorum)。</p>
</blockquote>
</li>
<li><p><strong>哨兵投票选举哨兵leader：哨兵在检测到主节点不可用后，会进入选举状态，此时哨兵将开始选举哨兵的领导者。</strong></p>
<blockquote>
<p>监视该主节点的所有哨兵都有可能被选为<code>领导者</code>，选举使用的算法是Raft算法；Raft算法的基本思路是<code>先到先得</code>：</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/%E5%93%A8%E5%85%B5%E9%80%89%E4%B8%BE.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/%E5%93%A8%E5%85%B5%E9%80%89%E4%B8%BE.png" alt="哨兵选举"></a></p>
</li>
<li><p><strong>哨兵leader开始推动故障切换流程并选举出一个新的master</strong></p>
<blockquote>
<p>在从节点中选出新的master的规则： ①redis.<code>conf</code>中<code>优先级</code>slave-priority或replica-priority高的从节点优先（数值越小优先级越高） ②<code>复制偏移量</code>(offset)<code>大</code>的从节点优先。 ③<code>Run ID最小</code>的从节点优先(按字典顺序、ASCII码值比较)，每个redis实例启动后都会随机生成一个40位的run id。</p>
<p>复制偏移量是一个相对值，表示已复制的字节数</p>
<p>Run ID是reids实例启动的标识</p>
</blockquote>
</li>
<li><p><strong>选举出新的master后由<code>Sentinel leader完成failover工作</code>(故障切换)</strong></p>
<ul>
<li>执行slaveof no one命令让选出来的从节点成为新的主节点，并通过slaveof命令让其他节点（包括原来的master）成为新主节点的从节点。</li>
<li>Sentinel leader会向被重新配置的实例发送一个 CONFIG REWRI TE 命令， 从而确保这些配置会持久化在硬盘里(写入配置文件)。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-小总结"><a href="#4-小总结" class="headerlink" title="4. 小总结"></a>4. 小总结</h3><ul>
<li><p>哨兵实例的数量应为<code>多个</code>，哨兵本身应该集群，保证高可用</p>
</li>
<li><p>哨兵实例的个数应该为<code>奇数</code>，方便投票选出Sentinel Leader，方便raft算法执行</p>
</li>
<li><p>各个哨兵实例的<code>配置</code>应该<code>一致</code></p>
</li>
<li><p>哨兵集群+主从复制，并<code>不能保证数据零丢失</code>（引出集群cluster，集群可以解决这一问题）</p>
<blockquote>
<p><code>master宕机</code>后，哨兵需要在一定时间内<code>选出</code>新的master并执行failover操作，这段时间内<code>从节点无法写入数据</code>，造成<code>数据丢失</code>。</p>
</blockquote>
</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>Redis 集群是 Redis 数据库的分布式解决方案，它可以将数据分散存储在多个节点上，以支持大规模数据存储和高并发访问。</p>
<p>Redis 集群使用的是基于槽的分区策略，即将数据分成固定数量的槽，每个槽由一个主节点和多个从节点组成。客户端请求会根据键值的哈希值被路由到对应的槽上，从而实现数据的分布式存储和访问。同时，Redis 集群还提供了多种操作槽的命令，以支持集群的管理和维护。</p>
<p>Redis 集群的主要特点包括：</p>
<ol>
<li>分布式存储：Redis 集群将数据分散存储在多个节点上，每个节点负责处理一部分数据，从而实现数据的分布式存储和访问。集群可以扩展到数千个节点，以支持海量数据存储和高并发访问。建议控制在1000个以内的节点数。</li>
<li><code>高可用性</code>：Redis 集群通过多副本机制和自动故障转移机制，保证数据的可靠性和可用性。每个节点都有多个副本，其中一个副本为主节点，负责处理客户端请求，其他副本为从节点，负责复制主节点的数据。当主节点宕机时，从节点会自动选举一个新的主节点，以保证数据的连续性和可用性。</li>
<li>数据<code>自动分片</code>：Redis 集群将数据自动分片存储在多个节点上，以实现数据的均衡分布和高效访问。每个节点都负责处理一部分数据，同时维护一份槽指派表，记录每个槽对应的主节点和从节点。客户端请求会根据键值的哈希值被路由到对应的槽上，从而实现数据的分布式存储和访问。</li>
<li>支持<code>在线扩容缩容</code>：Redis 集群支持在线添加和删除节点，以扩展或缩小集群的容量，而无需停机或数据迁移。集群会<code>自动将数据重新分片和迁移</code>，以保证数据的连续性和可用性。</li>
<li>负载均衡：Redis 集群通过智能路由算法，将客户端请求均匀地分发到不同的节点上，以实现负载均衡和性能优化。客户端可以通过集群模式下的代理节点（cluster-enabled proxy）进行连接，代理节点会自动将请求路由到正确的节点上。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/cluster.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/cluster.png" alt="cluster"></a></p>
<hr>
<h3 id="1-redis集群槽位"><a href="#1-redis集群槽位" class="headerlink" title="1. redis集群槽位"></a>1. redis集群槽位</h3><p>在 Redis 集群中，槽位（slot）是<code>将数据进行分片的基本单位</code>，也是实现数据分布式存储和访问的重要机制。Redis 集群默认将 <code>16384</code> 个槽位均分给不同的节点，<code>每个节点负责处理一部分槽位</code>，从而实现数据的分布式存储和访问。</p>
<p>具体来说，Redis 集群使用<code>哈希槽（hash slot）</code>的方式<code>将数据进行分片</code>，每个槽对应着一个整数编号，从 0 开始，一直到 16383。每个节点会负责处理一部分槽位，同时维护一份<code>槽指派表（slot map）</code>，记录每个槽对应的主节点和从节点。</p>
<p>客户端请求会&#x3D;&#x3D;根据键值的哈希值被路由到对应的槽&#x3D;&#x3D;上，从而实现数据的分布式存储和访问。具体来说，客户端会将键值的哈希值对 16384 取模，得到一个槽号，然后将请求发送到对应的槽所在的节点上。如果该节点是主节点，它会将请求处理后的结果返回给客户端；如果该节点是从节点，则会将请求转发给对应的主节点进行处理。</p>
<p>需要注意的是，<code>槽的数量是固定的</code>，因此如果需要扩展 Redis 集群的容量，就需要将一些<code>槽移动到新的节点上</code>，以实现数据的重新分片和迁移。Redis 集群提供了多种操作槽的命令，以支持集群的管理和维护。</p>
<hr>
<h3 id="2-redis集群分片"><a href="#2-redis集群分片" class="headerlink" title="2. redis集群分片"></a>2. redis集群分片</h3><p>在 Redis 集群中，数据分片（sharding）是将数据划分成多个部分，分别存储在不同的节点上，从而实现分布式存储和访问的基本方式。Redis 集群使用哈希槽（hash slot）的方式将数据进行分片，每个节点负责处理一部分槽位，从而实现数据的分布式存储和访问。</p>
<p>具体来说，Redis 集群默认将 16384 个槽位均分给不同的节点，每个节点负责处理一部分槽位，同时维护一份槽指派表（slot map），记录每个槽对应的主节点和从节点。客户端请求会根据键值的哈希值被路由到对应的槽上，从而实现数据的分布式存储和访问。</p>
<p>数据分片能够提高 Redis 集群的容量和可用性，减少单节点的负载压力，并支持横向扩展和动态扩容。同时，数据分片也会带来一些挑战和问题，例如数据迁移、节点失效、一致性维护等方面的问题，需要进行合理的设计和实现。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/redis%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/redis%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87.png" alt="redis集群分片"></a></p>
<hr>
<h3 id="3-redis槽位映射"><a href="#3-redis槽位映射" class="headerlink" title="3. redis槽位映射"></a>3. redis槽位映射</h3><ul>
<li><p><strong><code>哈希取余</code>分区</strong></p>
<p>哈希取余分区是一种常见的数据分区技术，它将数据划分成多个分区，并将每个分区分配给集群中的不同节点，从而实现分布式存储和访问。</p>
<p>在哈希取余分区中，首先根据某个键的哈希值对分区总数取模，得到该键所在的分区编号，然后将该键存储在对应的节点上。当需要访问某个键值对时，同样通过哈希值计算得到该键所在的分区编号，然后访问对应的节点，从而实现数据的分布式访问。</p>
<p>哈希取余分区技术简单易懂，易于实现，可以<code>较好地均衡数据在各个节点之间的分布</code>，从而提高系统的可扩展性和可用性。但是，该技术存在<code>数据倾斜和数据迁移</code>等问题。如果某个键的哈希值对分区总数取模后恰好落在某个分区上，那么该分区的负载将会比其他分区更重，可能会导致性能问题。此外，在节点的动态扩容和缩容时，会需要进行数据迁移，对系统的稳定性和性能也会带来影响。</p>
<p><code>在出现变动的时候，比如哈希的分母出现了变化，那么各种映射都要重新计算</code></p>
</li>
<li><p><strong><code>一致性哈希</code>算法分区</strong></p>
<p>一致性哈希算法（Consistent Hashing Algorithm）是一种用于分布式存储系统的数据分区技术，它可以使得数据在集群中的分布更加均匀，同时减少在数据分区发生变化时需要重新分配的数据量。</p>
<p>在一致性哈希算法中，所有的数据被分成一定数量的分区，<code>每个分区被映射到一个哈希环上</code>。<code>每个节点也被映射到哈希环上</code>，并负责其所在的某些分区。当需要存储一个数据时，<code>先对该数据进行哈希</code>，<code>然后将哈希值映射到哈希环上</code>，**<code>找到最近的节点</code>**，并将数据存储在该节点上。当需要读取一个数据时，也先对该数据进行哈希，并映射到哈希环上，然后从离该数据最近的节点上读取数据。</p>
<p>一致性哈希算法的核心思想是<code>将哈希环视为一个环形空间</code>，并将节点和数据视为该空间上的点。通过在哈希环上的均匀分布，可以使得数据在集群中的分布更加均匀。当某个节点宕机时，只会影响该节点所负责的一部分分区，不会影响整个集群，从而提高了系统的可用性和稳定性。同时，一致性哈希算法也能够自动地将数据重新映射到新的节点上，从而减少了数据的迁移量和系统的维护成本。</p>
<p>一致性哈希算法已经被广泛地应用于各种分布式系统中，包括缓存系统、负载均衡系统、分布式文件系统等</p>
<p><code>其实就是根据查询映射到环上的位置去找最近的节点映射位置</code></p>
<p>存在<code>数据倾斜</code>的问题，因为寻找方向是固定的，都是顺时针或者逆时针,所以会存在<code>分布不均匀</code>的情况</p>
<blockquote>
<p>一致性<code>哈希环</code></p>
<p>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32)，这样让它逻辑上形成了一个环形空间。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%8E%AF.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%8E%AF.png" alt="一致性哈希环"></a></p>
</blockquote>
</li>
<li><p><strong>哈希槽分区</strong></p>
<p>哈希槽分区是 Redis 集群中常用的数据分区技术，它将整个数据集划分为固定数量的槽位（slot），然后将每个槽位分配到集群中不同的节点上，从而实现数据的分布式存储和访问。</p>
<p>在哈希槽分区中，每个槽位都对应着一个哈希值范围，例如 0 到 16383。当需要存储某个键值对时，先计算出该键的哈希值，然后确定该哈希值所在的槽位，最后将键值对存储在负责管理该槽位的节点上。当需要访问某个键值对时，同样先计算出该键的哈希值，然后确定该哈希值所在的槽位，最后访问负责管理该槽位的节点，从而实现数据的分布式访问。</p>
<p>哈希槽分区技术具有简单、可扩展性强等优点，它可以自动完成节点的动态扩容和缩容，并且在数据迁移时可以只迁移部分槽位，从而降低数据迁移的成本和风险。但是，该技术也存在一些问题，例如槽位的分配不均匀可能会导致某些节点的负载过重，从而影响系统的性能和可用性，此时可以通过手动调整槽位分配来解决这个问题。</p>
</li>
</ul>
<hr>
<h3 id="4-集群环境搭建"><a href="#4-集群环境搭建" class="headerlink" title="4. 集群环境搭建"></a>4. 集群环境搭建</h3><p><strong>（1）三主三从redis集群配置</strong></p>
<p>由于机器性能有限，这里只配置了三台虚拟机，一台虚拟机配置两个redis实例</p>
<blockquote>
<p>192.168.101.110 (下面简称110)配置端口为6381和6382两个实例，配置文件分别为cluster6381.conf和cluster6382.conf 192.168.101.111 (下面简称111)配置端口为6383和6384两个实例，配置文件分别为cluster6383.conf和cluster6384.conf 192.168.101.112 (下面简称112)配置端口为6385和6386两个实例，配置文件分别为cluster6385.conf和cluster6386.conf</p>
</blockquote>
<p>以实例cluster6381.conf为例，配置文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">port 6381</span><br><span class="line">logfile &quot;/myredis/cluster/cluster6381.log&quot;</span><br><span class="line">pidfile /myredis/ccluster6381.pid</span><br><span class="line">dir /myredis/cluster</span><br><span class="line">dbfilename dump6381.rdb</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly6381.aof&quot;</span><br><span class="line">requirepass 123456</span><br><span class="line">masterauth 123456</span><br><span class="line"> </span><br><span class="line">cluster-enabled yes		# 开启集群</span><br><span class="line">cluster-config-file nodes-6381.conf		# 集群生成的配置文件</span><br><span class="line">cluster-node-timeout 5000	# 集群节点之间的超时时间</span><br></pre></td></tr></table></figure>



<p>在每台虚拟机的根目录创建<code>/myredis/cluster</code>目录，然后在该目录创建两个配置文件：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_125434.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_125434.png" alt="2023-04-15_125434"></a></p>
<p>查看cluster6381.conf文件内容：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_124752.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_124752.png" alt="2023-04-15_124752"></a></p>
<p><strong>（2）启动六台redis实例</strong></p>
<blockquote>
<p>启动集群实例和之前启动redis实例一样，只不过配置文件中配置了开启集群，会以集群的方式启动redis实例。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_130446.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_130446.png" alt="2023-04-15_130446"></a></p>
<p><strong>（3）构建主从关系</strong></p>
<p>使用命令构建集群间的主从关系：**<code>redis-cli -a 密码 --cluster create --cluster-replicas 1 IP:端口号 [IP:端口号]</code>**</p>
<blockquote>
<p>选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点</p>
<p><code>IP:端口号</code>是redis实例的地址和端口号，多个redis实例构成一个集群</p>
<p>主从关系是随机分配的(个人见解：一般按照输入的顺序基数位为master，偶数位为slave)，其master-slave关系是随机分配的。</p>
</blockquote>
<p>在任意一个虚拟机中执行这个命令都可以，下面在110虚拟机中执行此命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[root@redis cluster]# redis-cli -a 123456 --cluster create --cluster-replicas 1 192.168.101.110:6381 192.168.101.110:6382 192.168.101.111:6383 192.168.101.111:6384 192.168.101.112:6385 192.168.101.112:6386</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460			# 1号主节点分配了0-5460的槽位</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922		# 2号主节点分配了5461-10922的槽位</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383	# 3号主节点分配了10923-16383的槽位</span><br><span class="line">Adding replica 192.168.101.111:6384 to 192.168.101.110:6381	#111机器的6384实例同步110机器的6381实例</span><br><span class="line">Adding replica 192.168.101.112:6386 to 192.168.101.111:6383	#112机器的6386实例同步111机器的6383实例</span><br><span class="line">Adding replica 192.168.101.110:6382 to 192.168.101.112:6385	#110机器的6382实例同步112机器的6385实例</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381	# 主节点id IP:端口号</span><br><span class="line">   slots:[0-5460] (5461 slots) master	# 分配了5461个槽位</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382	# 从节点id IP:端口号</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec	# 从属154d23(主节点id，对应6385)</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes	# 是否保存这些配置，输入yes保存</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">..</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.110:6381)</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   slots: (0 slots) slave	# 从节点分配了0个槽位</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>



<p>重连6381实例再查看集群信息：<code>CLUSTER INFO</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@redis cluster]# redis-cli -a 123456 -p 6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6381&gt; CLUSTER INFO	# 查看集群信息</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:3652</span><br><span class="line">cluster_stats_messages_pong_sent:3675</span><br><span class="line">cluster_stats_messages_sent:7327</span><br><span class="line">cluster_stats_messages_ping_received:3670</span><br><span class="line">cluster_stats_messages_pong_received:3652</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:7327</span><br><span class="line">total_cluster_links_buffer_limit_exceeded:0</span><br></pre></td></tr></table></figure>



<p>查看集群节点的状态信息：<code>CLUSTER NODES</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@redis cluster]# redis-cli -a 123456 -p 6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6381&gt; CLUSTER NODES	# 查看集群节点状态信息</span><br><span class="line">e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381@16381 myself,master - 0 1681569469000 1 connected 0-5460	# myself,master表示当前所在的节点，是主节点。前面的一大串是该节点的id、IP端口信息</span><br><span class="line">851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384@16384 slave e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 0 1681569472503 1 connected	# 从节点851c41(6384)同步e4d44f(6381)</span><br><span class="line">1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383@16383 master - 0 1681569472000 3 connected 5461-10922</span><br><span class="line">202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382@16382 slave 154d23ad6fb321801ebe84e8066411e3f3fc05ec 0 1681569472000 5 connected</span><br><span class="line">e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386@16386 slave 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 0 1681569472503 3 connected</span><br><span class="line">154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385@16385 master - 0 1681569472604 5 connected 10923-16383</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_224005.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_224005.png" alt="2023-04-15_224005"></a></p>
<hr>
<h3 id="5-测试集群读写"><a href="#5-测试集群读写" class="headerlink" title="5. 测试集群读写"></a>5. 测试集群读写</h3><blockquote>
<p>每个key都有自己的哈希值，根据哈希值通过某种算法算出对应的槽位，该<code>key只能存储到该槽位所在的节点上</code>。</p>
<p>然而这种情况并不是我们想要的，可以在<code>连接redis客户端时</code>添加<code>-c</code>参数，这样会帮我们把数据<code>路由</code>到指定的槽位上，即使在不同的节点上也能随便存储数据。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_232003.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_232003.png" alt="2023-04-15_232003"></a></p>
<p>查看某个key对应的槽位值：<code>CLUSTER KEYSLOT key</code></p>
<blockquote>
<p>任何字符都有对应的哈希值，所以任何字符都能计算出对应的槽位</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_232246.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_232246.png" alt="2023-04-15_232246"></a></p>
<p>查看某个槽位是否被占用：<code>CLUSTER COUNTKEYSINSLOT 槽位号</code></p>
<blockquote>
<p>返回1表示该槽位被占用；返回0表示该槽位没有被占用。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_021649.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_021649.png" alt="2023-04-16_021649"></a></p>
<hr>
<h3 id="6-测试集群主从切换"><a href="#6-测试集群主从切换" class="headerlink" title="6. 测试集群主从切换"></a>6. 测试集群主从切换</h3><ul>
<li><p>首先查看当前节点主从关系：<code>INFO REPLICATION</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_233204.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_233204.png" alt="2023-04-15_233204"></a></p>
</li>
<li><p>手动关闭主节点6381，查看集群节点状态</p>
<blockquote>
<p>在其他任何集群节点查看集群节点的状态都可以。</p>
<p>主节点宕机后，从节点会成为新的master。</p>
</blockquote>
<p><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_234248.png" alt="2023-04-15_234248"></p>
</li>
<li><p>重新连接节点6381，查看集群节点状态</p>
<blockquote>
<p>恢复6381节点后，该节点会变成新master的slave。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_000001.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_000001.png" alt="2023-04-16_000001"></a></p>
</li>
<li><p>恢复6381master的身份：<code>CLUSTER FAILOVER</code></p>
<blockquote>
<p>使用<code>cluster failover</code>可以恢复发生故障前的主从关系</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_000849.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_000849.png" alt="2023-04-16_000849"></a></p>
</li>
</ul>
<hr>
<h3 id="7-redis集群扩容"><a href="#7-redis集群扩容" class="headerlink" title="7. redis集群扩容"></a>7. redis集群扩容</h3><p>在112虚拟机上新建两个redis实例6387和6388，此时112虚拟机上有4个redis实例分别是6385、6386、6387、6388</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_002143.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_002143.png" alt="2023-04-16_002143"></a></p>
<p>启动这两个新节点，此时它们都是master</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_002446.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_002446.png" alt="2023-04-16_002446"></a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_002814.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_002814.png" alt="2023-04-16_002814"></a></p>
<p>将6387节点作为master加入到集群中：**<code>redis-cli -a 密码 --cluster add-node IP:port IP:port</code>**</p>
<blockquote>
<p>前者<code>IP:port</code>为需要加入到集群的节点ip和端口 后者<code>IP:port</code>指集群中任一节点的ip和端口（可以理解为推荐人）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster add-node 192.168.101.112:6387 192.168.101.110:6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Adding node 192.168.101.112:6387 to cluster 192.168.101.110:6381</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.110:6381)</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">&gt;&gt;&gt; Getting functions from cluster</span><br><span class="line">&gt;&gt;&gt; Send FUNCTION LIST to 192.168.101.112:6387 to verify there is no functions in it</span><br><span class="line">&gt;&gt;&gt; Send FUNCTION RESTORE to 192.168.101.112:6387</span><br><span class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 192.168.101.112:6387 to make it join the cluster.</span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure>



<p>检查集群情况：**<code>redis-cli -a 密码 --cluster check IP:port</code>**</p>
<blockquote>
<p>只需要指定集群中任意一个在线的节点的地址(IP:端口号)， 就会自动找到集群中的其他节点，即可查看整个集群的信息。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@redis1 ~]# redis-cli -a 123456 --cluster check 192.168.101.110:6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">192.168.101.110:6381 (e4d44fbd...) -&gt; 2 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.101.112:6385 (154d23ad...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.101.112:6387 (b1ef21d8...) -&gt; 0 keys | 0 slots | 0 slaves.	#可以看到节点6387加入了集群但是没有分配槽位</span><br><span class="line">192.168.101.111:6383 (1b9c2607...) -&gt; 1 keys | 5462 slots | 1 slaves.</span><br><span class="line">[OK] 4 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.110:6381)</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: b1ef21d88293bc1560f61a46c4fca8b601d59d60 192.168.101.112:6387</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>



<p>重新分派槽号：**<code>redis-cli -a 密码 --cluster reshard IP:port</code>**</p>
<blockquote>
<p>只需要指定集群中任意一个在线的节点的地址(IP:端口号)即可。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster reshard 192.168.101.110:6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.110:6381)</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: b1ef21d88293bc1560f61a46c4fca8b601d59d60 192.168.101.112:6387</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 4096</span><br><span class="line">What is the receiving node ID? b1ef21d88293bc1560f61a46c4fca8b601d59d60	# 指定一个节点id接收槽位</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  # all表示现有的三个分片平均拿出一点槽位分给新节点</span><br><span class="line">  Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type &#x27;done&#x27; once you entered all the source nodes IDs.</span><br><span class="line">Source node #1: all</span><br><span class="line"></span><br><span class="line">Ready to move 4096 slots.</span><br></pre></td></tr></table></figure>



<p>再次检查集群情况</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_011920.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_011920.png" alt="2023-04-16_011920"></a></p>
<p>为集群中新主节点添加从节点： <strong><code>redis-cli -a 密码 --cluster add-node IP:port IP:port --cluster-slave --cluster-master-id 新主节点id</code></strong></p>
<blockquote>
<p>前者<code>IP:port</code>指从节点的地址，后者<code>IP:port</code>为集群中任意一个在线节点的地址</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster add-node 192.168.101.112:6388 192.168.101.112:6387 --cluster-slave --cluster-master-id b1ef21d88293bc1560f61a46c4fca8b601d59d60</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Adding node 192.168.101.112:6388 to cluster 192.168.101.112:6387</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.112:6387)</span><br></pre></td></tr></table></figure>



<p>再次检查集群情况</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_011706.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_011706.png" alt="2023-04-16_011706"></a></p>
<hr>
<h3 id="8-redis集群缩容"><a href="#8-redis集群缩容" class="headerlink" title="8. redis集群缩容"></a>8. redis集群缩容</h3><p>首先先将从节点6388删除：**<code>redis-cli -a 密码 --cluster del-node IP:从节点端口 从节点id</code>**</p>
<blockquote>
<p>节点id可以通过检查集群情况命令查看：<code>redis-cli -a 密码 --cluster check IP:port</code> 也可以通过<code>CLUSTER NODES</code>命令查看。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster del-node 192.168.101.112:6388 8bc4986317910e2f57d67609931645b41d5a90e3		# 删除6388j</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Removing node 8bc4986317910e2f57d67609931645b41d5a90e3 from cluster 192.168.101.112:6388</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER RESET SOFT to the deleted node.</span><br></pre></td></tr></table></figure>



<p>将主节点6387的槽号清空重新分配</p>
<blockquote>
<p>这里将清空的槽号全部分配给6381节点（当然也可以平均分配回之前的三个主节点，只不过要操作三次）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 重新分配槽号</span><br><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster reshard 192.168.101.110:6381</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_014559.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_014559.png" alt="2023-04-16_014559"></a></p>
<p>移除槽位后检查集群情况</p>
<blockquote>
<p>6387节点槽位被清空，成为了6381节点的从节点</p>
<p>这和加入6387节点到集群时填写的集群中的<code>IP:port</code>有关（6381相当于推荐人）</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_015556.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_015556.png" alt="2023-04-16_015556"></a></p>
<p>此时节点6387是一个从节点，将节点6387删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster del-node 192.168.101.112:6387 b1ef21d88293bc1560f61a46c4fca8b601d59d60</span><br></pre></td></tr></table></figure>



<p>再次检查集群情况</p>
<p><a target="_blank" rel="noopener" href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_020413.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_020413.png" alt="2023-04-16_020413"></a></p>
<h3 id="9-关于16384"><a href="#9-关于16384" class="headerlink" title="9. 关于16384"></a>9. 关于16384</h3><p>在 Redis 集群中，每个节点都会通过<code>发送心跳信息</code>来保持与其他节点的连接和状态同步。心跳信息通常包含了一些关键的集群信息，如节点的 IP 地址、端口号、节点角色、复制偏移量等。</p>
<p>心跳信息<code>包含了节点负责的槽位信息</code>，如果槽位太多，发送的就很多，16384是一个均衡后的结果。65536是CRC16的上限，可是浪费带宽，一般节点数量也不会超过1000，16834够用了</p>
<h3 id="10-关于强一致"><a href="#10-关于强一致" class="headerlink" title="10. 关于强一致"></a>10. 关于强一致</h3><p>Redis集群不保证强一致性，也就是在特定条件下，redis集群可能丢掉一些被系统收到的写入请求命令，也就是master写到从的时候如果断了，是无法同步过去的。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/06/11/JAVA%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/" rel="next" title="JAVA算法应用基础">
                <i class="fa fa-chevron-left"></i> JAVA算法应用基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/06/25/MySQL/" rel="prev" title="MySQL">
                MySQL <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">1.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Key%E7%9A%84%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.</span> <span class="nav-text">Key的通用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#KEYS"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">**KEYS ***</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXISTS"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">EXISTS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DEL"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">DEL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPIRE"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">EXPIRE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TTL"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">TTL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TYPE"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">TYPE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DBSIZE"><span class="nav-number">1.1.0.7.</span> <span class="nav-text">DBSIZE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SELECT"><span class="nav-number">1.1.0.8.</span> <span class="nav-text">SELECT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MOVE"><span class="nav-number">1.1.0.9.</span> <span class="nav-text">MOVE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FLUSHDB"><span class="nav-number">1.1.0.10.</span> <span class="nav-text">FLUSHDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FLUSHALL"><span class="nav-number">1.1.0.11.</span> <span class="nav-text">FLUSHALL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#help"><span class="nav-number">1.1.0.12.</span> <span class="nav-text">help</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CONFIG"><span class="nav-number">1.1.0.13.</span> <span class="nav-text">CONFIG</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%8D%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">Redis十大数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-Stirng"><span class="nav-number">1.2.1.</span> <span class="nav-text">一. Stirng</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SET%E5%92%8CGET"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">SET和GET</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MSET%E5%92%8CMGET"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">MSET和MGET</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#INCR%E3%80%81INCRBY"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">INCR、INCRBY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SETNX%E5%92%8CSETEX"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">SETNX和SETEX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MSETNX"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">MSETNX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SETRANGE%E5%92%8CGETRANGE"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">SETRANGE和GETRANGE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STRLEN"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">STRLEN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#APPEND"><span class="nav-number">1.2.1.8.</span> <span class="nav-text">APPEND</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GETSET"><span class="nav-number">1.2.1.9.</span> <span class="nav-text">GETSET</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#key%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.10.</span> <span class="nav-text">key的结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-List"><span class="nav-number">1.2.2.</span> <span class="nav-text">二. List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LPUSH%E5%92%8CRPUSH"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">LPUSH和RPUSH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LPUSHX%E5%92%8CRPUSHX"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">LPUSHX和RPUSHX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LRANGE"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">LRANGE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LPOP%E5%92%8CRPOP"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">LPOP和RPOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BLPOP%E5%92%8CBRPOP"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">BLPOP和BRPOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPOPLPUSH"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">RPOPLPUSH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LINDEX"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">LINDEX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LLEN"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">LLEN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LREM"><span class="nav-number">1.2.2.9.</span> <span class="nav-text">LREM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LTRIM"><span class="nav-number">1.2.2.10.</span> <span class="nav-text">LTRIM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LSET"><span class="nav-number">1.2.2.11.</span> <span class="nav-text">LSET</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LINSERT"><span class="nav-number">1.2.2.12.</span> <span class="nav-text">LINSERT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-Hash"><span class="nav-number">1.2.3.</span> <span class="nav-text">三. Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HSET%E5%92%8CHGET"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">HSET和HGET</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HMSET%E5%92%8CHMGET"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">HMSET和HMGET</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HGETALL"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">HGETALL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HDEL"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">HDEL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HLEN"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">HLEN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HEXISTS"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">HEXISTS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HKEYS%E5%92%8CHVALS"><span class="nav-number">1.2.3.7.</span> <span class="nav-text">HKEYS和HVALS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HINCR%E3%80%81HINCRBYFLOAT"><span class="nav-number">1.2.3.8.</span> <span class="nav-text">HINCR、HINCRBYFLOAT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HSETNX"><span class="nav-number">1.2.3.9.</span> <span class="nav-text">HSETNX</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-Set"><span class="nav-number">1.2.4.</span> <span class="nav-text">四. Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SADD"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">SADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SMEMBERS"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">SMEMBERS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SISMEMBER"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">SISMEMBER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SCARD"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">SCARD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SREM"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">SREM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SRANDMEMBER"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">SRANDMEMBER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SPOP"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">SPOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SMOVE"><span class="nav-number">1.2.4.8.</span> <span class="nav-text">SMOVE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.4.9.</span> <span class="nav-text">集合运算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SDIFF"><span class="nav-number">1.2.4.9.1.</span> <span class="nav-text">SDIFF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SUNION"><span class="nav-number">1.2.4.9.2.</span> <span class="nav-text">SUNION</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SINTER"><span class="nav-number">1.2.4.9.3.</span> <span class="nav-text">SINTER</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-SortedSet"><span class="nav-number">1.2.5.</span> <span class="nav-text">五. SortedSet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZADD"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">ZADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZCARD"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">ZCARD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZCOUNT"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">ZCOUNT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZSCORE"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">ZSCORE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZRANGE%E5%92%8CZREVRANGE"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">ZRANGE和ZREVRANGE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZRANGEBYSCORE%E5%92%8CZREVRANGEBYSCORE"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">ZRANGEBYSCORE和ZREVRANGEBYSCORE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZRANK%E5%92%8CZREVRANK"><span class="nav-number">1.2.5.7.</span> <span class="nav-text">ZRANK和ZREVRANK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZREM"><span class="nav-number">1.2.5.8.</span> <span class="nav-text">ZREM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZINCRBY"><span class="nav-number">1.2.5.9.</span> <span class="nav-text">ZINCRBY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZPOPMAX%E5%92%8CZPOPMIN"><span class="nav-number">1.2.5.10.</span> <span class="nav-text">ZPOPMAX和ZPOPMIN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZMPOP"><span class="nav-number">1.2.5.11.</span> <span class="nav-text">ZMPOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97-1"><span class="nav-number">1.2.5.12.</span> <span class="nav-text">集合运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD-Bitmap"><span class="nav-number">1.2.6.</span> <span class="nav-text">六. Bitmap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SETBIT"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">SETBIT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GETBIT"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">GETBIT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BITCOUNT"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">BITCOUNT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BITOP"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">BITOP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83-HyperLogLog"><span class="nav-number">1.2.7.</span> <span class="nav-text">七. HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PFADD"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">PFADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PFCOUNT"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">PFCOUNT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PFMERGE"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">PFMERGE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB-Geospatial"><span class="nav-number">1.2.8.</span> <span class="nav-text">八. Geospatial</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GEOADD"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">GEOADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GEOPOS"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">GEOPOS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GEOHASH"><span class="nav-number">1.2.8.3.</span> <span class="nav-text">GEOHASH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GEODIST"><span class="nav-number">1.2.8.4.</span> <span class="nav-text">GEODIST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GEORADIUS"><span class="nav-number">1.2.8.5.</span> <span class="nav-text">GEORADIUS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GEORADIUSBYMEMBER"><span class="nav-number">1.2.8.6.</span> <span class="nav-text">GEORADIUSBYMEMBER</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9D-Stream"><span class="nav-number">1.2.9.</span> <span class="nav-text">九. Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#XADD"><span class="nav-number">1.2.9.1.</span> <span class="nav-text">XADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XRANGE"><span class="nav-number">1.2.9.2.</span> <span class="nav-text">XRANGE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XREVRANGE"><span class="nav-number">1.2.9.3.</span> <span class="nav-text">XREVRANGE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XDEL"><span class="nav-number">1.2.9.4.</span> <span class="nav-text">XDEL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XLEN"><span class="nav-number">1.2.9.5.</span> <span class="nav-text">XLEN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XTRIM"><span class="nav-number">1.2.9.6.</span> <span class="nav-text">XTRIM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XREAD"><span class="nav-number">1.2.9.7.</span> <span class="nav-text">XREAD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XGROUP"><span class="nav-number">1.2.9.8.</span> <span class="nav-text">XGROUP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XREADGROUP"><span class="nav-number">1.2.9.9.</span> <span class="nav-text">XREADGROUP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XPENDING"><span class="nav-number">1.2.9.10.</span> <span class="nav-text">XPENDING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XACK"><span class="nav-number">1.2.9.11.</span> <span class="nav-text">XACK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XINFO"><span class="nav-number">1.2.9.12.</span> <span class="nav-text">XINFO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81-Bitfield"><span class="nav-number">1.2.10.</span> <span class="nav-text">十. Bitfield</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BITFIELD"><span class="nav-number">1.2.10.1.</span> <span class="nav-text">BITFIELD</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-RDB"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%BF%AB%E7%85%A7"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1.1 快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-RDB%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">1.2 RDB优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-RDB%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">1.3 RDB配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E8%A7%A6%E5%8F%91RDB%E5%BF%AB%E7%85%A7%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">1.4 触发RDB快照和恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-1-%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="nav-number">1.3.1.4.1.</span> <span class="nav-text">1.4.1 自动触发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-2-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="nav-number">1.3.1.4.2.</span> <span class="nav-text">1.4.2 手动触发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-3-%E4%BF%AE%E5%A4%8D%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.1.4.3.</span> <span class="nav-text">1.4.3 修复快照数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-4-%E6%81%A2%E5%A4%8D%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.1.4.4.</span> <span class="nav-text">1.4.4 恢复快照数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E7%A6%81%E7%94%A8RDB%E5%BF%AB%E7%85%A7"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">1.5 禁用RDB快照</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-AOF"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-AOF%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">2.1 AOF优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-AOF%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2.2 AOF配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">2.3 三种写回策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-AOF%E7%9A%84%E6%81%A2%E5%A4%8D%E5%92%8C%E4%BF%AE%E5%A4%8D"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">2.4 AOF的恢复和修复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E8%A7%A6%E5%8F%91AOF%E6%97%A5%E5%BF%97%E9%87%8D%E5%86%99"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">2.5 触发AOF日志重写</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-1-%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="nav-number">1.3.2.5.1.</span> <span class="nav-text">2.5.1 自动触发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-2-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="nav-number">1.3.2.5.2.</span> <span class="nav-text">2.5.2 手动触发</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-AOF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">2.6 AOF工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-AOF%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.2.7.</span> <span class="nav-text">2.7 AOF重写原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-AOF-RDB%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. AOF+RDB混合模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BA%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 纯缓存模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.4.</span> <span class="nav-text">Redis事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Redis%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. Redis事务特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Redis%E4%BA%8B%E5%8A%A1%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. Redis事务命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MULTI"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">MULTI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXEC"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">EXEC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DISCARD"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">DISCARD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WATCH"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">WATCH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UNWATCH"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">UNWATCH</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 不保证原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9D%E5%85%A8%E4%BD%93%E8%BF%9E%E5%9D%90%E2%80%9C"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">”全体连坐“</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C%E5%86%A4%E5%A4%B4%E5%80%BA%E4%B8%BB%E2%80%9D"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">“冤头债主”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. 事务执行流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%AE%A1%E9%81%93"><span class="nav-number">1.5.</span> <span class="nav-text">Redis管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-pipeline%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. pipeline的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Pipeline%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. Pipeline小总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85-%E4%BA%86%E8%A7%A3"><span class="nav-number">1.6.</span> <span class="nav-text">Redis发布和订阅(了解)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SUBSCRIBE"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">SUBSCRIBE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PUBLISH"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">PUBLISH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PSUBSCRIBE"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">PSUBSCRIBE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PUBSUB"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">PUBSUB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UNSUBSCRIBE"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">UNSUBSCRIBE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PUNSUBSCRIBE"><span class="nav-number">1.6.1.6.</span> <span class="nav-text">PUNSUBSCRIBE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. 小总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%A4%8D%E5%88%B6"><span class="nav-number">1.7.</span> <span class="nav-text">Redis复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. 环境配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. 基本命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.3.</span> <span class="nav-text">3. 常见问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Redis%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">1.7.4.</span> <span class="nav-text">4. Redis复制流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Redis%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.7.5.</span> <span class="nav-text">5. Redis复制的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%93%A8%E5%85%B5-Sentinel"><span class="nav-number">1.8.</span> <span class="nav-text">Redis哨兵(Sentinel)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-1"><span class="nav-number">1.8.1.</span> <span class="nav-text">1. 环境配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%9E%E6%93%8D%E6%BC%94%E7%A4%BA"><span class="nav-number">1.8.2.</span> <span class="nav-text">2. 实操演示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%90%AF%E5%8A%A8%E4%B8%89%E4%B8%AAredis%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">2.1 启动三个redis实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%90%AF%E5%8A%A8%E4%B8%89%E4%B8%AA%E5%93%A8%E5%85%B5%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">2.2 启动三个哨兵实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E6%B5%8B%E8%AF%95%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">2.3 测试主从复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E6%9F%A5%E7%9C%8Bsentinel%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">2.4 查看sentinel日志文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E6%A8%A1%E6%8B%9Fmaster%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">2.4 模拟master节点宕机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%93%A8%E5%85%B5%E9%80%89%E4%B8%BE%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.8.3.</span> <span class="nav-text">3. 哨兵选举的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.4.</span> <span class="nav-text">4. 小总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="nav-number">1.9.</span> <span class="nav-text">Redis集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-redis%E9%9B%86%E7%BE%A4%E6%A7%BD%E4%BD%8D"><span class="nav-number">1.9.1.</span> <span class="nav-text">1. redis集群槽位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-redis%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87"><span class="nav-number">1.9.2.</span> <span class="nav-text">2. redis集群分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-redis%E6%A7%BD%E4%BD%8D%E6%98%A0%E5%B0%84"><span class="nav-number">1.9.3.</span> <span class="nav-text">3. redis槽位映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">1.9.4.</span> <span class="nav-text">4. 集群环境搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4%E8%AF%BB%E5%86%99"><span class="nav-number">1.9.5.</span> <span class="nav-text">5. 测试集群读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2"><span class="nav-number">1.9.6.</span> <span class="nav-text">6. 测试集群主从切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-redis%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9"><span class="nav-number">1.9.7.</span> <span class="nav-text">7. redis集群扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-redis%E9%9B%86%E7%BE%A4%E7%BC%A9%E5%AE%B9"><span class="nav-number">1.9.8.</span> <span class="nav-text">8. redis集群缩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%85%B3%E4%BA%8E16384"><span class="nav-number">1.9.9.</span> <span class="nav-text">9. 关于16384</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%85%B3%E4%BA%8E%E5%BC%BA%E4%B8%80%E8%87%B4"><span class="nav-number">1.9.10.</span> <span class="nav-text">10. 关于强一致</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sounio</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
