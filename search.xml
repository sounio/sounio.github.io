<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络相关</title>
      <link href="/2023/07/05/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/07/05/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络编程"><a href="#计算机网络编程" class="headerlink" title="计算机网络编程"></a>计算机网络编程</h1><p>什么是网络编程？</p><p>计算机和计算机之间通过网络进行数据传输</p><p>##常见架构</p><h3 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h3><p>需要客户端，本地有一个客户端程序，远程有一个服务器端程序</p><p>体验好、要开发客户端</p><p>更新麻烦</p><p>###BS</p><p>只需要一个浏览器，用户通过不同的网址，客户访问不同的服务器</p><p>方便</p><p>体验一般</p><h2 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>设备在网络中的地址，唯一标识</p><p>分为公网IP和私有IP（局域网）</p><p>特殊：127.0.0.1本地ip和该设备在局域网的ip不一样，通过本地ip时不经过网络</p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>应用程序在设备中唯一的标识0~65535</p><p>一个端口只能被一个程序使用</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>数据在网络中传输的规则，常见有UDP、TCP、HTTP、HTTPS、FTP</p><p>OSI参考模型–&gt;tcp&#x2F;ip七层–&gt;四层</p><p>![1688561846371](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1688561846371.png)</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>面向无连接，速度快，有大小限制64K，数据不安全，易丢失</p><p>发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span>  <span class="string">&quot;nihao!!!&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str.getBytes();</span><br><span class="line"></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,port);</span><br><span class="line"></span><br><span class="line">ds.send(dp);</span><br><span class="line"></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><p>接受：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10086</span>);</span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line"><span class="comment">//该方法是阻塞的</span></span><br><span class="line">ds.receive(dp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据包</span></span><br><span class="line"><span class="type">byte</span>[] data = dp.getData();</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> dp.getAddress();</span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> dp.getPort();</span><br><span class="line">System.out.println(<span class="string">&quot;receive:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,len));</span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><h5 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h5><p>单播：一对一</p><p>组播：一对多（部分）组播地址：224.0.0.0<del>238.225.225.225其中224.0.0.0</del>224.0.0.225为预留的组播地址</p><p>广播：一对多（所有）255.255.255.255</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>面向连接、速度慢、没有限制、数据安全</p><p>可靠的网络协议，在通信的两端各建立一个Socket对象，在通信之前要保证连接已经建立，通过Socket产生IO流来进行网络通信</p><p>三次握手</p><p>![1688563362506](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1688563362506.png)</p><p>四次挥手</p><p>![1688563296313](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1688563296313.png)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/06/25/MySQL/"/>
      <url>/2023/06/25/MySQL/</url>
      
        <content type="html"><![CDATA[<p>#MySQL</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>mysql安装到系统后，自动注册为一个系统服务mysql80，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">启动:</span><br><span class="line">net start mysql80</span><br><span class="line">停止：</span><br><span class="line">net stop mysql80</span><br><span class="line">连接：</span><br><span class="line">mysql [-h 127.0.0.0.1] [-P 3306] -u root -p // 127这个是连接的ip地址，3306是端口号，默认ip本地主机，-u指明用户，-p输入密码</span><br></pre></td></tr></table></figure><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>什么是关系型数据库？</p><p>关系型数据库（Relational Database）是一种使用<code>关系模型</code>来组织和管理数据的数据库系统。它是目前最常用的数据库类型之一。关系型数据库采用表（Table）的形式来存储和表示数据，表由行（Row）和列（Column）组成，每一行表示一个实体或记录，每一列表示一种属性或字段。也就是建立在关系模型基础上，由多张相互连接的二维表组成的数据库</p><p>关系型数据库的主要特点包括：</p><ol><li>结构化数据：关系型数据库要求数据以严格的结构进行组织，数据的类型和约束规则需要在表的定义中进行明确定义。</li><li>表与表之间的关系：通过建立<code>表与表之间的关系</code>，如主键（Primary Key）和外键（Foreign Key），可以实现数据之间的关联和连接。</li><li>ACID事务支持：关系型数据库支持事务（Transaction），保证数据的一致性和可靠性。ACID是指原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</li><li>SQL查询语言：关系型数据库使用结构化查询语言（SQL）作为数据操作和查询的标准语言。SQL提供了丰富的操作和查询语句，可以方便地对数据进行增删改查操作。</li><li>数据完整性：关系型数据库提供数据完整性的机制，通过定义约束、触发器等方式，确保数据的有效性和一致性。</li></ol><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--单行注释</span></span><br><span class="line">#注释</span><br><span class="line"><span class="comment">/*注释*/</span></span><br></pre></td></tr></table></figure><h3 id="通用语法及分类"><a href="#通用语法及分类" class="headerlink" title="通用语法及分类"></a>通用语法及分类</h3><ul><li>DDL: 数据<code>定义</code>语言，用来定义数据库<code>对象</code>（数据库、表、字段）</li><li>DML: 数据<code>操作</code>语言，用来对数据库表中的数据进行<code>增删改</code></li><li>DQL: 数据<code>查询</code>语言，用来<code>查</code>询数据库中表的记录</li><li>DCL: 数据<code>控制</code>语言，用来创建数据库用户、控制数据库的控制<code>权限</code></li></ul><h3 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h3><p>数据定义语言</p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>查询所有数据库：<br><code>SHOW DATABASES;</code><br>查询<code>当前</code>数据库：也就是返回当前在操作的数据库<br><code>SELECT DATABASE();</code><br>创建数据库：<br><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code><br>删除数据库：<br><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code><br>使用数据库：<br><code>USE 数据库名;</code></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li></ul><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><p>查询当前数据库所有表：<br><code>SHOW TABLES;</code><br>查询表结构：<br><code>DESC 表名;</code><br>查询指定表的建表语句：<br><code>SHOW CREATE TABLE 表名;</code></p><p>创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(   字段<span class="number">1</span> 字段<span class="number">1</span>类型 [COMMENT 字段<span class="number">1</span>注释],    # 中括号中是注释，不是必要的，使用时不需要带中括号</span><br><span class="line">字段<span class="number">2</span> 字段<span class="number">2</span>类型 [COMMENT 字段<span class="number">2</span>注释],    </span><br><span class="line">字段<span class="number">3</span> 字段<span class="number">3</span>类型 [COMMENT 字段<span class="number">3</span>注释],    </span><br><span class="line">...    </span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br></pre></td></tr></table></figure><p><strong>最后一个字段后面没有逗号</strong></p><p>添加字段：<br><code>ALTER</code> <code>TABLE</code> 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];<br>例：ALTER TABLE emp ADD nickname varchar(20) COMMENT ‘昵称’;</p><p>修改数据类型：<br>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);<br>修改字段名和字段类型：<br>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];<br>例：将emp表的nickname字段修改为username，类型为varchar(30)<br>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT ‘昵称’;</p><p>删除字段：<br>ALTER TABLE 表名 DROP 字段名;</p><p>修改表名：<br>ALTER TABLE 表名 RENAME TO 新表名</p><p><code>删除</code>表：<br><code>DROP</code> TABLE [IF EXISTS] 表名;<br>删除表，并重新创建该表：<br>TRUNCATE TABLE 表名;</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>![1687666148901](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1687666148901.png)</p><p>![1687666323855](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1687666323855.png)</p><p>![1687666474990](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1687666474990.png)</p><h3 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>指定字段：<br>INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2, …);<br>全部字段：<br>INSERT INTO 表名 VALUES (值1, 值2, …);</p><p>批量添加数据：<br>INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2, …), (值1, 值2, …), (值1, 值2, …);<br>INSERT INTO 表名 VALUES (值1, 值2, …), (值1, 值2, …), (值1, 值2, …);</p><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul><h4 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h4><p>修改数据：<br><code>UPDATE</code> 表名 <code>SET</code> 字段名1 &#x3D; 值1, 字段名2 &#x3D; 值2, … [ WHERE 条件 ];<br>例：<br>UPDATE emp SET name &#x3D; ‘Jack’ WHERE id &#x3D; 1;</p><p>删除数据：<br>DELETE FROM 表名 [ WHERE 条件 ];</p><h3 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT    字段列表FROM    表名字段WHERE    条件列表GROUP BY    分组字段列表HAVING    分组后的条件列表ORDER BY    排序字段列表LIMIT    分页参数</span><br></pre></td></tr></table></figure><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><p>查询多个字段：<br>SELECT 字段1, 字段2, 字段3, … FROM 表名;<br>SELECT * FROM 表名;</p><p>设置别名：<br>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], … FROM 表名;<br>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], … FROM 表名;</p><p><code>去除重复</code>记录：<br>SELECT <code>DISTINCT</code> 字段列表 FROM 表名;</p><p>转义：<br>SELECT * FROM 表名 WHERE name LIKE ‘&#x2F;_张三’ ESCAPE ‘&#x2F;‘<br>&#x2F; 之后的_不作为通配符</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></p><p>条件：</p><table><thead><tr><th align="left">比较运算符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">小于等于</td></tr><tr><td align="left">&#x3D;</td><td align="left">等于</td></tr><tr><td align="left">&lt;&gt; 或 !&#x3D;</td><td align="left">不等于</td></tr><tr><td align="left">BETWEEN … AND …</td><td align="left">在某个范围内（含最小、最大值）</td></tr><tr><td align="left">IN(…)</td><td align="left">在in之后的列表中的值，多选一</td></tr><tr><td align="left">LIKE 占位符</td><td align="left"><code>模糊匹配</code>（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td align="left">IS NULL</td><td align="left">是NULL</td></tr></tbody></table><table><thead><tr><th align="left">逻辑运算符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">AND 或 &amp;&amp;</td><td align="left">并且（多个条件同时成立）</td></tr><tr><td align="left">OR 或 ||</td><td align="left">或者（多个条件任意一个成立）</td></tr><tr><td align="left">NOT 或 !</td><td align="left">非，不是</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 年龄等于30select * from employee where age = 30;-- 年龄小于30select * from employee where age &lt; 30;-- 小于等于select * from employee where age &lt;= 30;-- 没有身份证select * from employee where idcard is null or idcard = &#x27;&#x27;;-- 有身份证select * from employee where idcard;select * from employee where idcard is not null;-- 不等于select * from employee where age != 30;-- 年龄在20到30之间select * from employee where age between 20 and 30;select * from employee where age &gt;= 20 and age &lt;= 30;-- 下面语句不报错，但查不到任何信息select * from employee where age between 30 and 20;-- 性别为女且年龄小于30select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;-- 年龄等于25或30或35select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);-- 姓名为两个字select * from employee where name like &#x27;__&#x27;;-- 身份证最后为Xselect * from employee where idcard like &#x27;%X&#x27;;</span><br></pre></td></tr></table></figure><h4 id="聚合查询（聚合函数）"><a href="#聚合查询（聚合函数）" class="headerlink" title="聚合查询（聚合函数）"></a>聚合查询（聚合函数）</h4><p>常见聚合函数：</p><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">count</td><td align="left">统计数量</td></tr><tr><td align="left">max</td><td align="left">最大值</td></tr><tr><td align="left">min</td><td align="left">最小值</td></tr><tr><td align="left">avg</td><td align="left">平均值</td></tr><tr><td align="left">sum</td><td align="left">求和</td></tr></tbody></table><p>语法：<br><code>SELECT 聚合函数(字段列表) FROM 表名;</code><br>例：<br>SELECT count(id) from employee where workaddress &#x3D; “广东省”;</p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></p><p>where 和 having 的区别：</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行<code>过滤</code>。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 根据性别分组，统计男性和女性数量</span></span><br><span class="line"><span class="keyword">select</span> gender, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 根据性别分组，统计男性和女性的平均年龄</span></span><br><span class="line"><span class="keyword">select</span> gender, <span class="built_in">avg</span>(age) <span class="keyword">from</span> employee <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 年龄小于45，并根据工作地址分组</span></span><br><span class="line"><span class="keyword">select</span> workaddress, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">45</span> <span class="keyword">group</span> <span class="keyword">by</span> workaddress;</span><br><span class="line"><span class="comment">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span></span><br><span class="line"><span class="keyword">select</span> workaddress, <span class="built_in">count</span>(<span class="operator">*</span>) address_count <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">45</span> <span class="keyword">group</span> <span class="keyword">by</span> workaddress <span class="keyword">having</span> address_count <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>执行顺序：<code>where &gt; 聚合函数 &gt; having</code></li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>语法：<br>SELECT 字段列表 FROM 表名 <code>ORDER BY</code> 字段1 <code>排序方式1</code>, 字段2 排序方式2;</p><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据年龄升序排序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br><span class="line"><span class="comment">-- 两字段排序，根据年龄升序排序，入职时间降序排序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>, entrydate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><p>如果是多字段排序，当<code>第一个字段值相同</code>时，才会<code>根据第二个字段进行排序</code></p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>语法：<br>SELECT 字段列表 FROM 表名 LIMIT <code>起始索引</code>, 查询<code>记录数</code>;</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询第一页数据，展示10条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee LIMIT <span class="number">0</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 查询第二页0就是第一页第一条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee LIMIT <span class="number">10</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h5 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>起始索引<code>从0开始</code>，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是<code>LIMIT</code></li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><h4 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序!!"></a>DQL执行顺序!!</h4><p><code>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</code></p><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><p>用户由主机名和用户名组成‘用户名‘@’主机名’</p><p>查询用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;#系统目录</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>创建用户:<br>CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;</p><p>修改用户密码：<br>ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘新密码’;</p><p>删除用户：<br>DROP USER ‘用户名‘@’主机名’;</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户test，只能在当前主机localhost访问create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;-- 创建用户test，能在任意主机访问create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;create user &#x27;test&#x27; identified by &#x27;123456&#x27;;-- 修改密码alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;-- 删除用户drop user &#x27;test&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>主机名可以使用 % 通配</li></ul><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>常用权限：</p><table><thead><tr><th align="left">权限</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ALL, ALL PRIVILEGES</td><td align="left">所有权限</td></tr><tr><td align="left">SELECT</td><td align="left">查询数据</td></tr><tr><td align="left">INSERT</td><td align="left">插入数据</td></tr><tr><td align="left">UPDATE</td><td align="left">修改数据</td></tr><tr><td align="left">DELETE</td><td align="left">删除数据</td></tr><tr><td align="left">ALTER</td><td align="left">修改表</td></tr><tr><td align="left">DROP</td><td align="left">删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td align="left">CREATE</td><td align="left">创建数据库&#x2F;表</td></tr></tbody></table><p>更多权限请看<a href="https://dhc.pythonanywhere.com/article/public/1/#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8">权限一览表</a></p><p>查询权限：<br>SHOW GRANTS FOR ‘用户名‘@’主机名’;</p><p>授予权限：<br>GRANT 权限列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;</p><p>撤销权限：<br>REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’;</p><h5 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>常用函数：</p><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">CONCAT(s1, s2, …, sn)</td><td align="left">字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td align="left">LOWER(str)</td><td align="left">将字符串全部转为小写</td></tr><tr><td align="left">UPPER(str)</td><td align="left">将字符串全部转为大写</td></tr><tr><td align="left">LPAD(str, n, pad)</td><td align="left">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td align="left">RPAD(str, n, pad)</td><td align="left">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td align="left">TRIM(str)</td><td align="left">去掉字符串头部和尾部的空格</td></tr><tr><td align="left">SUBSTRING(str, start, len)</td><td align="left">返回从字符串str从start位置起的len个长度的字符串</td></tr><tr><td align="left">REPLACE(column, source, replace)</td><td align="left">替换字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 拼接</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>);</span><br><span class="line"><span class="comment">-- 小写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="comment">-- 大写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="comment">-- 左填充---01</span></span><br><span class="line"><span class="keyword">SELECT</span> LPAD(<span class="string">&#x27;01&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="comment">-- 右填充01---</span></span><br><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">&#x27;01&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="comment">-- 去除空格</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(<span class="string">&#x27; Hello World &#x27;</span>);</span><br><span class="line"><span class="comment">-- 切片（起始索引为1）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>常见函数：</p><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">CEIL(x)</td><td align="left">向上取整</td></tr><tr><td align="left">FLOOR(x)</td><td align="left">向下取整</td></tr><tr><td align="left">MOD(x, y)</td><td align="left">返回x&#x2F;y的模</td></tr><tr><td align="left">RAND()</td><td align="left">返回0~1内的随机数</td></tr><tr><td align="left">ROUND(x, y)</td><td align="left">求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>常用函数：</p><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">CURDATE()</td><td align="left">返回当前日期</td></tr><tr><td align="left">CURTIME()</td><td align="left">返回当前时间</td></tr><tr><td align="left">NOW()</td><td align="left">返回当前日期和时间</td></tr><tr><td align="left">YEAR(date)</td><td align="left">获取指定date的年份</td></tr><tr><td align="left">MONTH(date)</td><td align="left">获取指定date的月份</td></tr><tr><td align="left">DAY(date)</td><td align="left">获取指定date的日期</td></tr><tr><td align="left">DATE_ADD(date, INTERVAL expr type)</td><td align="left">返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值,type是年月</td></tr><tr><td align="left">DATEDIFF(date1, date2)</td><td align="left">返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATE_ADDSELECT DATE_ADD(NOW(), <span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">YEAR</span>);</span><br></pre></td></tr></table></figure><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>常用函数：</p><table><thead><tr><th align="left">函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">IF(value, t, f)</td><td align="left">如果value为true，则返回t，否则返回f</td></tr><tr><td align="left">IFNULL(value1, value2)</td><td align="left">如果value1不为空，返回value1，否则返回value2</td></tr><tr><td align="left">CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td align="left">如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td align="left">CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td align="left">如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  name,  (<span class="keyword">case</span> <span class="keyword">when</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;中年&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;青年&#x27;</span> <span class="keyword">end</span>)<span class="keyword">from</span> employee;</span><br><span class="line"><span class="keyword">select</span>  name,  (<span class="keyword">case</span> workaddress <span class="keyword">when</span> <span class="string">&#x27;北京市&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;上海市&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;二线城市&#x27;</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span><span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>分类：</p><table><thead><tr><th align="left">约束</th><th align="left">描述</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">非空约束</td><td align="left">限制该字段的数据不能为null</td><td align="left">NOT NULL</td></tr><tr><td align="left">唯一约束</td><td align="left">保证该字段的所有数据都是唯一、不重复的</td><td align="left">UNIQUE</td></tr><tr><td align="left">主键约束</td><td align="left">主键是一行数据的唯一标识，要求非空且唯一</td><td align="left">PRIMARY KEY</td></tr><tr><td align="left">默认约束</td><td align="left">保存数据时，如果未指定该字段的值，则采用默认值</td><td align="left">DEFAULT</td></tr><tr><td align="left">检查约束（8.0.16版本后）</td><td align="left">保证字段值满足某一个条件</td><td align="left">CHECK</td></tr><tr><td align="left">外键约束</td><td align="left">用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td align="left">FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。</p><h3 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h3><table><thead><tr><th align="left">约束条件</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">主键</td><td align="left">PRIMARY KEY</td></tr><tr><td align="left">自动增长</td><td align="left">AUTO_INCREMENT</td></tr><tr><td align="left">不为空</td><td align="left">NOT NULL</td></tr><tr><td align="left">唯一</td><td align="left">UNIQUE</td></tr><tr><td align="left">逻辑条件</td><td align="left">CHECK</td></tr><tr><td align="left">默认值</td><td align="left">DEFAULT</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,   </span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,    </span><br><span class="line">    age <span class="type">int</span> <span class="keyword">check</span>(age <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">120</span>),    </span><br><span class="line">    status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span>,    </span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>添加外键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(    </span><br><span class="line">    字段名 字段类型,    </span><br><span class="line">    ...    </span><br><span class="line">    [<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY(外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名));</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名);</span><br><span class="line"><span class="comment">-- 例子这里的外键字段名是子表内对于的那个字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key(dept_id) <span class="keyword">references</span> dept(id);</span><br></pre></td></tr></table></figure><p>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h4 id="删除-x2F-更新行为"><a href="#删除-x2F-更新行为" class="headerlink" title="删除&#x2F;更新行为"></a>删除&#x2F;更新行为</h4><table><thead><tr><th align="left">行为</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">NO ACTION</td><td align="left">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）</td></tr><tr><td align="left">RESTRICT</td><td align="left">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）</td></tr><tr><td align="left">CASCADE</td><td align="left">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td align="left">SET NULL</td><td align="left">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td align="left">SET DEFAULT</td><td align="left">父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><p>更改删除&#x2F;更新行为：<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) <code>ON UPDATE 行为 ON DELETE 行为</code>;</p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在<code>多的</code>一方建立<code>外键</code>，指向一的一方的主键</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张<code>中间表</code>，中间表至少包含<code>两个外键</code>，<code>分别关联两方主键</code>(被关联的都是主键)</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于<code>单表拆分</code>，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以<code>提升操作效率</code><br>实现：在<code>任意</code>一方加入<code>外键</code>，关联另外一方的主键，并且设置<code>外键为唯一</code>的（UNIQUE）</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<br>select * from employee, dept;</p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p><code>消除无效笛卡尔积</code>：<br>select * from employee, dept <code>where</code> employee.dept &#x3D; dept.id;</p><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><p>内连接查询的是两张表<code>交集</code>的部分</p><p>隐式内连接：<br>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 …;</p><p>显式内连接：<br>SELECT 字段列表 FROM 表1 [ INNER ] <code>JOIN</code> 表2 ON <code>连接条件</code> …;</p><p>显式性能比隐式高</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工姓名，及关联的部门的名称</span></span><br><span class="line"><span class="comment">-- 隐式</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name <span class="keyword">from</span> employee <span class="keyword">as</span> e, dept <span class="keyword">as</span> d <span class="keyword">where</span> e.dept <span class="operator">=</span> d.id;</span><br><span class="line"><span class="comment">-- 显式</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name <span class="keyword">from</span> employee <span class="keyword">as</span> e <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>左外连接：<br>查询<code>左表</code>所有数据，以及两张表交集部分数据<br>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 …;<br>相当于查询<code>表1的所有</code>数据，<code>包含</code>表1和表2<code>交集</code>部分数据</p><p>右外连接：<br>查询<code>右表所有数据</code>，<code>以及</code>两张表<code>交集</code>部分数据<br>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 …;</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.name <span class="keyword">from</span> employee <span class="keyword">as</span> e <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br><span class="line"><span class="keyword">select</span> d.name, e.<span class="operator">*</span> <span class="keyword">from</span> dept d <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br><span class="line"><span class="comment">-- 这条语句与下面的语句效果一样</span></span><br><span class="line"><span class="comment">-- 右</span></span><br><span class="line"><span class="keyword">select</span> d.name, e.<span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">as</span> e <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h3 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h3><p>当前<code>表与自身的连接</code>查询，自连接<code>必须使用表别名</code></p><p>语法：<br>SELECT 字段列表 FROM 表A <code>别名A</code> JOIN 表A <code>别名B</code> ON 条件 …;</p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工及其所属领导的名字将这里看成两张表，找出其中员工的经理id等于该id的</span></span><br><span class="line"><span class="keyword">select</span> a.name, b.name <span class="keyword">from</span> employee a, employee b <span class="keyword">where</span> a.manager <span class="operator">=</span> b.id;</span><br><span class="line"><span class="comment">-- 没有领导的也查询出来</span></span><br><span class="line"><span class="keyword">select</span> a.name, b.name <span class="keyword">from</span> employee a <span class="keyword">left</span> <span class="keyword">join</span> employee b <span class="keyword">on</span> a.manager <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><h3 id="联合查询-union-union-all"><a href="#联合查询-union-union-all" class="headerlink" title="联合查询 union, union all"></a>联合查询 union, union all</h3><p>把<code>多次</code>查询的结果<code>合并</code>，形成一个新的查询集</p><p>语法：也就是在两个查询间加入union all</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...<span class="keyword">UNION</span> [<span class="keyword">ALL</span>]<span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ...</span><br></pre></td></tr></table></figure><h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>UNION ALL 会有<code>重复</code>结果，UNION 不会</li><li>联合查询<code>比使用or效率高</code>，不会使索引失效</li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> column1 <span class="operator">=</span> ( <span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure><p>子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个增删改查</p><p>根据<code>子查询结果</code>可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据<code>子查询位置</code>可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询销售部所有员工</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"><span class="comment">-- 根据销售部部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 合并（子查询）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询xxx入职之后的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> (<span class="keyword">select</span> entrydate <span class="keyword">from</span> employee <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>返回的结果是一列（可以是多行）。往下</p><p>常用操作符：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">IN</td><td align="left"><code>在</code>指定的集合范围内，多选一</td></tr><tr><td align="left">NOT IN</td><td align="left"><code>不在</code>指定的集合范围内</td></tr><tr><td align="left">ANY</td><td align="left">子查询返回列表中，有<code>任意</code>一个满足即可</td></tr><tr><td align="left">SOME</td><td align="left">与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td align="left">ALL</td><td align="left">子查询返回列表的<code>所有</code>值都必须满足</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询销售部和市场部的所有员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"><span class="comment">-- 查询比研发部任意一人工资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">any</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br></pre></td></tr></table></figure><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>返回的结果是一行（可以是多列）。往右<br>常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与xxx的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> (salary, manager) <span class="operator">=</span> (<span class="number">12500</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> (salary, manager) <span class="operator">=</span> (<span class="keyword">select</span> salary, manager <span class="keyword">from</span> employee <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>返回的结果是多行多列<code>其实就是把行子查询的IN进行了扩展</code><br>常用操作符：IN</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> (job, salary) <span class="keyword">in</span> (<span class="keyword">select</span> job, salary <span class="keyword">from</span> employee <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xxx1&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;xxx2&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>) <span class="keyword">as</span> e <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，事务会把<code>所有操作作为一个整体</code>一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>转账基本操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 查询张三账户余额</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 2. 将张三账户余额-1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 此语句出错后张三钱减少但是李四钱没有增加模拟sql语句错误</span></span><br><span class="line"><span class="comment">-- 3. 将李四账户余额+1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看事务提交方式只是查看</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@AUTOCOMMIT</span>;</span><br><span class="line"><span class="comment">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@AUTOCOMMIT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 设置手动提交后上面代码改为：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">commit</span>;# 手动模式下提交了才生效</span><br></pre></td></tr></table></figure><p>操作方式二：</p><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：表示当前事务结束<br><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h3 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务<code>一旦提交或回滚</code>，它对数据库中的数据的<code>改变就是永久</code>的</li></ul><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><table><thead><tr><th align="left">问题</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">脏读</td><td align="left">一个事务读到另一个事务<code>还没提交</code>的数据</td></tr><tr><td align="left">不可重复读</td><td align="left">一个事务先后读取同一条记录，但<code>两次</code>读取的<code>数据不同</code>  （可能是读取别的事务&#96;提交前后的内容）</td></tr><tr><td align="left">幻读</td><td align="left">一个事务按照条件<code>查询</code>数据时，<code>没有</code>对应的数据行，但是再<code>插入</code>数据时，又发现这行数据已经<code>存在</code></td></tr></tbody></table><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a></p><p>幻读：在解决可重复读的时候，一个事务内对于数据库的读取是不变的，可是在别的事务进行了写操作后，此时该事务还是无法读取这个操作，然后进行重复操作的时候就会报错。也就是读被隔离了，写没有被隔离</p></blockquote><h4 id="并发事务隔离级别"><a href="#并发事务隔离级别" class="headerlink" title="并发事务隔离级别"></a>并发事务隔离级别</h4><table><thead><tr><th align="left">隔离级别</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻读</th></tr></thead><tbody><tr><td align="left">Read uncommitted 读未提交</td><td align="left">√</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">Read committed   读已提交</td><td align="left">×</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">Repeatable Read(默认) 可重复读</td><td align="left">×</td><td align="left">×</td><td align="left">√</td></tr><tr><td align="left">Serializable          串行化</td><td align="left">×</td><td align="left">×</td><td align="left">×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL体系结构：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图"><br><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述"></p><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是InnoDB。</p><p>相关操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> account;</span><br><span class="line"><span class="comment">-- 建表时指定存储引擎</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(    ...) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="comment">-- 查看当前数据库支持的存储引擎</span></span><br><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code></p><p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构"></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table><thead><tr><th align="left">特点</th><th align="left">InnoDB</th><th align="left">MyISAM</th><th align="left">Memory</th></tr></thead><tbody><tr><td align="left">存储限制</td><td align="left">64TB</td><td align="left">有</td><td align="left">有</td></tr><tr><td align="left">事务安全</td><td align="left">支持</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">锁机制</td><td align="left">行锁</td><td align="left">表锁</td><td align="left">表锁</td></tr><tr><td align="left">B+tree索引</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">Hash索引</td><td align="left">-</td><td align="left">-</td><td align="left">支持</td></tr><tr><td align="left">全文索引</td><td align="left">支持（5.6版本之后）</td><td align="left">支持</td><td align="left">-</td></tr><tr><td align="left">空间使用</td><td align="left">高</td><td align="left">低</td><td align="left">N&#x2F;A</td></tr><tr><td align="left">内存使用</td><td align="left">高</td><td align="left">低</td><td align="left">中等</td></tr><tr><td align="left">批量插入速度</td><td align="left">低</td><td align="left">高</td><td align="left">高</td></tr><tr><td align="left">支持外键</td><td align="left">支持</td><td align="left">-</td><td align="left">-</td></tr></tbody></table><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对<code>事物</code>的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以<code>读操作和插入操作为主</code>，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于<code>临时表及缓存</code>。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的<code>足迹和评论</code>适合使用 MyISAM 引擎，<code>缓存</code>适合使用 Memory 引擎。</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code> 或者 <code>SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code><br>例：<code>show global status like &#39;Com_______&#39;</code></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢查询日志开关slow_query_log=1# 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2</span><br></pre></td></tr></table></figure><p>更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p><p>查看慢查询日志开关状态：<br><code>show variables like &#39;slow_query_log&#39;;</code></p><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</span><br></pre></td></tr></table></figure><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<code>数据结构（有序）</code>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，<code>降低数据排序的成本</code>，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大<code>提高了查询</code>效率，但<code>降低了更新的速度</code>，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><table><thead><tr><th align="left">索引结构</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">B+Tree</td><td align="left">最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td align="left">Hash</td><td align="left">底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td align="left">R-Tree(空间索引)</td><td align="left">空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td align="left">Full-Text(全文索引)</td><td align="left">是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th align="left">索引</th><th align="left">InnoDB</th><th align="left">MyISAM</th><th align="left">Memory</th></tr></thead><tbody><tr><td align="left">B+Tree索引</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">Hash索引</td><td align="left">不支持</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">R-Tree索引</td><td align="left">不支持</td><td align="left">支持</td><td align="left">不支持</td></tr><tr><td align="left">Full-text</td><td align="left">5.6版本后支持</td><td align="left">支持</td><td align="left">不支持</td></tr></tbody></table><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>结构图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，<code>层级更少</code>，<code>搜索效率高</code></li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低   <code>因为InnoDB中使用页/块来存储，如果将数据一起存在非叶子节点，那么一页的键值就会减少，指针数也变少，树就会越高</code></li><li>相对于 Hash 索引，B+Tree 支持<code>范围匹配</code>及<code>排序</code>操作</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table><thead><tr><th align="left">分类</th><th align="left">含义</th><th align="left">特点</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">主键索引</td><td align="left">针对于表中主键创建的索引</td><td align="left">默认自动创建，只能有一个</td><td align="left">PRIMARY</td></tr><tr><td align="left">唯一索引</td><td align="left">避免同一个表中某数据列中的值重复</td><td align="left">可以有多个</td><td align="left">UNIQUE</td></tr><tr><td align="left">常规索引</td><td align="left">快速定位特定数据</td><td align="left">可以有多个</td><td align="left"></td></tr><tr><td align="left">全文索引</td><td align="left">全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td align="left">可以有多个</td><td align="left">FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据<code>索引的存储形式</code>，又可以分为以下两种：</p><table><thead><tr><th align="left">分类</th><th align="left">含义</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left">聚集索引(Clustered Index)</td><td align="left">将数据存储与索引放一块，索引结构的<code>叶子节点保存了行数据</code></td><td align="left">必须有，而且只有一个</td></tr><tr><td align="left">二级索引(Secondary Index)</td><td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是<code>对应的主键</code></td><td align="left">可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在<code>主键</code>，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个<code>唯一</code>(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 <code>rowid</code> 作为隐藏的聚集索引</li></ul><p>根据二级索引得到的主键找到主键对于的数据这种操作叫做<code>回表查询</code></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ol><li>以下 SQL 语句，哪个执行效率高？为什么？</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span>;</span><br><span class="line"><span class="comment">-- 备注：id为主键，name字段创建的有索引</span></span><br></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><ol start="2"><li>InnoDB 主键索引的 B+Tree 高度为多少？</li></ol><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。<code>InnoDB</code> 的<code>指针占用6个字节</code>的空间，主键假设为bigint，占用字节数为8,<code>一页大小为16k</code>.<br>可得公式：n * 8 + (n + 1) * 6 &#x3D; 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 &#x3D; 18736；<br>如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 &#x3D; 21939856。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>创建索引：<br><code>CREATE</code> [ UNIQUE | FULLTEXT ] <code>INDEX</code> index_name <code>ON</code> table_name (index_col_name, …);<br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br>SHOW INDEX FROM table_name;</p><p>删除索引：<br>DROP INDEX index_name ON table_name;</p><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br><span class="line"><span class="comment">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone <span class="keyword">on</span> tb_user (phone);</span><br><span class="line"><span class="comment">-- 为profession, age, status创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_stat <span class="keyword">on</span> tb_user(profession, age, status);</span><br><span class="line"><span class="comment">-- 为email建立合适的索引来提升查询效率</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> tb_user; </span><br></pre></td></tr></table></figure><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引关联了多列（<code>联合</code>索引），要遵守最左前缀法则，最左前缀法则指的是<code>查询</code>从索引的<code>最左列开始</code>，并且<code>不跳过索引中的列</code>。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 (<strong><code>这里的左指的是创建索引的左</code></strong>)</p><p><strong><code>也就是对于联合索引，在查的时候要保证输入条件是按照联合索引的顺序来的，如果某一个缺失，后面的就都失效了（没用了）。</code></strong></p><p>联合索引其实就是将两个索引拼接成一个新的索引</p><p>注意：这里关注的只有跳过某个索引，也就是对于联合索引的顺序，不同的索引重要性不一样，缺失了前面的，后面的就失效了，这里<code>和输入的顺序无关</code>。</p><p>联合索引中，出现<code>范围查询</code>（&lt;, &gt;），范围查询<code>右侧的列索引失效</code>。可以用<code>&gt;=</code>或者<code>&lt;=</code>来<code>规避</code>索引失效问题。</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol><li>在索引列上进行<code>运算</code>操作，<code>索引将失效</code>。如：explain select * from tb_user where <code>substring(phone, 10, 2) = &#39;15&#39;</code>;</li><li><code>字符串类型</code>字段使用时，<code>不加引号，索引将失效</code>。如：explain select * from tb_user where phone &#x3D; 17799990015;，此处phone的值没有加引号</li><li><code>模糊查询</code>中，如果仅仅是<code>尾部</code>模糊匹配，索引<code>不会</code>是<code>失效</code>；如果是<code>头部</code>模糊匹配，索引<code>失效</code>。如：explain select * from tb_user where profession like ‘%工程’;，前后都有 % 也会失效。</li><li>用 <code>or</code> 分割开的条件，如果 or <code>其中一个</code>条件的列<code>没有</code>索引，那么<code>涉及的索引都不会被用到</code>。</li><li>如果 MySQL <code>评估</code>使用<code>索引</code>比全表<code>更慢</code>，则<code>不使用索引</code>。</li></ol><h4 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些<code>人为的提示</code>来达到优化操作的目的。</p><p>例如，建议使用索引：<br>explain select * from tb_user <code>use index</code>(idx_user_pro) where profession&#x3D;”软件工程”;<br>不使用哪个索引：<br>explain select * from tb_user <code>ignore index</code>(idx_user_pro) where profession&#x3D;”软件工程”;<br>必须使用哪个索引：<br>explain select * from tb_user <code>force index</code>(idx_user_pro) where profession&#x3D;”软件工程”;</p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="覆盖索引-amp-回表查询"><a href="#覆盖索引-amp-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h4><p>尽量使用<code>覆盖索引</code>（查询使用了索引，并且<code>需要返回的列，在该索引中已经全部能找到</code>），减少 select *。</p><p>explain 中 extra 字段含义：<br>using index condition：查找使用了索引，但是需要<code>回表查询</code>数据<br>using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以<code>不需要回表查询</code></p><p><strong><code>其实就是在查找的时候，有些select的值是在索引的过程中就能找到的，而有些是需要再去查找的，也就是需要回表查询</code></strong></p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name&#x3D;’xxx’;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name&#x3D;’xxx’;</p><p>所以<code>尽量不要用select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br>select id, username, password from tb_user where username&#x3D;’itcast’;</p><p>解：给username和password字段建立<code>联合索引</code>，<code>则不需要回表查询，直接覆盖索引</code></p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只将<code>字符串的一部分前缀</code>，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：create index idx_xxxx on table_name(columnn(<code>n</code>));取前n个字符<br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email, <span class="number">1</span>, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="单列索引-amp-联合索引"><a href="#单列索引-amp-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br>explain select id, phone, name from tb_user where phone &#x3D; ‘17799990010’ and name &#x3D; ‘韩信’;<br>这句只会用到phone索引字段</p><h5 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>针对于数据<code>量较大</code>，且<code>查询比较频繁</code>的表建立索引</li><li>针对于<code>常作为查询条件（where）、排序（order by）、分组（group by）操作</code>的<code>字段</code>建立索引</li><li>尽量选择<code>区分度高</code>的列作为索引，尽量建立<code>唯一索引</code>，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立<code>前缀</code>索引</li><li><code>尽量使用联合</code>索引，减少单列索引，查询时，联合索引很多时候可以<code>覆盖索引</code>，<code>节省存储空间</code>，<code>避免回表</code>，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，<code>索引越多，维护索引结构的代价就越大</code>，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用<code>NOT NULL约束</code>它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>普通插入：</p><ol><li>采用<code>批量</code>插入（一次插入的数据不建议超过1000条）</li><li><code>手动提交</code>事务</li><li><code>主键顺序</code>插入</li></ol><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 <span class="comment">--local-infile（这一行在bash/cmd界面输入）</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"># 设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;<span class="keyword">select</span> @<span class="variable">@local</span>_infile;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;tb_user&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"># <span class="keyword">local</span> infile 本地文件fields terminated <span class="keyword">by</span> 各个键之间的分隔符 lines terminated <span class="keyword">by</span> 行之间的分隔符</span><br></pre></td></tr></table></figure><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>数据组织方式：在<code>InnoDB存储引擎</code>中，表数据都是根据<code>主键顺序组织存放</code>的，这种存储方式的表称为<code>索引组织表</code>（Index organized table, IOT）</p><p><code>页分裂</code>：页可以为空，也可以填充一般，也可以填充100%，每个页包含了<code>2-N</code>行数据（如果一行数据过大，会行溢出），根据主键排列。<code>乱序插入时如果这一页已经满了，会根据B+树的原则进行分页和添加数据</code></p><p><code>页合并</code>：当删除一行记录时，实际上记录并没有被物理删除，只是<code>记录被标记</code>（flaged）为<code>删除</code>并且它的空间变得<code>允许被其他记录声明使用</code>。当页中删除的记录到达 <code>MERGE_THRESHOLD</code>（默认为<code>页的50%</code>），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个<code>页合并</code>以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量<code>降低主键的长度</code>,<code>因为二级索引存储的是主键的值，所以太长会浪费空间</code></li><li>插入数据时，尽量选择<code>顺序插入</code>，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，<code>避免对主键的修改</code>,因为要一起修改二级索引等</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><ol><li>Using <code>filesort</code>：通过表的索引或全表扫描，读取满足条件的数据行，然后在<code>排序缓冲区</code> sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过<code>有序索引顺序扫描直接返回</code>有序数据，这种情况即为 using index，<code>不需要额外排序</code>，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果<code>一个</code>字段<code>升序</code>排序，另<code>一个</code>字段<code>降序</code>排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要<code>另外再创建一个索引</code>，如：</p><p>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，</p><p>此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，<code>多字段排序时，也遵循最左前缀法则</code></li><li>尽量使用<code>覆盖</code>索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现filesort，<code>大数据量排序</code>时，可以适当增大<code>排序缓冲区</code>大小 sort_buffer_size（默认256k）</li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为idx_user_pro_age_stat，则句式可以是select … where profession order by age，这样也符合最左前缀法则</p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过<code>覆盖索引加子查询</code>形式进行优化</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此语句耗时很长</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku limit <span class="number">9000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span></span><br><span class="line"><span class="comment">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span></span><br><span class="line"><span class="comment">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku <span class="keyword">as</span> s, (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>, <span class="number">10</span>) <span class="keyword">as</span> a <span class="keyword">where</span> s.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p><code>MyISAM</code> 引擎把一个表的总行数存在了磁盘上，因此执行 count() 的时候会直接返回这个数，<code>效率很高</code>（前提是不适用where）；<br><code>InnoDB</code> 在执行 count() 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis*</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count()一样，因为<code>主键不能为空</code>；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count()一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：<code>没有not null</code>约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层<code>判断</code>是否为null，不为null，计数累加；有<code>not null约束</code>的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，<code>直接</code>按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，<code>放一个数字 1 (不是1也行)进去</code>，直接<code>按行进行累加</code></li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，<code>不取值</code>，服务层<code>直接按行进行累加</code></li></ul><p>按效率排序：<code>count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)</code>，所以尽量使用 count(*)</p><h3 id="update优化（避免行锁升级为表锁）"><a href="#update优化（避免行锁升级为表锁）" class="headerlink" title="update优化（避免行锁升级为表锁）"></a>update优化（避免行锁升级为表锁）</h3><p>InnoDB 的<code>行锁</code>是针对<code>索引</code>加的锁，不是针对<code>记录</code>加的锁，并且该索引不能失效，否则会从行锁升级为<code>表锁</code>。</p><p>如以下两条语句：<br>update student set no &#x3D; ‘123’ where id &#x3D; 1;，这句由于<code>id有主键索引</code>，所以只会锁这一行；<br>update student set no &#x3D; ‘123’ where name &#x3D; ‘test’;，这句由于<code>name没有索引</code>，所以会把<code>整张表都锁</code>住进行数据更新，解决方法是给name字段添加索引</p><h2 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h2><p>视图（View）是一种<code>虚拟存在的表</code>。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图<code>只保存了查询的SQL逻辑</code>，不保存查询<code>结果</code>。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] <span class="keyword">VIEW</span> 视图名称[（列名列表）] <span class="keyword">AS</span> <span class="keyword">SELECT</span> 语句 [ <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ]</span><br></pre></td></tr></table></figure><blockquote><p>例子： create or replace view <code>stu_wll</code> as <code>select id,name from student where id&lt;=10</code>;</p></blockquote><h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>查看创建视图语句： <code>SHOW CREATE VIEW </code>视图名称；</p><p>查看视图数据：<code>SELECT*FROM </code> 视图名称；<br><code>show create view stu_v_1;</code></p><h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><p>方式一：<code>CREATE[OR REPLACE] VIEW 视图名称[（列名列表)）] AS SELECT 语句[ WITH[ CASCADED | LOCAL ] CHECK OPTION ]</code></p><p>方式二：<code>ALTER VIEW 视图名称 [（列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</code></p><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] 视图名称 [视图名称]</span><br></pre></td></tr></table></figure><h3 id="视图检查选项"><a href="#视图检查选项" class="headerlink" title="视图检查选项"></a>视图检查选项</h3><p>当使用<code>WITH CHECK QPTION</code>子句<code>创建</code>视图时，MySQL会通过视图<code>检查</code>正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。MySQL允许<code>基于另一个视图创建视图</code>，它还会检查依赖视图中的规则以保持<code>一致性</code>。为了确定检查的<code>范围</code>，mysql提供了两个选项：CASCADED 和 LOCAL ，默认值为 CASCADED。</p><p>NOTE：如果没有开检查选项就不会进行检查。不同版本是不同含义的，要看版本。</p><h4 id="CASCADED"><a href="#CASCADED" class="headerlink" title="CASCADED"></a>CASCADED</h4><p>级联，一旦选择了这个选项，除了会检查<code>创建</code>视图时候的条件，还会检查所<code>依赖</code>视图的条件。</p><blockquote><p>比如下面的例子：创建stu_V_l 视图，id是小于等于 20的。<br>create or replace view stu_V_l as select id,name from student where id &lt;&#x3D;20; </p><p>再创建 stu_v_2 视图，20 &gt;&#x3D; id &gt;&#x3D;10。<br>create or replace view stu_v_2 as select id,name <code>from stu_v_1</code> where id &gt;&#x3D;10 <code>with cascaded check option</code>; </p><p>再创建 stu_v_3 视图。<br>create or replace view stu_v_3 as select id,name <code>from stu_v_2</code> where id&lt;&#x3D;15;</p><p>这条数据能够成功，stu_v_3 <code>没有开检查选项</code>所以不会 去判断 id 是否小于等于15, <code>直接检查 是否满足 stu_v_2</code>。<br>insert into stu_v_3 values(17,’Tom’);</p></blockquote><h4 id="LOCAL"><a href="#LOCAL" class="headerlink" title="LOCAL"></a>LOCAL</h4><p>本地的条件也会检查，还会向上检查。在向上找的时候，就要看是否上面开了检查选项，如果没开就不检查。和 CASCADED 的区别就是 <code>CASCADED 不管上面开没开检查选项都会进行检查</code>。</p><h3 id="更新及作用"><a href="#更新及作用" class="headerlink" title="更新及作用"></a>更新及作用</h3><p>要使视图<code>可更新</code>，视图中的行与基础表中的行之间必须存在<code>一对一</code>的关系。如果视图包含以下任何一项，则该视图不可更新</p><ol><li>聚合函数或窗口函数 ( SUM()、MIN()、MAX()、COUNT() 等 )</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION 或者UNION ALL</li></ol><blockquote><p>例子： 使用了聚合函数，插入会失败。 这里失去了一一对应的关系</p><p><code>create view stu_v_count as select count(*) from student;</code><br><code>insert into stu_v_count values(10);</code></p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>视图不仅可以<code>简化用户对数据的理解</code>，也可以简化他们的操作。那些<code>被经常使用的查询可以被定义为视图</code>，从而使得用户不必为以后的操作每次指定全部的条件。</p><h5 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h5><p>数据库可以授权，但不能授权到数据库<code>特定行和特定的列</code>上。通过视图用户只能查询和修改他们所能见到的数据</p><h5 id="数据独立"><a href="#数据独立" class="headerlink" title="数据独立"></a>数据独立</h5><p>视图可帮助用户<code>屏蔽真实表结构变化</code>带来的影响。</p><p>总而言之 类似于给表加上了一个外壳，通过这个外壳访问表的时候，只能按照所设计的方式进行访问与更新。</p><h2 id="存储过程-routines"><a href="#存储过程-routines" class="headerlink" title="存储过程(routines)"></a>存储过程(routines)</h2><p>存储过程是<code>事先经过编译并存储</code>在数据库中的一段<code>SQL 语句的集合</code>，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库SQL 语言层面的代码封装与重用。</p><p>特点</p><ol><li>封装</li><li>复用</li><li>可以接收参数，也可以返回数据减少网络交互，效率提升</li></ol><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称( [参数列表] ) </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">SQL</span> 语句 ;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>NOTE: 在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter 指定SQL语句的结束符。默认是 分号作为结束符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$ </span><br></pre></td></tr></table></figure><p>则 $$ 符作为结束符。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 名称 ( [参数])</span><br></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>查询指定数据库的存储过程及状态信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="keyword">WHERE</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span> </span><br></pre></td></tr></table></figure><p>存储过程名称；–查询某个存储过程的定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 名称</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> [ IFEXISTS ] 存储过程名称</span><br></pre></td></tr></table></figure><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>游标（CURSOR）是用来<code>存储查询结果集</code>的数据类型，在存储过程和函数中可以<code>使用游标对结果集进行循环的处理</code>。游标的使用包括游标的声明、OPEN、FETCH和CLOSE，其语法分别如下。</p><blockquote><p>声明游标： <code>DECLARE 游标名称 CURSOR FOR 查询语句</code></p></blockquote><blockquote><p>打开游标： <code>OPEN 游标名称</code></p></blockquote><blockquote><p>获取游标记录： <code>FETCH 游标名称INTO变量[变量]</code></p></blockquote><p>条件处理程序：<br>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><blockquote><p>DECLARE handler action HANDLER FOR condition value L condition value]..statement</p></blockquote><p>handler_action CONTINUE：继续执行当前程序</p><p>EXIT：终止执行当前程序</p><p>condition_value :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQLSTATE</span> sqlstate_value：状态码，如<span class="number">02000</span></span><br><span class="line"><span class="keyword">SQLWARNING</span>：所有以<span class="number">01</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line"><span class="keyword">NOT</span> FOUND：所有以<span class="number">02</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line"><span class="keyword">SQLEXCEPTION</span>：所有没有被<span class="keyword">SQLWARNING</span>或<span class="keyword">NOT</span> FOUND捕获的<span class="keyword">SQLSTATE</span>代码的简写</span><br></pre></td></tr></table></figure><p>例子：</p><p>NOTE：要先声明普通变量，再申请游标。</p><p>要求： <code>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表（id，name，profession）中。</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1l(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>); # 用于存储游标中的记录注意：要先声明普通变量再声明游标</span><br><span class="line"><span class="keyword">decLare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage; # 声明游标</span><br><span class="line">#当 条件处理程序的处理的状态码为<span class="number">02000</span>的时候，就会退出。</span><br><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span><span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro; </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(# 创建表</span><br><span class="line">            id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, </span><br><span class="line">            name <span class="type">varchar</span>(<span class="number">100</span>), </span><br><span class="line">            profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">open</span> u_cursor; # 开启游标</span><br><span class="line">while <span class="literal">true</span> do </span><br><span class="line">            <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,Upro; # 获取数据并赋值</span><br><span class="line">            <span class="keyword">insert</span> <span class="keyword">into</span> tb_user_pro <span class="keyword">values</span>(<span class="keyword">null</span>,uname,Upro);  # 插入数据</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">close</span> u_cursor; # 关闭游标</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>全局变量：GLOBAL，全局可用</p><p>会话变量：SESSION，该会话可用</p><h3 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h3><p>类似于异常机制</p><p>MySQL 的条件处理程序（Conditional Handler）是一种用于<code>处理存储过程或函数中异常情况</code>或<code>特定条件</code>的结构。它允许在程序执行过程中检测和处理特定的条件，例如错误、警告或查询结果为空等。</p><p>条件处理程序通常与存储过程或函数一起使用，用于<code>捕获和处理可能发生的异常情况</code>。它可以用于执行以下操作：</p><ol><li>处理 SQL 错误：条件处理程序可以捕获并处理在存储过程或函数中执行 SQL 语句时发生的错误。这使得可以针对不同的错误情况采取相应的处理措施，例如记录日志、回滚事务或返回自定义错误信息等。</li><li>处理 SQL 警告：条件处理程序可以捕获并处理在存储过程或函数中执行 SQL 语句时产生的警告。这使得可以根据警告类型采取适当的操作，例如忽略警告、记录警告信息或采取其他处理措施。</li><li>处理查询结果为空：条件处理程序可以检测查询语句的结果集是否为空，并根据需要采取相应的操作。例如，可以选择在结果集为空时返回默认值、抛出异常或执行其他逻辑。</li></ol><p>条件处理程序使用以下语法定义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlCopy code</span><br><span class="line"><span class="keyword">DECLARE</span> condition_name <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> condition_value;</span><br></pre></td></tr></table></figure><p>在这里，<code>condition_name</code> 是条件处理程序的名称，<code>condition_value</code> 是一个整数值，表示特定的错误代码或 SQLSTATE 值。</p><p>一旦条件处理程序定义完成，可以在存储过程或函数中使用 <code>DECLARE ... HANDLER</code> 语句来捕获并处理特定的条件。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlCopy code</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> condition_name statement;</span><br></pre></td></tr></table></figure><p>在这里，<code>condition_name</code> 是之前定义的条件处理程序的名称，<code>statement</code> 是在特定条件发生时要执行的语句。</p><p>通过条件处理程序，可以根据特定的条件或错误类型，定义自定义的错误处理逻辑，提高存储过程或函数的健壮性和容错性。</p><p>请注意，条件处理程序只能在存储过程、函数和触发器中使用，而不能直接在普通的 SQL 语句中使用。</p><p>这一段可以加在上面游标定义的下面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor; # 状态码看官方文档</span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">close</span> u_cursor;</span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>介绍<br>触发器是与表有关的数据库对象，指在<code>insert/update/delete之前或之后</code>，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。<br>使用<code>别名OLD和NEW</code>来<code>引用触发器中发生变化的记录内容</code>，这与其他的数据库是相似的。现在触发器还只支持<code>行级触发</code>（比如说 一条语句影响了 5 行 则会被触发 5 次），不支持语句级触发（比如说 一条语句影响了 5 行 则会被触发 1 次）。</p><table><thead><tr><th>触发器<code>类型</code></th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td><code>INSERT</code></td><td><code>NEW</code> 表示将要或者已经新增的数据</td></tr><tr><td><code>UPDATE</code></td><td><code>OLD</code>表示修改之前的数据，<code>NEW</code>表示将要或已经修改后的数据</td></tr><tr><td><code>DELETE</code></td><td><code>OLD</code>表示将要或者已经删除的数据</td></tr></tbody></table><p>创建触发器（CREATE TRIGGER）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlCopy codeCREATE <span class="keyword">TRIGGER</span> trigger_name trigger_time trigger_event</span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> table_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">--行级触发器</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 触发器的逻辑代码</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><code>trigger_name</code> 是要创建的触发器的名称。</li><li><code>trigger_time</code> 指定触发器的执行时机，可以是 BEFORE 或 AFTER。</li><li><code>trigger_event</code> 指定触发器要响应的事件，例如 INSERT、UPDATE 或 DELETE。</li><li><code>table_name</code> 是触发器要关联的表的名称。</li><li><code>FOR EACH ROW</code> 表示触发器将为每一行数据触发执行。</li><li>在 <code>BEGIN</code> 和 <code>END</code> 之间编写触发器的逻辑代码。</li></ul><p>查看触发器（SHOW TRIGGERS）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS <span class="keyword">LIKE</span> <span class="string">&#x27;table_name&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>table_name</code> 是要查看触发器的表的名称。</li></ul><p>这条语句将显示指定表的触发器信息，包括触发器名称、触发时机、触发事件等。</p><p>删除触发器（DROP TRIGGER）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [IF <span class="keyword">EXISTS</span>] trigger_name;</span><br></pre></td></tr></table></figure><ul><li><code>trigger_name</code> 是要删除的触发器的名称。</li><li><code>IF EXISTS</code> 可选参数，如果指定了该参数，则在触发器不存在时不会引发错误。</li></ul><p>使用此语句可以删除指定名称的触发器。</p><p>请注意，上述语句中的关键字和参数需要根据实际情况进行替换或调整。确保在执行删除触发器操作之前，先确认要删除的触发器的名称和关联表的名称，并确保有足够的权限执行这些操作。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>NOTE : 针对事物才有加锁的意义。</p><p>分类：MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ol><li><code>全局锁</code>：锁定数据库中的<code>所有表</code>。 </li><li><code>表级锁</code>：每次操作锁住<code>整张表</code>。</li><li><code>行级锁</code>：每次操作锁住对应的<code>行数据</code>。</li></ol><p>全局锁：</p><p>全局锁就是对<code>整个数据库</code>实例加锁，加锁后整个实例就处于<code>只读</code>状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。<code>全局锁时，会有两种情况，一种是主库备份，业务可能得停摆，一种是从库备份，那么会导致主从延迟，在InnoDB引擎中，可以在备份的时候加上--single-transaction参数来完成不加锁的一致性数据备份。</code></p><p>表锁：</p><p>表级锁，每次操作<code>锁住整张表</code>。锁定<code>粒度大</code>，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ol><li><code>表锁</code>：对于表锁，分为两类：1.<code>表共享读锁</code>（read lock）所有的事物都只<code>能读</code>（当前加锁的客户端也只能读，不能写），<code>不能写</code> 2.<code>表独占写锁</code>（write lock），对<code>当前加锁的客户端</code>，可读可写，对于其他的客户端，不可读也不可写。<br>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</li><li><code>元数据锁</code>（meta data lock，MDL），MDL加锁过程是系统<code>自动控制</code>，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是<code>维护表元数据的数据一致性</code>，在表上有活动事务的时候，不可以对元数据进行写入操作。在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）;当对表结构进行变更操作的时候，加MDL写锁（排他）。<code>防止DML（数据操作）和DDL（数据定义）语句冲突</code></li><li><code>意向锁</code>: 为了避免DML在执行时，加的<code>行锁与表锁的冲突</code>，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用<code>意向锁来减少表锁的检查</code>。<br>一个客户端对某一行加上了行锁，那么系统也会对其加上一个意向锁，当别的客户端来想要对其加上表锁时，便会检查意向锁是否兼容，若是不兼容，便会阻塞直到意向锁释放。</li></ol><p>意向锁兼容性：</p><ol><li><code>意向共享</code>锁（IS）：与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。</li><li><code>意向排他</code>锁（lX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥。</li></ol><p>行锁：</p><p>行级锁，每次操作锁住对应的行数据。锁定<code>粒度最小</code>，发生<code>锁冲突的概率最低</code>，并发度最高。应用在InnoDB存储引擎中。<br>InnoDB的数据是<code>基于索引组织</code>的，行锁是通过对<code>索引上的索引项加锁</code>来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol><li>行锁（Record Lock）：锁定<code>单个行记录</code>的锁，防止其他事务对此行进行update和delete。在RC（read commit ）、RR（repeat read）隔离级别下都支持。</li><li>间隙锁（GapLock）：锁定<code>索引记录间隙</code>（<code>不含该记录</code>），确保索引记录间隙<code>不变</code>，防止其他事务在这个间隙进行insert，产生幻读。在<code>RR隔离级别</code>下都支持。比如说 两个临近叶子节点为 15 23，那么间隙就是指 [15 , 23],锁的是这个间隙。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住<code>数据</code>，并锁住数据前面的<code>间隙Gap</code>。在RR隔离级别下支持。</li></ol><p>InnoDB实现了以下两种类型的行锁：</p><ol><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ol><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>insert</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>update</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>delete</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>select</td><td>不加任何锁</td><td></td></tr><tr><td>select　lock　in　share mode</td><td>排他锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>select　for　update</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p>行锁 - 演示</p><p>默认情况下，InnoDB在<code>REPEATABLE READ</code>事务隔离级别运行，InnoDB使用<code>next-key 锁</code>进行搜索和索引扫描，以防止幻读。</p><ol><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会<code>自动优化为行锁</code>。</li><li>InnoDB的行锁是针对于索引加的锁，<code>不通过索引条件检索数据</code>，那么InnoDB将对表中的所有记录加锁，此时就会<code>升级为表锁</code>。</li></ol><p>间隙锁&#x2F;临键锁-演示</p><p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li>索引上的<code>等值</code>查询（<code>唯一索引</code>），给<code>不存在</code>的记录加锁时，<code>优化为间隙锁</code>。<code>也就是锁住记录在的间隙，防止其余的操作</code></li><li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。<code>防止幻读</code></li><li>索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。</li></ol><p>注意：间隙锁唯一目的是<code>防止其他事务插入间隙</code>。间隙锁可以共存，<code>一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁</code>。</p><h2 id="InnoDB-引擎"><a href="#InnoDB-引擎" class="headerlink" title="InnoDB 引擎"></a>InnoDB 引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p><code>表空间</code>（ibd文件），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><p><code>段</code>，分为<code>数据段</code>（Leaf node segment）、<code>索引段</code>（Non-leaf node segment）、<code>回滚段</code>（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><p><code>区</code>，表空间的单元结构，每个区的大小为<code>1M</code>。默认情况下，InnoDB存储引擎页大小为<code>16K</code>，即一个<code>区中一共有64个连续的页</code>。</p><p><code>页</code>，是InnoDB存储引擎磁盘管理的<code>最小</code>单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎<code>每从磁盘申请4-5个区。一页包含若干行</code>。</p><p><code>行</code>，InnoDB存储引擎数据是按进行存放的。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/artic.png" alt="images"></a></p><p>Buffer Pool：缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘I0，加快处理速度。</p><p><a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic2.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/artic2.png" alt="images"></a> <a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic3.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/artic3.png" alt="images"></a> <a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic4.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/artic4.png" alt="images"></a> <a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic5.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/artic5.png" alt="images"></a></p><p>磁盘架构： <a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic6.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/artic6.png" alt="images"></a> <a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic7.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/artic7.png" alt="images"></a> <a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic8.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/artic8.png" alt="images"></a></p><p>InnoDB的整个体系结构为：</p><p>当业务操作的时候直接操作的是内存缓冲区，如果缓冲区当中没有数据，则会从磁盘中加载到缓冲区，增删改查都是在缓冲区的，后台线程以一定的速率刷新到磁盘。</p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时败。具有ACID四大特征。</p><p>原子性，一致性，持久性这三大特性由 redo log 和 undo log 日志来保证的。 隔离性 是由锁机制和MVCC保证的。</p><p>redo log:</p><p><code>重做日志</code>，记录的是事务提交时数据页的<code>物理修改</code>，是用来实现事务的持久性。 该日志文件由两部分组成：重做日志缓冲（<code>redo log buffer</code>）以及重做日志文件（<code>redo log file</code>），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><blockquote><p>个人理解： 事物每次提交的时候都会将数据刷到redo log中而<code>不是直接将buffer pool中的数据直接刷到磁盘中</code>（ibd文件中），是因为redo log 是顺序写，性能处理的够快，<code>直接刷到ibd中，是随机写，性能慢</code>。所以脏页是在下一次读的时候，或者后台线程采用一定的机制进行刷盘到ibd中。</p><p>也就是先刷入日志，在刷脏页，用于确保刷入脏页的时候发生错误能够进行数据恢复。</p></blockquote><p>undo log:<br><code>回滚日志</code>，用于记录数据被<code>修改前的信息</code>，作用包含两个：<code>提供回滚</code>和<code>MVCC（多版本并发控制）</code>。 undo log和redo log记录物理日志不一样，它是<code>逻辑日志</code>。可以认为当delete一条记录，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><blockquote><p>Undo log销毁：undo log在事务执行时产生，<code>事务提交时，并不会立即删除undo log</code>，因为这些日志可能还用于<code>MVCC</code>。 Undo log存储：undo log采用<code>段</code>的方式进行管理和记录，存放在前面介绍的<code>rollback segment回滚段</code>中，内部包含1024个undo log segment。</p></blockquote><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读:"></a>当前读:</h3><p>读取的是<code>记录的最新版本</code>，读取时还要<code>保证其他并发事务不能修改当前记录</code>，会对读取的记录进行加锁。对于我们日常的操作，如：</p><ul><li>select…lock in share mode（共享锁）。</li><li>select..…for update、update、insert、delete（排他锁）都是一种当前读。</li></ul><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读:"></a>快照读:</h3><p>简单的select（<code>不加锁</code>）就是快照读，快照读，读取的是记录数据的<code>可见版本</code>，<code>有可能是历史数据</code>，不加锁，是非阻塞读。比如一个事务内的可重复读。</p><ul><li>Read Committed：<code>每次select</code>，都生成一个快照读。</li><li>Repeatable Read：开启事务后<code>第一个select</code>语句才是快照读的地方。</li><li>Serializable：快照读会<code>退化为当前读</code>。</li></ul><h3 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC:"></a>MVCC:</h3><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h4 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC 实现原理:"></a>MVCC 实现原理:</h4><p>有三个隐藏的字段:</p><p><a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/MVCC.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/MVCC.png" alt="images"></a></p><blockquote><p>undo log回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p></blockquote><p>undo log <code>版本链</code>：</p><p>undo log日志会记录原来的版本的数据，因为是<code>通过undo log 日志进行回滚</code>的。</p><p><a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/MVCCList.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/MVCCList.png" alt="images"></a></p><p>如何<code>确定返回哪一个版本</code> 这是由<code>read view</code>决定返回 undo log 中的哪一个版本。</p><p><a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/readview0.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/readview0.png" alt="images"></a></p><blockquote><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。<br>RR隔离级别下，在事务中第一次执行快照读时生成ReadView，后续会复用。</p></blockquote><blockquote><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145&spm_id_from=pageDriver&vd_source=bbc04b831b54029788a178a7c2e9ae20">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145&amp;spm_id_from=pageDriver&amp;vd_source=bbc04b831b54029788a178a7c2e9ae20</a></p></blockquote><p>MVCC 靠 隐藏字段 , undo log 版本链 , read view 实现的。</p><ul><li>原子性-undo log</li><li>持久性-redo log</li><li>一致性-undo log + redo log</li><li>隔离性-锁 + MVCC</li></ul><p><a href="https://github.com/Buildings-Lei/mysql_note/blob/main/images/readview.png"><img src="https://github.com/Buildings-Lei/mysql_note/raw/main/images/readview.png" alt="images"></a></p><h1 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><table><thead><tr><th align="left">类型名称</th><th align="left">取值范围</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">-128〜127</td><td align="left">1个字节</td></tr><tr><td align="left">SMALLINT</td><td align="left">-32768〜32767</td><td align="left">2个宇节</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">-8388608〜8388607</td><td align="left">3个字节</td></tr><tr><td align="left">INT (INTEGHR)</td><td align="left">-2147483648〜2147483647</td><td align="left">4个字节</td></tr><tr><td align="left">BIGINT</td><td align="left">-9223372036854775808〜9223372036854775807</td><td align="left">8个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><table><thead><tr><th align="left">类型名称</th><th align="left">说明</th><th align="left">存储需求</th></tr></thead><tbody><tr><td align="left">FLOAT</td><td align="left">单精度浮点数</td><td align="left">4 个字节</td></tr><tr><td align="left">DOUBLE</td><td align="left">双精度浮点数</td><td align="left">8 个字节</td></tr><tr><td align="left">DECIMAL (M, D)，DEC</td><td align="left">压缩的“严格”定点数</td><td align="left">M+2 个字节</td></tr></tbody></table><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><table><thead><tr><th align="left">类型名称</th><th align="left">日期格式</th><th align="left">日期范围</th><th align="left">存储需求</th></tr></thead><tbody><tr><td align="left">YEAR</td><td align="left">YYYY</td><td align="left">1901 ~ 2155</td><td align="left">1 个字节</td></tr><tr><td align="left">TIME</td><td align="left">HH:MM:SS</td><td align="left">-838:59:59 ~ 838:59:59</td><td align="left">3 个字节</td></tr><tr><td align="left">DATE</td><td align="left">YYYY-MM-DD</td><td align="left">1000-01-01 ~ 9999-12-3</td><td align="left">3 个字节</td></tr><tr><td align="left">DATETIME</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td align="left">8 个字节</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td align="left">4 个字节</td></tr></tbody></table><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><table><thead><tr><th align="left">类型名称</th><th align="left">说明</th><th align="left">存储需求</th></tr></thead><tbody><tr><td align="left">CHAR(M)</td><td align="left">固定长度非二进制字符串</td><td align="left">M 字节，1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td align="left">VARCHAR(M)</td><td align="left">变长非二进制字符串</td><td align="left">L+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td align="left">TINYTEXT</td><td align="left">非常小的非二进制字符串</td><td align="left">L+1字节，在此，L&lt;2^8</td></tr><tr><td align="left">TEXT</td><td align="left">小的非二进制字符串</td><td align="left">L+2字节，在此，L&lt;2^16</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">中等大小的非二进制字符串</td><td align="left">L+3字节，在此，L&lt;2^24</td></tr><tr><td align="left">LONGTEXT</td><td align="left">大的非二进制字符串</td><td align="left">L+4字节，在此，L&lt;2^32</td></tr><tr><td align="left">ENUM</td><td align="left">枚举类型，只能有一个枚举字符串值</td><td align="left">1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td align="left">SET</td><td align="left">一个设置，字符串对象可以有零个或 多个SET成员</td><td align="left">1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><h2 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h2><table><thead><tr><th align="left">类型名称</th><th align="left">说明</th><th align="left">存储需求</th></tr></thead><tbody><tr><td align="left">BIT(M)</td><td align="left">位字段类型</td><td align="left">大约 (M+7)&#x2F;8 字节</td></tr><tr><td align="left">BINARY(M)</td><td align="left">固定长度二进制字符串</td><td align="left">M 字节</td></tr><tr><td align="left">VARBINARY (M)</td><td align="left">可变长度二进制字符串</td><td align="left">M+1 字节</td></tr><tr><td align="left">TINYBLOB (M)</td><td align="left">非常小的BLOB</td><td align="left">L+1 字节，在此，L&lt;2^8</td></tr><tr><td align="left">BLOB (M)</td><td align="left">小 BLOB</td><td align="left">L+2 字节，在此，L&lt;2^16</td></tr><tr><td align="left">MEDIUMBLOB (M)</td><td align="left">中等大小的BLOB</td><td align="left">L+3 字节，在此，L&lt;2^24</td></tr><tr><td align="left">LONGBLOB (M)</td><td align="left">非常大的BLOB</td><td align="left">L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h1 id="权限一览表"><a href="#权限一览表" class="headerlink" title="权限一览表"></a>权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th align="left">Privilege</th><th align="left">Grant Table Column</th><th align="left">Context</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td align="left">Synonym for “all privileges”</td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td align="left"><code>Alter_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td align="left"><code>Alter_routine_priv</code></td><td align="left">Stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td align="left"><code>Create_priv</code></td><td align="left">Databases, tables, or indexes</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td align="left"><code>Create_role_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td align="left"><code>Create_routine_priv</code></td><td align="left">Stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td align="left"><code>Create_tablespace_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td align="left"><code>Create_tmp_table_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td align="left"><code>Create_user_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td align="left"><code>Create_view_priv</code></td><td align="left">Views</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td align="left"><code>Delete_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td align="left"><code>Drop_priv</code></td><td align="left">Databases, tables, or views</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td align="left"><code>Drop_role_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td align="left"><code>Event_priv</code></td><td align="left">Databases</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td align="left"><code>Execute_priv</code></td><td align="left">Stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td align="left"><code>File_priv</code></td><td align="left">File access on server host</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td align="left"><code>Grant_priv</code></td><td align="left">Databases, tables, or stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td align="left"><code>Index_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td align="left"><code>Insert_priv</code></td><td align="left">Tables or columns</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td align="left"><code>Lock_tables_priv</code></td><td align="left">Databases</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td align="left"><code>Process_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td align="left">See <code>proxies_priv</code> table</td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td align="left"><code>References_priv</code></td><td align="left">Databases or tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td align="left"><code>Reload_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td align="left"><code>Repl_client_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td align="left"><code>Repl_slave_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td align="left"><code>Select_priv</code></td><td align="left">Tables or columns</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td align="left"><code>Show_db_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td align="left"><code>Show_view_priv</code></td><td align="left">Views</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td align="left"><code>Shutdown_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td align="left"><code>Super_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td align="left"><code>Trigger_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td align="left"><code>Update_priv</code></td><td align="left">Tables or columns</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td align="left">Synonym for “no privileges”</td><td align="left">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th align="left">Privilege</th><th align="left">Context</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td align="left">Dual password administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td align="left">Allow queries blocked by audit log filter</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td align="left">Audit log administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td align="left">Authentication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td align="left">Backup administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td align="left">Backup and Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td align="left">Backup and Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td align="left">Clone administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td align="left">Firewall administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td align="left">Firewall administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td align="left">Firewall administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td align="left">Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td align="left">Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td align="left">Redo log archiving administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td align="left">NDB Cluster</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td align="left">Authentication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td align="left"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td align="left">Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td align="left">Resource group administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td align="left">Resource group administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td align="left">Server administration</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/06/25/Redis/"/>
      <url>/2023/06/25/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Key的通用命令"><a href="#Key的通用命令" class="headerlink" title="Key的通用命令"></a>Key的通用命令</h2><p>redis命令不区分大小写，但是key是区分大小写的。没有返回值的命令执行成功会返回1，失败返回0。</p><h4 id="KEYS"><a href="#KEYS" class="headerlink" title="**KEYS ***"></a>**KEYS ***</h4><blockquote><p>查看所有的key，返回值是一个数组</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_205002.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_205002.png" alt="2023-04-05_205002"></a></p><h4 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a><strong>EXISTS</strong></h4><blockquote><p><code>EXISTS key [key ...]</code>：返回给定的key中已存在的个数，一个都不存在返回0。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_204837.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_204837.png" alt="2023-04-05_204837"></a></p><h4 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a><strong>DEL</strong></h4><blockquote><p><code>del key [key ...]</code>：删除给定的key，返回值为删除的个数<code>原子</code>,还有一个unlink也是删除，不过是异步命令</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_205440.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_205440.png" alt="2023-04-05_205440"></a></p><h4 id="EXPIRE"><a href="#EXPIRE" class="headerlink" title="EXPIRE"></a><strong>EXPIRE</strong></h4><blockquote><p><code>expire key second</code>：给key设置一个过期时间second，单位为秒，比如expire name 10，表示name这个键10秒后过期</p></blockquote><h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a><strong>TTL</strong></h4><blockquote><p><code>ttl key</code>：查看key的过期时间，不设置过期时间的话默认是永不过期(返回值-1)，过期则返回-2。time to live的缩写。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_211917.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_211917.png" alt="2023-04-05_211917"></a></p><h4 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a><strong>TYPE</strong></h4><blockquote><p><code>type key</code>：返回key的类型，如果key不存在返回null</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_210006.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_210006.png" alt="2023-04-05_210006"></a></p><h4 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a><strong>DBSIZE</strong></h4><blockquote><p>查看当前数据库有多少个key</p></blockquote><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a><strong>SELECT</strong></h4><blockquote><p><code>select index</code>：切换数据库，redis默认一共16个数据库，对应索引为0~15，默认的数据库是0号库</p></blockquote><h4 id="MOVE"><a href="#MOVE" class="headerlink" title="MOVE"></a><strong>MOVE</strong></h4><blockquote><p><code>move key index</code>：将指定key移入指定数据库中</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_215157.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_215157.png" alt="2023-04-05_215157"></a></p><h4 id="FLUSHDB"><a href="#FLUSHDB" class="headerlink" title="FLUSHDB"></a><strong>FLUSHDB</strong></h4><blockquote><p>清空当前库的key</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushdb# 输入fushdb回车即可清空当前库的所有键，此操作慎用</span><br></pre></td></tr></table></figure><h4 id="FLUSHALL"><a href="#FLUSHALL" class="headerlink" title="FLUSHALL"></a><strong>FLUSHALL</strong></h4><blockquote><p>清空所有库的key</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushall# 输入flushall会清空所有库的键，此操作慎用</span><br></pre></td></tr></table></figure><hr><h4 id="help"><a href="#help" class="headerlink" title="help"></a><strong>help</strong></h4><blockquote><p>help命令可以查看redis命令或数据类型的使用说明，注意该命令要在redis客户端才能使用。</p></blockquote><ul><li>help 命令：查看命令的使用说明</li></ul><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_221342.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_221342.png" alt="2023-04-05_221342"></a></p><ul><li>help @数据类型：查看redis数据类型的使用说明</li></ul><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_221630.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_221630.png" alt="2023-04-05_221630"></a></p><hr><h4 id="CONFIG"><a href="#CONFIG" class="headerlink" title="CONFIG"></a>CONFIG</h4><blockquote><p>查看配置文件指定信息</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG get dir# 查看RDB文件存放目录</span><br><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;/opt/redis-7.0.10&quot;</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get save# 查看RDB触发条件</span><br><span class="line">1) &quot;save&quot;</span><br><span class="line">2) &quot;7 3&quot;</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get appendonly# 查看AOF是否开启</span><br><span class="line">1) &quot;appendonly&quot;</span><br><span class="line">2) &quot;yes&quot;</span><br></pre></td></tr></table></figure><h2 id="Redis十大数据类型"><a href="#Redis十大数据类型" class="headerlink" title="Redis十大数据类型"></a>Redis十大数据类型</h2><p>redis中的数据都是用k-v键值对存储的，所有的key都是String类型，所说的十大&#x3D;&#x3D;数据类型指的是value值的数据类型&#x3D;&#x3D;。</p><p>准确来说这十大数据类型只有&#x3D;&#x3D;六大数据类型&#x3D;&#x3D;，分别是&#x3D;&#x3D;String、List、Hash、Set、Zset、Stream&#x3D;&#x3D;。 其余的四种是对这数据类型封装出来的数据结构，分别是Bitmap(String)、HyperLogLog(String)、Geospatial(Zset)、BitField(String)。</p><hr><h3 id="一-Stirng"><a href="#一-Stirng" class="headerlink" title="一. Stirng"></a>一. Stirng</h3><blockquote><p><strong>字符串</strong></p><p>String类型，也就是字符串类型，是Redis中最简单的存储类型，单key单value结构。 其value是字符串，不过根据字符串的格式不同，又可以分为3类： String：普通字符串 int：整数类型，可以做自增、自减操作 float：浮点类型，可以做自增、自减操作</p><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p></blockquote><hr><p><em><strong>String类型的常用命令：</strong></em></p><h4 id="SET和GET"><a href="#SET和GET" class="headerlink" title="SET和GET"></a><strong>SET和GET</strong></h4><p>**<code>set key value [可选参数]</code>**：添加或者修改一个String类型的键值对</p><p>**<code>get key</code>**：根据key获取String类型的value，不存在返回nil</p><blockquote><p>可选参数：</p><p>EX：以秒为单位设置过期时间</p><p>PX：以毫秒为单位设置过期时间</p><p>EXAT：设置以秒为单位的时间戳为过期时间(使用unix时间戳，有时候可以节约一步换算)</p><p>PXAT：设置以毫秒为单位的时间戳为过期时间</p><p>NX：键<code>不存在</code>的时候添加键值对，存在返回nil</p><p>XX：键<code>存在</code>的时候设置键值，也就是覆盖，不存在返回nil</p><p>GET：返回指定键<code>原本</code>的值，若不存在返回nil</p><p>KEEPTTL：<code>保留</code>键之前的生存时间，即在覆盖键值时过期时间还是之前的过期时间，也就是现在计算的过期时间不变，然后改变设定</p><p>提示：set命令使用EX、PX、NX参数，效果等同于SETEX、SETPX、SETNX。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set name Tom# 设置name=Tom</span><br><span class="line">set name Bob get # 重新设置name值并返回原来的name值</span><br><span class="line">set name Bob ex 20 get # 重新设置name值并设置过期时间20秒，并返回之前的name值 </span><br><span class="line">get name# 获取name的值</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_005049.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_005049.png" alt="2023-04-06_005049"></a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name Marry keepttl<span class="comment"># 表示保持之前的过期时间</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_010246.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_010246.png" alt="2023-04-06_010246"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set name Mike XX# name已存在时才创建(覆盖)</span><br><span class="line">set name Mike NX# name不存在时创建，已存在时不创建</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/image-20230406012146601.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230406012146601.png" alt="image-20230406012146601"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set name Mike EXAT 1680715582# 设置以秒为单位的时间戳的过期时间</span><br><span class="line">set name Mike PXAT 1680715582123# 设置以毫秒为单位的时间戳的过期时间</span><br></pre></td></tr></table></figure><hr><h4 id="MSET和MGET"><a href="#MSET和MGET" class="headerlink" title="MSET和MGET"></a><strong>MSET和MGET</strong></h4><blockquote><p>M是multi的缩写，表示<code>多个</code>的意思。</p></blockquote><p>**<code>mset key value [key value ...]</code>**：批量添加多个String类型的键值对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset name Tom age 18 sex man# 设置name=Tom，age=18，sex=man</span><br></pre></td></tr></table></figure><p>**<code>mget key [key ...]</code>**：批量获取String类型的value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget name age sex# 获取name、age、sex的值</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_222939.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_222939.png" alt="2023-04-05_222939"></a></p><hr><h4 id="INCR、INCRBY"><a href="#INCR、INCRBY" class="headerlink" title="INCR、INCRBY"></a><strong>INCR、INCRBY</strong></h4><blockquote><p>increase的缩写，表示自增</p></blockquote><p>**<code>incr key</code>**：让一个整型的key自增1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set age 20</span><br><span class="line">incr age# 让age自增1</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_224947.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_224947.png" alt="2023-04-05_224947"></a></p><p>**<code>incrby key step</code>**：指定步长step，让一个整型的key自增step</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby age 2# 让age自增2</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_225406.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_225406.png" alt="2023-04-05_225406"></a></p><p>**<code>incrbyfloat key step</code>**：让一个浮点类型的数字指定步长自增（浮点类型只能指定步长自增，incrbyfloat也是用整型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set weight 66.6</span><br><span class="line">INCRBYFLOAT weight 0.2# 让weight自增0.2</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_230537.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_230537.png" alt="2023-04-05_230537"></a></p><ul><li><p><strong>DECR、DECRBY、DECRBYFLOAT</strong></p><p>自减，操作和上述自增一样。</p></li></ul><hr><h4 id="SETNX和SETEX"><a href="#SETNX和SETEX" class="headerlink" title="SETNX和SETEX"></a><strong>SETNX和SETEX</strong></h4><blockquote><p>setnx：已存在就不会改变键的值。NX是not exists的缩写。</p><p>setex：设定键的过期时间。EX是expire的缩写。</p></blockquote><p>**<code>setnx key value</code>**：如果key不存在则创建一个String类型的键值对，如果key存在，则不执行。创建成功返回1，失败返回0。</p><p>**<code>setex key second</code>**：创建一个String类型的键值对，并设置过期时间，second为秒数</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_232643.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_232643.png" alt="2023-04-05_232643"></a></p><hr><h4 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a><strong>MSETNX</strong></h4><p>**<code>msetnx key value [key value ...]</code>**：批量添加多个String类型的键值对。</p><p>当且仅当要创建的所有key都不存在时才创建成功。只要有一个键已存在，则都创建失败。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-05_234446.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-05_234446.png" alt="2023-04-05_234446"></a></p><hr><h4 id="SETRANGE和GETRANGE"><a href="#SETRANGE和GETRANGE" class="headerlink" title="SETRANGE和GETRANGE"></a><strong>SETRANGE和GETRANGE</strong></h4><p>**<code>setrange key offset value</code>**：从指定位置替换值的内容，offset表示偏移量，如果为1表示从第二个字符开始。value为替换的内容。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_000031.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_000031.png" alt="2023-04-06_000031"></a></p><p>**<code>getrange key start end</code>**：获取key值指定范围的内容，start表示开始索引，end表示结束索引。0到-1表示获取全部。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_001053.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_001053.png" alt="2023-04-06_001053"></a></p><hr><h4 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a><strong>STRLEN</strong></h4><p>**<code>strlen key</code>**：获取key值的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen str # 获取str值的长度</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_002335.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_002335.png" alt="2023-04-06_002335"></a></p><hr><h4 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a><strong>APPEND</strong></h4><p>**<code>append key value</code>**：在key值后追加内容value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append str hijklmn# 在str值后追加内容hijklmn</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_002704.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_002704.png" alt="2023-04-06_002704"></a></p><hr><h4 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a>GETSET</h4><p>**<code>getset key value</code>**：设置键值对时先获取原先的key值再设置新的key值，等价于set key get。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_014722.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_014722.png" alt="2023-04-06_014722"></a></p><hr><h4 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a><strong>key的结构</strong></h4><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就冲突了该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求设计。这样我们就可以把不同类型的数据区分开了，从而避免了key的冲突问题。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li>user相关的key：<strong>heima:user:1</strong></li><li>product相关的key：<strong>heima:product:1</strong></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/InWMfeD.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/InWMfeD.png" alt="InWMfeD"></a></p><hr><hr><h3 id="二-List"><a href="#二-List" class="headerlink" title="二. List"></a>二. List</h3><blockquote><p><strong>列表</strong></p><p>Redis的List类型是一个<code>单Key多Value</code>的集合，其value值是有序可重复的。</p><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个<code>双向</code>链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>如果键不存在，创建新的链表；</p><p>如果键已存在，新增内容，可重复；</p><p>如果值全移除，对应的键也就消失了。</p><p>特征与LinkedList类似：①有序 ②可重复 ③插入和删除速度快 ④查询速度一般</p><p>常用来存储一个有序数据，例如朋友圈点赞列表，评论列表等等。</p></blockquote><hr><p><em><strong>List类型常用命令：</strong></em></p><h4 id="LPUSH和RPUSH"><a href="#LPUSH和RPUSH" class="headerlink" title="LPUSH和RPUSH"></a>LPUSH和RPUSH</h4><blockquote><p>向列表头部或尾部插入元素。返回值为执行命令后列表的长度。当key不存在时则创建key。</p></blockquote><p>**<code>LPUSH key element [element ...]</code>**：在列表key左边添加一个或多个元素，也就是在列表的头部添加元素。</p><p>**<code>RPUSH key element [element ...]</code>**：在列表key右边添加一个或多个元素，也就是在列表的尾部添加元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lpush list A B# 创建一个列表，key为list</span><br><span class="line">lpush list C D E# 在列表左边（前面）追加C、D、E三个元素</span><br><span class="line">rpush list X Y Z# 在列表右边（后面）追加X、Y、Z三个元素</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_051330.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_051330.png" alt="2023-04-06_051330"></a></p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_064933.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_064933.png" alt="2023-04-06_064933"></a></p><hr><h4 id="LPUSHX和RPUSHX"><a href="#LPUSHX和RPUSHX" class="headerlink" title="LPUSHX和RPUSHX"></a>LPUSHX和RPUSHX</h4><blockquote><p>仅当列表存在时入栈，返回值为执行命令后列表的长度。</p></blockquote><p>**<code>LPUSHX key vlaue</code>**：将value值插入到列表Key的表头，当且仅当 key存在并且是一个列表。当key不存在，执行失败，返回0。</p><p>**<code>RPUSHX key value</code>**：将值 value插入到列表key的表尾，当且仅当 key存在并且是一个列表。当key不存在，执行失败，返回0。<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_194926.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_194926.png" alt="2023-04-06_194926"></a></p><hr><h4 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h4><p>没有RRANGE。</p><p>**<code>LRANGE key start stop</code>**：返回列表 key中指定区间内的元素，区间以偏移量(索引) <code>start</code> 和 <code>stop</code> 指定。</p><blockquote><p>0表示第一个元素，1表示列表第二个元素；-1表示列表最后一个元素，-2表示列表倒数第二个元素，以此类推。</p><p>如果start的下标比列表最大的下标end(LLEN list减一)还大，那么Lrange返回一个空列表。</p><p>如果stop的下标比end的下标还要大，Redis将stop的值设置为end。<code>0到-1表示列表的所有元素</code>。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_052827.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_052827.png" alt="2023-04-06_052827"></a></p><hr><h4 id="LPOP和RPOP"><a href="#LPOP和RPOP" class="headerlink" title="LPOP和RPOP"></a>LPOP和RPOP</h4><blockquote><p>弹出列表最左端或最右端的元素。</p></blockquote><p>**<code>LPOP key [count]</code>**：移除列表最左侧的元素并返回该元素，没有则返回nil，count为移除的个数。</p><p>**<code>RPOP key [count]</code>**：移除列表最右侧的元素并返回该元素，没有则返回nil，count为移除的个数。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_054714.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_054714.png" alt="2023-04-06_054714"></a></p><hr><h4 id="BLPOP和BRPOP"><a href="#BLPOP和BRPOP" class="headerlink" title="BLPOP和BRPOP"></a>BLPOP和BRPOP</h4><blockquote><p>B是blocking的缩写，表示阻塞的意思。</p><p>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil。</p></blockquote><p>**<code>BLPOP key [key ...] timeout</code>**：移除列表第一个元素并返回该元素，如果列表没有元素会阻塞队列直到等待超时或发现可弹出元素为止</p><p>**<code>BRPOP key [key ...] timeout</code>**：移除列表最后一个元素并返回该元素，如果列表没有元素会阻塞队列直到等待超时或发现可弹出元素为止</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_062102.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_062102.png" alt="2023-04-06_062102"></a></p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_062833.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_062833.png" alt="2023-04-06_062833"></a></p><hr><h4 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a>RPOPLPUSH</h4><p>**<code>RPOPLPUSH source destination</code>**：将列表source中的尾元素弹出插入到列表destination的头部，并返回该元素。</p><blockquote><p>如果source不存在，返回nil。 如果source和destination相同，则列表中的表尾元素被移动到表头，并返回该元素，这种情况可以视为列表的旋转操作。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_204113.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_204113.png" alt="2023-04-06_204113"></a></p><p>Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 LPUSH命令将消息放入队列中，而另一个客户端通过 RPOP或者 BRPOP命令取出队列中等待时间最长的消息。</p><p>上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。</p><p>使用RPOPLPUSH命令(或者它的阻塞版本 BRPOPLPUSH )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 LREM 命令将这个消息从备份表删除。</p><p>最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。</p><hr><h4 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h4><p>**<code>LINDEX key index</code>**：通过索引获取列表元素。</p><p>下标(index)参数 <code>start</code> 和 <code>stop</code> 都以 <code>0</code> 为底，也就是说，以 <code>0</code> 表示列表的第一个元素，以 <code>1</code> 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 <code>-1</code> 表示列表的最后一个元素， <code>-2</code> 表示列表的倒数第二个元素，以此类推。</p><p>如果 <code>index</code> 参数的值不在列表的区间范围内(out of range)，返回 <code>nil</code> 。如果 <code>key</code> 不是列表类型，返回一个错误。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_063939.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_063939.png" alt="2023-04-06_063939"></a></p><hr><h4 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h4><p>**<code>LLEN key</code>**：返回列表key的长度。</p><blockquote><p>如果key不存在，则key被解释为一个空列表，返回0。</p><p>如果key不是一个列表类型返回一个错误。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_200230.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_200230.png" alt="img"></a></p><hr><h4 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a>LREM</h4><blockquote><p>remove的缩写，移除指定元素。</p><p>返回值：被移除元素的数量。不存在的 <code>key</code> 被视作空表(empty list)，所以当 <code>key</code> 不存在时， LREM命令总是返回 0 。</p></blockquote><p>**<code>LREM key count value</code>**：根据count的值，移除列表中与参数value相等的元素。</p><blockquote><p><code>count</code> 的值可以是以下几种：</p><ul><li><code>count &gt; 0</code> : 从表头开始向表尾搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 。</li><li><code>count &lt; 0</code> : 从表尾开始向表头搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 的绝对值。</li><li><code>count = 0</code> : 移除表中所有与 <code>value</code> 相等的值。</li></ul></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_205240.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_205240.png" alt="2023-04-06_205240"></a></p><hr><h4 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h4><blockquote><p>对一个列表进行修剪(trim)，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p></blockquote><p>**<code>LTRIM key start stop</code>**：让列表key只保留<code>start</code>-<code>stop</code>区间的元素。成功返回ok，若key不是列表类型返回错误。</p><blockquote><p>下标(index)参数 <code>start</code> 和 <code>stop</code> 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_210818.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_210818.png" alt="2023-04-06_210818"></a></p><hr><h4 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h4><p>**<code>LSET key index value</code>**：将列表key下标为index的元素的值设置为value。操作成功返回ok。</p><blockquote><p>当index参数超出范围，或对一个空列表(key不存在)进行LSET时，返回一个错误。关于更多的下标信息，参考LINDEX。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_212624.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_212624.png" alt="2023-04-06_212624"></a></p><hr><h4 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a>LINSERT</h4><p>**<code>LINSERT key BEFORE|AFTER element value</code>**：将值value插入到列表key中element元素之前或之后。</p><blockquote><p>当<code>element</code>不存在列表<code>key</code>中时，不执行任何操作。当<code>key</code>不存在时，也不执行任何操作。若<code>key</code>不是列表类型，返回一个错误。</p><p>返回值： 如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到 <code>element</code> ，返回 <code>-1</code> 。 如果 <code>key</code> 不存在或为空列表，返回 <code>0</code> 。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-06_214201.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-06_214201.png" alt="2023-04-06_214201"></a></p><hr><hr><h3 id="三-Hash"><a href="#三-Hash" class="headerlink" title="三. Hash"></a>三. Hash</h3><blockquote><p><strong>哈希表</strong></p><p>hash类型，也叫做散列。其value是一个无序字典，类似于java中的HashMap结构。</p><p>K-V模式不变，但v又是一个键值对：Map&lt;key,Map&lt;key,value&gt;&gt;</p></blockquote><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/1652941995945.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/1652941995945.png" alt="img"></a></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD，下面是两个哈希表：</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/1652942027719.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/1652942027719.png" alt="img"></a></p><hr><p><em><strong>Hash类型的常用命令：</strong></em></p><h4 id="HSET和HGET"><a href="#HSET和HGET" class="headerlink" title="HSET和HGET"></a>HSET和HGET</h4><p>**<code>HSET key field value [field value ...]</code>**：将hash表key中的域field的值设置为value，支持同时设置多个域-值对。</p><blockquote><p>如果key不存在，一个新的hash表被创建并执行HSET操作。 如果域field不存在，表示新增<code>field-value</code>(域值对)，如果域field已经存在哈希表key中，其旧值将被覆盖。</p><p>返回值： 如果 field 是哈希表中的一个<code>新建域</code>，并且值设置成功，返回 1 。多个则返回对应的个数。 如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_013020.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_013020.png" alt="img"></a></p><p>**<code>HGET key field </code>**：根据给定域field返回对应的value值。当key不存在或者field不存在，返回nil。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_001928.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_001928.png" alt="2023-04-07_001928"></a></p><hr><h4 id="HMSET和HMGET"><a href="#HMSET和HMGET" class="headerlink" title="HMSET和HMGET"></a>HMSET和HMGET</h4><p>**<code>HMSET key field value [field value ...]</code>**：同时将多个<code>field-value</code>（域-值对）设置到哈希表key中。</p><blockquote><p>此命令会覆盖哈希表中已存在的域，如果key不存在，一个空的哈希表被创建并执行HMSET操作。</p><p>返回值：执行成功返回ok；若key不是hash类型，返回一个错误。</p><p>HSET在Redis版本迭代后也支持同时设置多个值到哈希表中，与HMSET操作完全相同，HMSET今后可能被淘汰。</p></blockquote><p>**<code>HMGET key field [field ...]</code>**：返回哈希表key中一个或多个给定的域值。</p><blockquote><p>如果给定的域不存在于哈希表，那么返回一个 <code>nil</code> 值。key不存在时也返回一个<code>nil</code>值。key不是Hash类型时报错。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_013751.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_013751.png" alt="img"></a></p><hr><h4 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h4><p>**<code>HGETALL key</code>**：返回哈希表key中所有的<code>field</code>和<code>value</code> 。</p><blockquote><p>在返回值里，紧跟着域名后的是域的值，所以返回值的长度是哈希表大小的两倍。</p><p>返回值：以列表形式返回哈希表的域和值，若key不存在，返回空列表。若key不是hash类型则报错。</p><p>若在Redis客户端这样显示的数据就是列表： 1）”AA” 2）”BB” 3）”CC” …</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_005809.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_005809.png" alt="2023-04-07_005809"></a></p><hr><h4 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h4><p>**<code>HDEL key field [field ...]</code>**：删除哈希表 <code>key</code> 中的一个或多个指定域，不存在的域将被忽略。</p><blockquote><p>返回值：被成功移除的域的数量，不包括被忽略的域。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_014536.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_014536.png" alt="img"></a></p><hr><h4 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h4><p>**<code>HLEN key</code>**：返回哈希表 <code>key</code> 中域的数量。</p><blockquote><p>返回值：返回哈希表中域的数量，当key不存在时返回0，若key不是hash类型则报错。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_014841.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_014841.png" alt="img"></a></p><hr><h4 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h4><p>**<code>HEXISTS key field</code>**：查看哈希表key中，给定域field是否存在。</p><blockquote><p>如果哈希表中存在给定域，返回 <code>1</code> 。 如果哈希表中不存在给定域，或 <code>key</code> 不存在，返回 <code>0</code> 。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_015539.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_015539.png" alt="2023-04-07_015539"></a></p><hr><h4 id="HKEYS和HVALS"><a href="#HKEYS和HVALS" class="headerlink" title="HKEYS和HVALS"></a>HKEYS和HVALS</h4><p>**<code>HKEYS key</code>**：获取哈希表key中所有的<code>field</code></p><blockquote><p>返回值：返回哈希表中所有field的<code>数组</code>，若key不存在返回一个空数组。若key不是hash类型返回错误。</p></blockquote><p>**<code>HVALS key</code>**：获取哈希表key中所有field对应的<code>value</code>值。</p><blockquote><p>返回值：返回哈希表中所有field对应的value的<code>数组</code>，若key不存在返回一个空数组。若key不是hash类型返回错误。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_015823.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_015823.png" alt="2023-04-07_015823"></a></p><hr><h4 id="HINCR、HINCRBYFLOAT"><a href="#HINCR、HINCRBYFLOAT" class="headerlink" title="HINCR、HINCRBYFLOAT"></a>HINCR、HINCRBYFLOAT</h4><p>**<code>HINCRBY key field increment</code>**：为哈希表 <code>key</code> 中的域 <code>field</code> 的值加上增量 <code>increment</code> 。只适用整型字符串</p><p>**<code>HINCRBYFLOAT key field increment</code>**：为哈希表 <code>key</code> 中的域 <code>field</code> 加上浮点数增量 <code>increment</code> 。只适用浮点型字符串</p><blockquote><p>增量也可以为负数，相当于对给定域进行减法操作。</p><p>如果哈希表 <code>key</code> 不存在，那么会先创建一个哈希表，再创建域 <code>field</code> ，最后再执行<code>HINCRBY</code> 或 <code>HINCRBYFLOAT</code>操作。</p><p>如果域 <code>field</code> 不存在，那么在执行命令前，域的值被初始化为 <code>0</code> ，然后后执行<code>HINCRBY</code> 或 <code>HINCRBYFLOAT</code>操作。</p><p>对一个储存<code>非整型字符串</code>的域 field 执行 <code>HINCRBY</code> 命令将造成一个错误。</p><p>对一个储存<code>非数值型字符串</code>的域 field 执行 <code>HINCRBYFLOAT</code> 命令将造成一个错误。</p><p>本操作的值被限制在 64 位(bit)有符号数字表示之内。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_024911.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_024911.png" alt="img"></a></p><hr><h4 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h4><p>**<code>HSETNX key field value</code>**：向哈希表key中添加<code>field-value</code>，当且仅当域field不存在。</p><blockquote><p>若field已存在，则该操作无效；若key不存在，则创建该哈希表并执行HSETNX操作。</p><p>返回值：添加成功，返回1；如果给定域已经存在返回 0 。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_030549.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_030549.png" alt="2023-04-07_030549"></a></p><hr><hr><h3 id="四-Set"><a href="#四-Set" class="headerlink" title="四. Set"></a>四. Set</h3><blockquote><p><strong>集合</strong></p><p>Redis的Set类型是一个和List一样的单key多value的集合，与List不同的是Set的value是无序且不可重复的。</p><p>Redis的set相当于Java语言里面的HashSet，它内部键值对是无序的、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值NULL，可以看做是一个value为null的HashMap。</p><p>具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><p><em>应用场景</em>： 微信抽奖小程序。（SRANDMEMBER） 微信朋友圈共友点赞。（SINTER） QQ推荐可能认识的人。（SDIFF）</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_043514.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_043514.png" alt="2023-04-07_043514"></a></p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_040923.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_040923.png" alt="img"></a></p><hr><p><em><strong>Set类型的常用命令：</strong></em></p><h4 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h4><p>**<code>SADD key member [member ...]</code>**：将一个或多个 <code>member</code> 元素加入到set集合 <code>key</code> 当中，已经存在于集合的 <code>member</code> 元素将被忽略。</p><blockquote><p>假如 <code>key</code> 不存在，则创建一个只包含 <code>member</code> 元素作成员的集合。</p><p>当 <code>key</code> 不是Set集合类型时，返回一个错误。</p><p><strong>返回值</strong>：被添加到集合中的新元素的数量，不包括被忽略的元素。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_052026.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_052026.png" alt="2023-04-07_052026"></a></p><hr><h4 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h4><p>**<code>SMEMBERS key</code>**：返回集合<code>key</code>中所有的成员。</p><blockquote><p>若key不存在，返回空数组；若key不是Set集合，返回错误。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_053352.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_053352.png" alt="2023-04-07_053352"></a></p><hr><h4 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h4><blockquote><p>S表示Set集合，ISMEMBER表示is member？</p></blockquote><p><strong>SISMEMBER key member</strong>：判断 <code>member</code> 元素是否是集合 <code>key</code> 的成员。</p><blockquote><p>如果 <code>member</code> 元素是集合的成员，返回 <code>1</code> 。</p><p>如果 <code>member</code> 元素不是集合的成员，或 <code>key</code> 不存在，返回 <code>0</code> 。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_095412.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_095412.png" alt="2023-04-07_095412"></a></p><hr><h4 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h4><p>**<code>SCARD key</code>**：返回集合key中成员的个数。当key不存在时，返回0。若key不是Set集合类型，返回错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCARD course# 获取集合course中元素的个数</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><hr><h4 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h4><p>**<code>SREM key member [member ...]</code>**：移除集合key中的一个或多个member元素并返回移除的个数，不存在的member元素会被忽略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SREM course C++# 移除C++</span><br><span class="line">(integer) 1# 成功移除一个</span><br></pre></td></tr></table></figure><hr><h4 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h4><p>**<code>SRANDMEMBER key [count]</code>**：随机返回集合中一个[或多个]元素。仅仅返回随机元素，而不对集合进行任何改动。</p><blockquote><p>SRANDMEMBER命令可选的 <code>count</code> 参数：</p><ul><li>如果 <code>count</code> 为正数，且小于集合基数，那么命令返回一个包含 <code>count</code> 个元素的数组，数组中的元素<strong>各不相同</strong>。 如果 <code>count</code> 大于等于集合基数，那么返回整个集合。</li><li>如果 <code>count</code> 为负数，那么命令返回一个数组，数组中的元素<strong>可能会重复出现多次</strong>，而数组的长度为 <code>count</code> 的绝对值。</li></ul><p>返回值: 只提供 <code>key</code> 参数时，返回一个元素；如果集合为空，返回 <code>nil</code> 。 如果提供了 <code>count</code> 参数，那么返回一个数组；如果集合为空，返回空数组。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_113723.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_113723.png" alt="img"></a></p><hr><h4 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h4><p><strong><code>SPOP key [count] </code></strong> ：移除并返回集合中的一个[或多个]随机元素。</p><blockquote><p>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER命令。</p><p>返回值：被移除的随机元素。当 <code>key</code> 不存在或 <code>key</code> 是空集时，返回 <code>nil</code> 。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-07_215248.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-07_215248.png" alt="2023-04-07_215248"></a></p><hr><h4 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h4><p>**<code>SMOVE source destination member</code>**：将 <code>member</code> 元素从 <code>source</code> 集合移动到 <code>destination</code> 集合。</p><blockquote><p>SMOVE是原子性操作。</p><p>如果 <code>source</code> 集合不存在或不包含指定的 <code>member</code> 元素，则 SMOVE 命令不执行任何操作，仅返回 <code>0</code> 。</p><p>当 <code>destination</code> 集合已经包含 <code>member</code> 元素时， SMOVE 命令只是简单地将 <code>source</code> 集合中的 <code>member</code> 元素删除。</p><p>当 <code>source</code> 或 <code>destination</code> 不是集合类型时，返回一个错误。</p><p><strong>返回值:</strong></p><p>如果 <code>member</code> 元素被成功移除，返回 <code>1</code> 。</p><p>如果 <code>member</code> 元素不是 <code>source</code> 集合的成员，并且没有任何操作对 <code>destination</code> 集合执行，那么返回 <code>0</code> 。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers course# 集合course有三个成员</span><br><span class="line">1) &quot;Go&quot;</span><br><span class="line">2) &quot;Python&quot;</span><br><span class="line">3) &quot;Java&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers subject# 集合subject有四个成员</span><br><span class="line">1) &quot;Chinese&quot;</span><br><span class="line">2) &quot;Physics&quot;</span><br><span class="line">3) &quot;English&quot;</span><br><span class="line">4) &quot;Math&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMOVE subject course Physics# 将集合subject的成员Physics移动到集合course中</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS course# 集合course中新增成员Physics</span><br><span class="line">1) &quot;Physics&quot;</span><br><span class="line">2) &quot;Go&quot;</span><br><span class="line">3) &quot;Python&quot;</span><br><span class="line">4) &quot;Java&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS subject# 集合subject中少了一个成员</span><br><span class="line">1) &quot;Chinese&quot;</span><br><span class="line">2) &quot;English&quot;</span><br><span class="line">3) &quot;Math&quot;</span><br><span class="line">127.0.0.1:6379&gt; SADD subject Go# 新增成员Go到集合subject</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMOVE subject course Go# 移动成员Go从subject到course(Go在两个集合中都存在)</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS subject# 自身减少了一个成员</span><br><span class="line">1) &quot;Chinese&quot;</span><br><span class="line">2) &quot;English&quot;</span><br><span class="line">3) &quot;Math&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS course# course本身就已有Go成员，所以不执行任何操作(也可以理解为覆盖了)</span><br><span class="line">1) &quot;Physics&quot;</span><br><span class="line">2) &quot;Go&quot;</span><br><span class="line">3) &quot;Python&quot;</span><br><span class="line">4) &quot;Java&quot;</span><br></pre></td></tr></table></figure><hr><h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><h5 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a>SDIFF</h5><p>**<code>SDIFF key key2 ...</code>**：返回给定集合的差集。</p><blockquote><p>sdiff A B：返回属于集合A但不属于集合B的元素 sdiff B A：返回属于集合B但不属于集合A的元素</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_005458.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_005458.png" alt="2023-04-08_005458"></a></p><h5 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h5><p>**<code>SUNION key [key ...]</code>**：返回给定集合的并集。</p><blockquote><p>比如<code>sunion A B</code>表示返回集合A和集合B的所有元素，公共的只取一份。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_010353.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_010353.png" alt="2023-04-08_010353"></a></p><h5 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a>SINTER</h5><p>**<code>SINTER key [key ...]</code>**：返回给定集合的交集。</p><blockquote><p>比如<code>sinter A B</code>表示即返回集合A和集合B共有的元素。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_010905.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_010905.png" alt="2023-04-08_010905"></a></p><p><strong><code>SINTERCARD numkeys key [key ...] [LIMIT limit]</code></strong> ：返回给定集合交集的个数。</p><blockquote><p>numkeys为key的个数。</p><p>LIMIT为限制返回的个数的最大值，比如交集个数有10个，但是LIMIT为5，则返回5。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_012107.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_012107.png" alt="2023-04-08_012107"></a></p><hr><hr><h3 id="五-SortedSet"><a href="#五-SortedSet" class="headerlink" title="五. SortedSet"></a>五. SortedSet</h3><blockquote><p><strong>有序集合</strong></p><p>SortedSet也叫<code>ZSet</code>。在Set的基础上，每个member前面加个score属性。</p><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。</p><p>SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>score的值是一个<em>整型数值或者浮点数值</em> 的数，是可重复的。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。比如商品销售排行榜。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_040833.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_040833.png" alt="img"></a></p><hr><p><em><strong>Zset类型的常用命令：</strong></em></p><h4 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h4><p>**<code>ZADD key score member [[score member] [score member] ...]</code>**：将一个或多个元素及其<code>score</code>值添加到有序集合<code>key</code>中。</p><blockquote><p>如果某个 <code>member</code> 已经是有序集的成员，那么更新这个 <code>member</code> 的 <code>score</code> 值，并通过重新插入这个 <code>member</code> 元素，来保证该 <code>member</code> 在正确的位置上。</p><p><code>score</code>是一个用于排序的属性，它的值是整数值或双精度浮点数，<code>score</code>写在<code>member</code>的前面。</p><p>如果 <code>key</code> 不存在，则创建一个空的有序集并执行 <code>ZADD</code> 操作。当 <code>key</code> 存在但不是有序集类型时，返回一个错误。</p><p>当然还可以加其他参数比如<code>NX</code>、<code>XX</code>、<code>INCR</code>等等，对有序集的更多介绍参见 <a href="http://redis.io/topics/data-types#sorted-sets">sorted set</a> 。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD userZset 10 Alice 20 Bob 30 Cindy 40 Davie# 添加四个成员</span><br><span class="line">(integer) 4# 返回添加成功的个数</span><br></pre></td></tr></table></figure><hr><h4 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h4><p>**<code>ZCARD key </code>**：返回有序集 <code>key</code> 中成员的个数。当key不存在时返回0，若key不是有序集类型，返回错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZCARD userZset# 获取有序集userZset中成员的个数</span><br><span class="line">(integer) 4# 四个</span><br></pre></td></tr></table></figure><hr><h4 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h4><p>**<code>ZCOUNT key min max</code>**：返回有序集 <code>key</code> 中， <code>score</code> 值在 <code>min</code> 和 <code>max</code> 之间(默认包括 <code>score</code> 值等于 <code>min</code> 或 <code>max</code> )的成员的数量。</p><blockquote><p>默认情况下，区间的取值使用闭区间(小于等于或大于等于)，也可以通过给参数前增加 <code>(</code> 符号将其改变为开区间。 比如 <code>(1 5</code> 表示 1&lt;score&lt;&#x3D;5，<code>(1 (5</code> 表示 1&lt;score&lt;5。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_191915.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_191915.png" alt="2023-04-08_191915"></a></p><hr><h4 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h4><p>**<code>ZSOCRE key member</code>**：返回有序集 <code>key </code>中指定成员 <code>member</code> 的 <code>score</code> 值。</p><blockquote><p>如果 <code>member</code> 元素不是有序集 <code>key</code> 的成员，或 <code>key</code> 不存在，返回 <code>nil</code> 。</p><p>返回值：<code>member</code> 成员的 <code>score</code> 值，以字符串形式表示。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_180150.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_180150.png" alt="2023-04-08_180150"></a></p><hr><h4 id="ZRANGE和ZREVRANGE"><a href="#ZRANGE和ZREVRANGE" class="headerlink" title="ZRANGE和ZREVRANGE"></a>ZRANGE和ZREVRANGE</h4><p>**<code>ZRANGE key start stop [WITHSCORES]</code>*<em>：返回有序集合key中指定区间的成员。</em>从小到大排序*</p><blockquote><p>其中成员的位置是按score值从小到大排序，具有相同score的车成员按字典序来排列。区间(下标参数)这里不再赘述。</p><p><code>WITHSCORES</code> 选项，表示让成员和它的 <code>score</code> 值一并返回，返回列表以 <code>member1,score1, ..., memberN,scoreN</code> 的格式表示。 可能会返回一些更复杂的数据类型，比如数组、元组等。</p><p>如果需要按score值从大到小排序，可以适用<code>ZREVRANGE</code>命令。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_044438.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_044438.png" alt="2023-04-08_044438"></a></p><p>**<code>ZREVRANGE key start stop [WITHSCORES]</code>*<em>：返回有序集合key中指定区间的成员。</em>从大到小排序*</p><blockquote><p>成员的位置是按照<code>score</code>值从大到小排序，其余都和<code>ZRANGE</code>一样。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_045728.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_045728.png" alt="2023-04-08_045728"></a></p><hr><h4 id="ZRANGEBYSCORE和ZREVRANGEBYSCORE"><a href="#ZRANGEBYSCORE和ZREVRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE和ZREVRANGEBYSCORE"></a>ZRANGEBYSCORE和ZREVRANGEBYSCORE</h4><p>**<code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code>*<em>：返回有序集 <code>key</code> 中所有 <code>score</code> 值介于 <code>min</code> 和 <code>max</code> 之间(包括等于 <code>min</code> 或 <code>max</code> )的成员。按score值</em>从小到大排序*</p><blockquote><p>默认情况下，区间的取值使用闭区间(小于等于或大于等于)，也可以通过给参数前增加 <code>(</code> 符号来使用可选的开区间(小于或大于)。 比如 <code>(1 5</code> 表示 1&lt;score&lt;&#x3D;5，<code>(1 (5</code> 表示 1&lt;score&lt;5。</p><p><code>LIMIT</code> 参数限制返回结果的区间(就像SQL中的 <code>SELECT ... LIMIT offset, count</code> )，offset为下标偏移量，count为个数。</p><p><code>WITHSCORES</code> 表示将有序集成员及其 <code>score</code> 值一起返回。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_185848.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_185848.png" alt="2023-04-08_185848"></a></p><p>**<code>ZREVRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code>*<em>：返回有序集 <code>key</code> 中所有 <code>score</code> 值介于 <code>min</code> 和 <code>max</code> 之间(包括等于 <code>min</code> 或 <code>max</code> )的成员。按score值</em>从大到小排序*，其余参考ZRANGEBYSCORE。</p><hr><h4 id="ZRANK和ZREVRANK"><a href="#ZRANK和ZREVRANK" class="headerlink" title="ZRANK和ZREVRANK"></a>ZRANK和ZREVRANK</h4><p>**<code>ZRANK key member</code>*<em>：返回有序集 <code>key</code> 中指定成员 <code>member</code> 的排名。</em>从小到大*</p><blockquote><p>排名按 <code>score</code> 值递增(从小到大)顺序排列。排名以 <code>0</code> 为底，也就是说<code>score</code> 值最小的成员排名为 <code>0</code> 。</p><p>使用 <code>ZREVRANK</code> 命令可以获得成员按 <code>score</code> 值递减(从大到小)排列的排名。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_181243.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_181243.png" alt="img"></a></p><p>**<code>ZREVRANK key member</code>*<em>：返回有序集 <code>key</code> 中指定成员 <code>member</code> 的排名。</em>从大到小*</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_181658.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_181658.png" alt="2023-04-08_181658"></a></p><hr><h4 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h4><p>**<code>ZREM key member [member ...]</code>**：移除有序集key中一个或多个成员，不存在的成员将被忽略。</p><blockquote><p>当key不存在时返回0；当key存在但不是有序集时返回一个错误。</p><p>移除成功返回移除成员的数量。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD testZset 10 A 20 B 30 C 40 D 50 E</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; ZREM testZset C D E# 移除三个成员</span><br><span class="line">(integer) 3# 移除成功返回3</span><br></pre></td></tr></table></figure><hr><h4 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h4><p>**<code>ZINCRBY key increment member</code>**：为有序集 <code>key</code> 的成员 <code>member</code> 的 <code>score</code> 值加上增量 <code>increment</code></p><blockquote><p>可以通过传递一个负数值 ，让 <code>score</code> 减去相应的值，比如 <code>ZINCRBY key -5 member</code> ，就是让 <code>member</code> 的 <code>score</code> 值减去 <code>5</code> 。</p><p><strong>返回值</strong>：返回<code>member</code> 成员的新 <code>score</code> 值，以字符串形式表示。 当 <code>key</code> 不是有序集类型时，返回一个错误。 当 <code>key</code> 不存在，或 <code>member</code> 不是 <code>key</code> 的成员时， <code>ZINCRBY key increment member</code> 等同于 <code>ZADD key increment member</code> 。</p><p><code>score</code> 值可以是整数值或双精度浮点数。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/image-20230408193813874.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230408193813874.png" alt="image-20230408193813874"></a></p><hr><h4 id="ZPOPMAX和ZPOPMIN"><a href="#ZPOPMAX和ZPOPMIN" class="headerlink" title="ZPOPMAX和ZPOPMIN"></a>ZPOPMAX和ZPOPMIN</h4><p>**<code>ZPOPMAX key [count]</code>**：删除并返回有序集<code>key</code>中<code>score</code>值最大的一个[或多个]成员。</p><p>**<code>ZPOPMIN key [count]</code>**：删除并返回有序集<code>key</code>中<code>score</code>值最小的一个[或多个]成员。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_200015.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_200015.png" alt="2023-04-08_200015"></a></p><hr><h4 id="ZMPOP"><a href="#ZMPOP" class="headerlink" title="ZMPOP"></a>ZMPOP</h4><p>**<code>ZMPOP numkeys key [key ...] &lt;MIN | MAX&gt; [COUNT count] </code>**：从所提供的键名列表中的第一个非空排序集中弹出一个[或多个]元素，这些元素是成员分数对。</p><blockquote><p>这个指令就是ZPOPMAX和ZPOPMIN的升级版，可以对多个有序集合进行操作。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_202047.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_202047.png" alt="2023-04-08_202047"></a></p><hr><h4 id="集合运算-1"><a href="#集合运算-1" class="headerlink" title="集合运算"></a>集合运算</h4><p>集合运算参考Set的集合运算，这里不再赘述。</p><blockquote><p>ZDIFF：求差集 ZINTER：求交集 ZUNION：求并集</p></blockquote><hr><hr><h3 id="六-Bitmap"><a href="#六-Bitmap" class="headerlink" title="六. Bitmap"></a>六. Bitmap</h3><blockquote><p><strong>位图</strong></p><p>用String类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>位图本质是数组，该数组由多个二进制位组成，其值只能是1或0，默认0，每个二进制位都对应一个偏移量(我们称之为一个索引)。</p><p>Bitmap支持的最大位数是2^32位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息。 (512<em>1024</em>1024<em>8&#x3D;2^9</em>2^10<em>2^10</em>2^3&#x3D;2^32)</p><p>一个字节占有8位，若在一个bitmap类型的key中，偏移量(索引)为8的位置存入1，前面7位会默认设置为0，那么该key占用两个字节，因为偏移量为8的那一位属于第二个字节了。</p><p><em>&#x3D;&#x3D;应用&#x3D;&#x3D;</em> ：由于offset值得范围是[0,2^32-1]，这个数非常大，可以将用户id和偏移量形成映射关系来存储很多二值数据： 通常先将用户存储到哈希表中，通过field值来标识每一位用户，然后再将field值和偏移量形成映射关系，比如 <code>HSET user 1 uid1001 2 uid1002</code> ：1代表uid1001，2代表uid1002 <code>SETBIT sign:Monday 1 1</code> 偏移量1的位置值为1，偏移量1对应用户uid1001（1表示已签到，0表示未签到） <code>SETBIT sign:Monday 2 1</code> 偏移量2的位置值为1，偏移量2对应用户uid1002 …… <code>SETBIT sign:Monday n 1</code> 再通过<code>BITCOUNT sign:Monday</code>就很容易获取Monday签到的用户数量了。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-08_232347.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-08_232347.png" alt="2023-04-08_232347"></a></p><hr><p><em><strong>Bitmap结构的常用命令：</strong></em></p><h4 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h4><p>**<code>SETBIT key offset value</code>**：设置key的value(字符串)在offset处的bit值。</p><blockquote><p>offset：偏移量，从0开始，最大值2^32-1 </p><p>返回值：<code>在offset处原来的bit值。</code></p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-09_000056.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-09_000056.png" alt="2023-04-09_000056"></a></p><hr><h4 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h4><p>**<code>GETBIT key offset</code>**：返回key对应的value在offset处的bit值。</p><blockquote><p>当offset超出了字符串长度的时候，超出的部分就被假定为由0比特填充的连续空间。 当key不存在的时候，它就认为是一个空字符串，所以offset总是超出范围，然后value也被认为是由0比特填充的连续空间。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETBIT mybit 2# 获取offset为2的值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GETBIT mybit 100# 获取offset为100的值，100已经超出了该字符串的长度，默认超出的比特位都是0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; STRLEN mybit# 获取mybit的长度(占用字节数)，因为只存储5位，不够一个字节，所以占用一个字节</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SETBIT mybit 5 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT mybit 6 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT mybit 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT mybit 8 1# 偏移量8，属于第二个字节了，所以mybit的长度为2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; STRLEN mybit</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><hr><h4 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h4><p>**<code>BITCOUNT key [start end [byte|bit]]</code>**：统计value中比特位为1的个数。</p><blockquote><p>可以指定特定的比特位区间或字节区间，只统计该区间上比特位为1的个数。 byte表示一个字节为一个偏移量，bit表示一个位为一个偏移量。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BITCOUNT mybit# 统计整个字符串value中比特位为1的个数</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT mybit 3 6 bit# 统计比特位区间[3,6]中比特位为1的个数</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT mybit 1 -1 byte# 统计第二个字节及以后的字节中比特位为1的个数</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><hr><h4 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h4><p>**<code>BITOP operation destkey key [key ...]</code>**：对一个或多个保存二进制位的字符串key进行位运算，并将结果保存到destkey中。</p><blockquote><p>operation有四种操作：AND、OR、NOT、XOR</p><ul><li><code>BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN</code> ：对一个或多个 key 求按位与（同一列都为1则为1）</li><li><code>BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN</code>：对一个或多个 key 求按位或（同一列有一个1即为1）</li><li><code>BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN</code>：对一个或多个 key 求按位异或（不同则为1）</li><li><code>BITOP NOT destkey srckey</code>：对给定 key 求按位取反（1变0，0变1）</li></ul><p>返回值：保存到destkey的字符串的长度（多少字节）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 设置一个bitmap类型的bitmap1，存储1 0 1 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap1 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap1 1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap1 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap1 3 0</span><br><span class="line">(integer) 0</span><br><span class="line"># 设置一个bitmap类型的bitmap2，存储1 0 1 1</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap2 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap2 1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap2 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT bitmap2 3 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"># 将这两个key做按位与运算，并将结果存到bitmap12中</span><br><span class="line">127.0.0.1:6379&gt; BITOP and bitmap12 bitmap1 bitmap2</span><br><span class="line">(integer) 1# 返回bitmap12的长度，1个字节</span><br><span class="line"># 获取bitmap12的值</span><br><span class="line">127.0.0.1:6379&gt; GETBIT bitmap12 0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GETBIT bitmap12 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; GETBIT bitmap12 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GETBIT bitmap12 3</span><br><span class="line">(integer) 0</span><br><span class="line">可以看到得出的数是1 0 1 0</span><br><span class="line"></span><br><span class="line"># 将bitmap1做按位取反运算</span><br><span class="line">127.0.0.1:6379&gt; BITOP not destkey1 bitmap1</span><br><span class="line">(integer) 1</span><br><span class="line"># 获取destkey1的值</span><br><span class="line">127.0.0.1:6379&gt; GETBIT destkey1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; GETBIT destkey1 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GETBIT destkey1 2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; GETBIT destkey1 3</span><br><span class="line">(integer) 1</span><br><span class="line">可以看到取反后的数为0 1 0 1</span><br></pre></td></tr></table></figure><hr><hr><h3 id="七-HyperLogLog"><a href="#七-HyperLogLog" class="headerlink" title="七. HyperLogLog"></a>七. HyperLogLog</h3><blockquote><p><strong>基数统计</strong></p><p>HyperLogLog是一种<code>概率</code>数据结构，用于计数唯一的事物(技术上这是指估计一个集合的基数)。 (基数就是一个数据集中<code>去除重复数据后总的个数</code>)</p><p>HyperLogLog的数据类型还是String。在Redis中的HyperLogLog，虽然技术上是不同的数据结构，但被编码为Redis字符串。</p><p>在Redis里面每个HyperLogLog键只需要花费12kb内存就可以统计接近2^64个不同元素的基数。</p><p>HyperLogLog只会根据输入的元素来计算奇数，不会存储输入的元素本身，所以HyperLogLog不能像集合那样返回输入的元素。</p></blockquote><hr><p><em><strong>HyperLogLog结构的常用命令：</strong></em></p><h4 id="PFADD"><a href="#PFADD" class="headerlink" title="PFADD"></a>PFADD</h4><p>**<code>PFADD key element [element ...]</code>**：将元素element添加到HyperLogLog结构的key中。</p><blockquote><p>如果 HyperLogLog 的内部被修改了,那么返回 1,否则返回 0 。</p><p>如果在调用该命令时仅提供变量名而不指定元素也是可以的，如果这个变量名存在，则不会有任何操作。如果不存在，则会创建一个数据结构（返回1）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD hll a b c c d d f f g g# 添加10个元素</span><br><span class="line">(integer) 1# 添加了10个元素，返回1</span><br><span class="line">127.0.0.1:6379&gt; PFADD hll a b c c d d f f g g# 重复添加，HLL内部没有改变，返回0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><hr><h4 id="PFCOUNT"><a href="#PFCOUNT" class="headerlink" title="PFCOUNT"></a>PFCOUNT</h4><p>**<code>PFCOUNT key [key ...]</code>**：返回给定HyperLogLog结构的key的基数。</p><blockquote><p>当参数为一个key时，返回存储在HyperLogLog结构体的该key的近似基数，如果该变量不存在，则返回0。</p><p>当参数为多个key时，返回这些HyperLogLog并集的近似基数，这个值是将所给定的所有key的HyperLoglog结构合并到一个临时的HyperLogLog结构中计算而得到的。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD hll a b c c d d f f g g</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT hll# 统计hll的基数（去重统计）</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><hr><h4 id="PFMERGE"><a href="#PFMERGE" class="headerlink" title="PFMERGE"></a>PFMERGE</h4><p>**<code>PFMERGE destkey [sourcekey [sourcekey ...]]</code>**：将多个HyperLogLog合并成一个HyperLogLog。</p><blockquote><p>destkey是合并后的HyperLogLog结构。</p><p>这个命令可以用PFCOUNT命令实现。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD hll1 a a b b c c d e f# 创建一个HyperLogLog结构的hll1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFADD hll2 d e f g g h h i i# 创建一个HyperLogLog结构的hll2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE hll3 hll1 hll2# 合并这两个HyperLogLog结构的key</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT hll3# 统计合并后HyperLogLog结构的hll3的基数</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT hll1 hll2# 直接统计hll1和hll2</span><br><span class="line">(integer) 9</span><br></pre></td></tr></table></figure><hr><hr><h3 id="八-Geospatial"><a href="#八-Geospatial" class="headerlink" title="八. Geospatial"></a>八. Geospatial</h3><blockquote><p><strong>地理空间</strong></p><p>Redis<code>地理空间</code>索引可以存储坐标并搜索它们。此数据结构用于在给定半径或包围框内查找附近点。</p><p>Geopatial的数据类型是Zset，相当于由之前的<code>score</code>变成了<code>longitude</code>和<code>latitude</code>，可以使用Zset的命令对其进行操作。</p></blockquote><hr><p><em><strong>Geospatial结构的常用命令：</strong></em></p><h4 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h4><p><strong><code>GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...]</code></strong></p><blockquote><p>将指定的地理空间项(经度、纬度、名称)添加到地理空间结构的key中。</p><p>数据以有序集的形式存储到键中，这样就可以使用GEOSEARCH命令查询项。</p><p>规定如下：</p><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul><p>当坐标位置超出上述指定范围时，该命令将会返回一个错误。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD city 116.403963 39.915119 &quot;天安门&quot; 116.403414 39.924091 &quot;故宫&quot; 116.024067 40.362639 &quot;长城&quot;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-09_051719.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-09_051719.png" alt="2023-04-09_051719"></a></p><p>注意：使用–raw启动客户端后，返回数据的类型以及编号不会显示了</p><hr><h4 id="GEOPOS"><a href="#GEOPOS" class="headerlink" title="GEOPOS"></a>GEOPOS</h4><p>**<code>GEOPOS key member [member ...]</code>**：从给定的key里返回所有指定member的位置(经度和纬度)，不存在的member返回nil。</p><blockquote><p>GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。给定的位置元素不存在时， 对应的数组项为空值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOPOS city 天安门 故宫 长城</span><br><span class="line">116.40396326780319214</span><br><span class="line">39.91511970338637383</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line">116.02406591176986694</span><br><span class="line">40.36263993239462167</span><br></pre></td></tr></table></figure><hr><h4 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h4><p>**<code>GEOHASH key member [member ...]</code>**：获取一个或多个<code>member</code>的geohash值。</p><blockquote><p>通常使用表示位置的元素使用不同的技术，使用Geohash位置52点整数编码。 由于编码和解码过程中所使用的初始最小和最大坐标不同，编码的编码也不同于标准。此命令返回一个标准的Geohash。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOHASH city 天安门 故宫 长城</span><br><span class="line">wx4g0f6f2v0</span><br><span class="line">wx4g0gfqsj0</span><br><span class="line">wx4t85y1kt0</span><br></pre></td></tr></table></figure><hr><h4 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h4><p>**<code>GEODIST key member1 member2 [M | KM | FT | MI]</code>**：返回两个给定<code>member</code>之间的距离。</p><blockquote><p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p>如果用户没有显式地指定单位参数， 那么 <code>GEODIST</code> 默认使用M作为单位。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEODIST city 天安门 长城</span><br><span class="line">59338.9814# 天安门距离长城59338.9814米</span><br><span class="line">127.0.0.1:6379&gt; GEODIST city 天安门 长城 km</span><br><span class="line">59.3390# 天安门距离长城59.3390千米</span><br></pre></td></tr></table></figure><hr><h4 id="GEORADIUS"><a href="#GEORADIUS" class="headerlink" title="GEORADIUS"></a>GEORADIUS</h4><p><strong><code>GEORADIUS key longitude latitude radius &lt;M | KM | FT | MI&gt; [WITHCOORD] [WITHDIST] [WITHHASH] </code></strong> <strong><code>[COUNT count [ANY]] [ASC | DESC] [STORE key] [STOREDIST key]</code></strong></p><blockquote><p>以给定的经纬度为中心， 返回key包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p><p>radius：半径</p><p>WITHDIST：在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</p><p>WITHCOORD： 将位置元素的经度和维度也一并返回。</p><p>WITHHASH：将geohash值一并返回。</p><p>COUNT ：限定返回的记录数。</p><p>ASC：由近到远返回（升序）</p><p>DESC：由远到近返回（降序）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">假设当前位置北京王府井(116.418017 39.914402)</span><br><span class="line"># 由近到远排序</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS city 116.418017 39.914402 10 km withdist withcoord withhash count 10</span><br><span class="line">天安门  # member</span><br><span class="line">1.2016# 天安门距离北京王府井1.2km</span><br><span class="line">4069885555089531# geohash值</span><br><span class="line">116.40396326780319214# 经度值</span><br><span class="line">39.91511970338637383# 纬度值</span><br><span class="line">故宫</span><br><span class="line">1.6470# 故宫距离北京王府井1.6km</span><br><span class="line">4069885568908290</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line"># 由远到近排序</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS city 116.418017 39.914402 10 km withdist withcoord withhash count 10 desc</span><br><span class="line">故宫</span><br><span class="line">1.6470</span><br><span class="line">4069885568908290</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line">天安门</span><br><span class="line">1.2016</span><br><span class="line">4069885555089531</span><br><span class="line">116.40396326780319214</span><br><span class="line">39.91511970338637383</span><br><span class="line"># 将半径改为70km，这样长城也在范围内</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS city 116.418017 39.914402 70 km withdist withcoord withhash count 10 desc</span><br><span class="line">长城</span><br><span class="line">60.0642# 长城距离北京王府井60km</span><br><span class="line">4069895262981475</span><br><span class="line">116.02406591176986694</span><br><span class="line">40.36263993239462167</span><br><span class="line">故宫</span><br><span class="line">1.6470</span><br><span class="line">4069885568908290</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line">天安门</span><br><span class="line">1.2016</span><br><span class="line">4069885555089531</span><br><span class="line">116.40396326780319214</span><br><span class="line">39.91511970338637383</span><br></pre></td></tr></table></figure><hr><h4 id="GEORADIUSBYMEMBER"><a href="#GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUSBYMEMBER"></a>GEORADIUSBYMEMBER</h4><p><strong><code>GEORADIUSBYMEMBER key member radius &lt;M | KM | FT | MI&gt; [WITHCOORD] [WITHDIST] [WITHHASH] </code></strong> <strong><code>[COUNT count [ANY]] [ASC | DESC] [STORE key] [STOREDIST key]</code></strong></p><blockquote><p>以给定的位置元素为中心点，找出位于指定范围内的元素。其他和GEORADIUS命令一样。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 获取距离天安10km范围内的位置元素</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER city 天安门 10 km withdist withcoord withhash count 10 desc</span><br><span class="line">故宫</span><br><span class="line">0.9988</span><br><span class="line">4069885568908290</span><br><span class="line">116.40341609716415405</span><br><span class="line">39.92409008156928252</span><br><span class="line">天安门</span><br><span class="line">0.0000</span><br><span class="line">4069885555089531</span><br><span class="line">116.40396326780319214</span><br><span class="line">39.91511970338637383</span><br></pre></td></tr></table></figure><hr><hr><h3 id="九-Stream"><a href="#九-Stream" class="headerlink" title="九. Stream"></a>九. Stream</h3><blockquote><p><strong>流</strong></p><p>Redis流是一种数据结构（Stream类型），它的作用类似于只能追加的日志。您可以使用流来实时记录和同时聚合事件。</p><p>Redis流用例示例包括:</p><ul><li>事件来源(例如，跟踪用户操作、点击等)</li><li>传感器监测(例如，来自现场设备的读数)</li><li>通知(例如，在单独的流中存储每个用户通知的记录)</li></ul><p>Redis为每个流消息生成一个唯一的ID，可以使用这些id检索它们关联的消息，或者读取和处理流中的所有后续消息。</p><p>四种和ID有关的特殊符号： <code>-</code>和<code>+</code>：当前流中最小ID和最大ID <code>$</code>：表示大于当前流中最大的id，用于新添加的消息 <code>&gt;</code>：用于XREANGROUP命令，表示迄今没有发送给组中使用者的信息，会更新消费者组的最后ID <code>*</code>：用于XADD命令中，表示让系统自动生成ID</p></blockquote><p>Stream流就是Redis版的MQ消息中间件+阻塞队列，它能实现消息队列，它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/stream%E5%8E%9F%E7%90%86.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/stream%E5%8E%9F%E7%90%86.png" alt="stream原理"></a></p><blockquote><p>Message Content：消息内容</p><p>Consumer group：消费组，通过XGROUP CREATE 命令创建，同一个消费组可以有多个消费者</p><p>Last_delivered_id：游标，每个消费组会有个游标 last_delivered_id，任意一消费者读取了消息都会使游标 last_delivered_id 往前移动。</p><p>Consumer：消费者，消费组中的消费者</p><p>Pending_ids：消费者会有一个状态变量，用于记录被当前消费已读取但未ack的消息Id，如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack它就开始减少。这个pending_ids变量在Redis官方被称之为 PEL(Pending Entries List)，记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</p></blockquote><hr><p><em><strong>Stream类型的常用命令：</strong></em></p><h4 id="XADD"><a href="#XADD" class="headerlink" title="XADD"></a>XADD</h4><p><strong><code>XADD key [NOMKSTREAM] [&lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count]] &lt;\* | id&gt; field value [field value ...] </code></strong></p><blockquote><p>将消息追加到指定流<code>key</code>的末尾，添加的消息ID要比上个消息的ID大。如果key不存在，将自动创建流key然后执行XADD操作。</p><p>ID用于标识给定消息，如果指定的ID参数是字符<code>*</code>，<code>XADD</code>命令会自动生成一个唯一的ID。ID是由时间戳-序列号两部分组成，当自动生成ID时，第一部分是生成ID的Redis实例的毫秒格式的Unix时间。 第二部分是一个序列号，用来区分同一毫秒内生成的ID的。序列号是64位长度(18446744073709551615)，理论上在同一毫秒内生成的数据量无法到达这个级别，因此不用担心序列号会不够用。</p><p>该命令返回添加的消息的ID。如果ID参数传的是<code>*</code>，那么ID是自动生成的， 否则，命令仅返回用户在插入期间指定的相同的ID。</p><p>通常使用命令<code>XADD ID filed value [field value ...]</code>，其他的花里胡哨的参数了解即可。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XADD mystream * name tom age 20# 添加一条消息到mystream队列末尾，自动生成id</span><br><span class="line">&quot;1681002319038-0&quot;# 返回生成消息的id</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681002319038-0 name tom age 20# 如果添加消息的id不比上一消息id大，则报错</span><br><span class="line">(error) ERR The ID specified in XADD is equal or smaller than the target stream top item</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681002319038-1 name tom age 20# 比上一消息id大，添加成功，返回添加消息的id</span><br><span class="line">&quot;1681002319038-1&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><hr><h4 id="XRANGE"><a href="#XRANGE" class="headerlink" title="XRANGE"></a>XRANGE</h4><p>**<code>XRANGE key start end [COUNT count]</code>**：返回给定id范围内流key的消息。</p><blockquote><p>id范围由[start,end]指定。特殊ID：<code>-</code> 表示流中最小的消息id，<code>+</code>表示流中最大的消息id。</p><p>返回的消息由id从小到大排序。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XADD mystream * name Alice age 20</span><br><span class="line">&quot;1681003546319-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream * name Bob age 21</span><br><span class="line">&quot;1681003556153-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream * name Cindy age 22</span><br><span class="line">&quot;1681003570177-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream * name Davie age 23</span><br><span class="line">&quot;1681003595504-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +# - + 表示返回流mystream中所有的消息，且根据id从小到大排序</span><br><span class="line">1) 1) &quot;1681003546319-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Alice&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">2) 1) &quot;1681003556153-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Bob&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br><span class="line">3) 1) &quot;1681003570177-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br><span class="line">4) 1) &quot;1681003595504-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;23&quot;</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - + count 2# 限制返回两个</span><br><span class="line">1) 1) &quot;1681003546319-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Alice&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">2) 1) &quot;1681003556153-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Bob&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br></pre></td></tr></table></figure><hr><h4 id="XREVRANGE"><a href="#XREVRANGE" class="headerlink" title="XREVRANGE"></a>XREVRANGE</h4><p>**<code>XREVRANGE key end start [COUNT count]</code>**：返回给定id范围内流key的消息。</p><blockquote><p>在<code>XREVRANGE</code>中，要先指定结束ID，再指定开始ID，返回消息的顺序是根据id从大到小排序。其余和XRANGE一样。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREVRANGE mystream + -</span><br><span class="line">1) 1) &quot;1681003595504-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;23&quot;</span><br><span class="line">2) 1) &quot;1681003570177-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br><span class="line">3) 1) &quot;1681003556153-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Bob&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br><span class="line">4) 1) &quot;1681003546319-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Alice&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREVRANGE mystream + - count 2</span><br><span class="line">1) 1) &quot;1681003595504-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;23&quot;</span><br><span class="line">2) 1) &quot;1681003570177-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br></pre></td></tr></table></figure><hr><h4 id="XDEL"><a href="#XDEL" class="headerlink" title="XDEL"></a>XDEL</h4><p>**<code>XDEL key id [id ...]</code>**：从流key中删除指定id(消息)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XDEL mystream 1681003595504-0 1681003556153-0# 删除Bob和Davie对应的id</span><br><span class="line">(integer) 2# 成功删除两个</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1681003546319-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Alice&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">2) 1) &quot;1681003570177-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br></pre></td></tr></table></figure><hr><h4 id="XLEN"><a href="#XLEN" class="headerlink" title="XLEN"></a>XLEN</h4><p>**<code>XLEN mystream</code>**：返回流key中消息的条数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XLEN mystream# 流mystream中有两条消息</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><hr><h4 id="XTRIM"><a href="#XTRIM" class="headerlink" title="XTRIM"></a>XTRIM</h4><p>**<code>XTRIM key &lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count]</code>**：将流消息裁剪为指定数量的消息。</p><blockquote><p>MAXLEN：表示允许最大的消息长度(个数)，超过此数量会优先删除id较小的消息。</p><p>MINID：表示允许最小的id，比此id还小的消息会被删除。</p><p>返回值：删除消息的数量。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 创建五条消息存入流mystream中</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-0 name Alice age 18</span><br><span class="line">&quot;1681006080120-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-1 name Bob age 19</span><br><span class="line">&quot;1681006080120-1&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-2 name Cindy age 20</span><br><span class="line">&quot;1681006080120-2&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-3 name Davie age 21</span><br><span class="line">&quot;1681006080120-3&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream 1681006080120-4 name Eric age 22</span><br><span class="line">&quot;1681006080120-4&quot;</span><br><span class="line">127.0.0.1:6379&gt; XTRIM mystream maxlen 3# 获取最近的3条消息，id较小的被删除（id是递增的）</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1681006080120-2&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Cindy&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br><span class="line">2) 1) &quot;1681006080120-3&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br><span class="line">3) 1) &quot;1681006080120-4&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Eric&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br><span class="line">127.0.0.1:6379&gt; XTRIM mystream minid 1681006080120-3# 获取id不小于1681006080120-3的消息</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1681006080120-3&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Davie&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;21&quot;</span><br><span class="line">2) 1) &quot;1681006080120-4&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;Eric&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;22&quot;</span><br></pre></td></tr></table></figure><hr><h4 id="XREAD"><a href="#XREAD" class="headerlink" title="XREAD"></a>XREAD</h4><p><strong><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id  [id ...]</code></strong></p><blockquote><p>从一个或者多个流中读取数据，仅返回id大于对应流中最大id的消息（也就是新添加的消息）。</p><p>count：最多读取多少条</p><p>block：是否以阻塞的方式读取，如果开启且milliseconds设为0，表示永远阻塞直到读取到消息。</p><p>id：表示读取ID大于指定id的消息。</p><p>特殊ID：符号<code>$</code>。表示以当前Stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，因此此时返回nil。一般用于阻塞队列获取新消息。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># 数据准备，创建两个流stream1和stream2</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-0 name Alice</span><br><span class="line">&quot;1681006080120-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-1 name Bob</span><br><span class="line">&quot;1681006080120-1&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-2 name Cindy</span><br><span class="line">&quot;1681006080120-2&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-3 name Davie</span><br><span class="line">&quot;1681006080120-3&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream1 1681006080120-4 name Eric</span><br><span class="line">&quot;1681006080120-4&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-0 1 one</span><br><span class="line">&quot;1681008731850-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-1 2 two</span><br><span class="line">&quot;1681008731850-1&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-2 3 three</span><br><span class="line">&quot;1681008731850-2&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-3 4 four</span><br><span class="line">&quot;1681008731850-3&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-4 5 five</span><br><span class="line">&quot;1681008731850-4&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD stream2 1681008731850-5 6 six</span><br><span class="line">&quot;1681008731850-5&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 streams stream1 0-0# count 3表示只获取3个，0-0表示从最小的ID开始获取Stream中的消息</span><br><span class="line">1) 1) &quot;stream1&quot;</span><br><span class="line">   2) 1) 1) &quot;1681006080120-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Alice&quot;</span><br><span class="line">      2) 1) &quot;1681006080120-1&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Bob&quot;</span><br><span class="line">      3) 1) &quot;1681006080120-2&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Cindy&quot;</span><br><span class="line">            </span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 streams stream1 0# 使用0也可以表示从最小的ID开始获取Stream中的消息，000也可以</span><br><span class="line">1) 1) &quot;stream1&quot;</span><br><span class="line">   2) 1) 1) &quot;1681006080120-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Alice&quot;</span><br><span class="line">      2) 1) &quot;1681006080120-1&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Bob&quot;</span><br><span class="line">      3) 1) &quot;1681006080120-2&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Cindy&quot;</span><br><span class="line">            </span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 streams stream1 $# $表示读取大于当前流中最大的id的消息</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 读取stream1中id大于1681006080120-2的三条消息，读取stream2中id大于1681008731850-3的三条消息</span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 block 0 streams stream1 stream2 1681006080120-2 1681008731850-3</span><br><span class="line">1) 1) &quot;stream1&quot;# 读取到了stream1中id大于1681006080120-2的3条消息（如果有多条则读取最新的消息）</span><br><span class="line">   2) 1) 1) &quot;1681006080120-3&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Davie&quot;</span><br><span class="line">      2) 1) &quot;1681006080120-4&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Eric&quot;</span><br><span class="line">      3) 1) &quot;1681008731850-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Jack&quot;</span><br><span class="line">2) 1) &quot;stream2&quot;# stream2中有两条id大于1681008731850-3的消息</span><br><span class="line">   2) 1) 1) &quot;1681008731850-4&quot;</span><br><span class="line">         2) 1) &quot;5&quot;</span><br><span class="line">            2) &quot;five&quot;</span><br><span class="line">      2) 1) &quot;1681008731850-5&quot;</span><br><span class="line">         2) 1) &quot;6&quot;</span><br><span class="line">            2) &quot;six&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 加入阻塞选项，此时开启另一个redis客户端存入消息到stream1中，观察当前客户端的变化</span><br><span class="line">127.0.0.1:6379&gt; XREAD count 3 block 0 streams stream1 $</span><br><span class="line">1) 1) &quot;stream1&quot;</span><br><span class="line">   2) 1) 1) &quot;1681008731850-0&quot;# 读取到了一条消息</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Jack&quot;</span><br><span class="line">(53.24s)# 等待了53.24s</span><br></pre></td></tr></table></figure><hr><p><em><strong>消费组相关指令</strong></em></p><h4 id="XGROUP"><a href="#XGROUP" class="headerlink" title="XGROUP"></a>XGROUP</h4><p>**<code>XGROUP CREATE key group &lt;id | $&gt; </code>**：创建消费者组。</p><blockquote><p>最后一个参数是要考虑已传递的流中最后一项的ID。</p><p>$表示从Stream尾部开始消费，在这种情况下，从该消费者组获取数据的消费者只能看到到达流的新元素。</p><p>0表示从Stream头部开始消费，消费者组可以获取整个流的历史记录。</p><p>创建消费者组的时候必须指定 ID, ID 为 0 表示从头开始消费，为 $ 表示只消费新的消息。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建消费者组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create mystream1 groupA $</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create mystream1 groupB 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>**<code>XGROUP CREATECONSUMER key group consumer</code>**：创建消费者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP CREATECONSUMER mystream1 groupA consumerA#在流mystream1的groupA中创建消费者consumerA</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XINFO CONSUMERS mystream1 groupA# 查看流mystream1的消费组groupA的消费者信息</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;consumerA&quot;# 消费者名称</span><br><span class="line">   3) &quot;pending&quot;</span><br><span class="line">   4) (integer) 0# 消费者读取消息的数量（此时还未读取消息，所以为0）</span><br><span class="line">   5) &quot;idle&quot;</span><br><span class="line">   6) (integer) 26277</span><br></pre></td></tr></table></figure><p>**<code>XGROUP DESTORY key group</code>**：删除流key中指定的消费组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP create mystream1 groupC 0# 在流stream1中创建消费组groupC</span><br><span class="line">OK</span><br><span class="line"># 删除消费组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP DESTROY mystream1 groupC# 删除流stream1中的消费组groupC</span><br><span class="line">(integer) 1# 返回删除的个数</span><br></pre></td></tr></table></figure><p>**<code>XGROUP DELCONSUMER key group consumer</code>**：删除流key中消费组group的指定消费者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP CREATECONSUMER mystream1 groupA consumerA</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XGROUP DELCONSUMER mystream1 groupA consumerA</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; XINFO CONSUMERS mystream1 groupA</span><br><span class="line">(empty array)# 消费者consumerA已经被删除</span><br></pre></td></tr></table></figure><hr><h4 id="XREADGROUP"><a href="#XREADGROUP" class="headerlink" title="XREADGROUP"></a>XREADGROUP</h4><p><strong><code>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]</code></strong></p><blockquote><p>读取消费者组中的消息。</p><p>消费者不存在则自动创建该消费者。</p><p>特殊ID：<code>&gt;</code>表示从第一条未被消费的消息开始读取。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 创建消费组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create stream1 groupA 0</span><br><span class="line">ok</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create stream1 groupB 0</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 消费组groupA内的消费者consumer1从stream1消息队列中读取所有信息</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer1 STREAMS stream1  &gt;# &gt;表示从第一条未被消费的消息开始读取。</span><br><span class="line">1) 1) &quot;stream1&quot;</span><br><span class="line">   2) 1) 1) &quot;1681006080120-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Alice&quot;</span><br><span class="line">      2) 1) &quot;1681006080120-1&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Bob&quot;</span><br><span class="line">      3) 1) &quot;1681006080120-2&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Cindy&quot;</span><br><span class="line">      4) 1) &quot;1681006080120-3&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Davie&quot;</span><br><span class="line">      5) 1) &quot;1681006080120-4&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Eric&quot;</span><br><span class="line">      6) 1) &quot;1681008731850-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Jack&quot;</span><br><span class="line"># 消费组groupA中消费者consumer1一口气读取完所有消息，组中其他消费者就不能读取消息了（同一个消费组里的消费者不能消费同一条消息）</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer2 STREAMS stream1  &gt;</span><br><span class="line">(nil)# 已经被消费者cumstomer1消费完了，所以返回nil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建消费组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create stream2 groupA 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; XGROUP create stream2 groupB 0</span><br><span class="line">OK</span><br><span class="line"># 让组内的多个消费者共同分担读取消息，所以让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer1 count 3 STREAMS stream2 &gt;# 限制读取3个</span><br><span class="line">1) 1) &quot;stream2&quot;</span><br><span class="line">   2) 1) 1) &quot;1681008731850-0&quot;</span><br><span class="line">         2) 1) &quot;1&quot;</span><br><span class="line">            2) &quot;one&quot;</span><br><span class="line">      2) 1) &quot;1681008731850-1&quot;</span><br><span class="line">         2) 1) &quot;2&quot;</span><br><span class="line">            2) &quot;two&quot;</span><br><span class="line">      3) 1) &quot;1681008731850-2&quot;</span><br><span class="line">         2) 1) &quot;3&quot;</span><br><span class="line">            2) &quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer2 count 3 STREAMS stream2 &gt;# 读取另外三个</span><br><span class="line">1) 1) &quot;stream2&quot;</span><br><span class="line">   2) 1) 1) &quot;1681008731850-3&quot;</span><br><span class="line">         2) 1) &quot;4&quot;</span><br><span class="line">            2) &quot;four&quot;</span><br><span class="line">      2) 1) &quot;1681008731850-4&quot;</span><br><span class="line">         2) 1) &quot;5&quot;</span><br><span class="line">            2) &quot;five&quot;</span><br><span class="line">      3) 1) &quot;1681008731850-5&quot;</span><br><span class="line">         2) 1) &quot;6&quot;</span><br><span class="line">            2) &quot;six&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP groupA consumer3 count 3 STREAMS stream2 &gt;</span><br><span class="line">(nil)# 已经没有消息可读，返回nil</span><br></pre></td></tr></table></figure><hr><h4 id="XPENDING"><a href="#XPENDING" class="headerlink" title="XPENDING"></a>XPENDING</h4><p>**<code>XPENDING key group</code>**：返回待处理消息相关信息。（读取到的消息没有经过XACK确认即为待处理消息）</p><blockquote><p>返回一组数据，包括消费组待处理消息的数量、所有消费者读取的消息最小id、所有消费者所读取id的最大值、每个消费者待处理消息的数量。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XPENDING stream1 groupA</span><br><span class="line">1) (integer) 6# 待处理消息数</span><br><span class="line">2) &quot;1681006080120-0&quot;# 待处理消息最小id</span><br><span class="line">3) &quot;1681008731850-0&quot;# 待处理消息最大id</span><br><span class="line">4) 1) 1) &quot;consumer1&quot;# 消费者consumer1</span><br><span class="line">      2) &quot;6&quot;# 消费者consumer1有6条待处理消息</span><br><span class="line">127.0.0.1:6379&gt; XPENDING stream2 groupA</span><br><span class="line">1) (integer) 6# 待处理消息数</span><br><span class="line">2) &quot;1681008731850-0&quot;# 待处理消息最小id</span><br><span class="line">3) &quot;1681008731850-5&quot;# 待处理消息最大id</span><br><span class="line">4) 1) 1) &quot;consumer1&quot;# 消费者consumer1</span><br><span class="line">      2) &quot;3&quot;# 消费者consumer1有3条待处理消息</span><br><span class="line">   2) 1) &quot;consumer2&quot;# 消费者consumer2</span><br><span class="line">      2) &quot;3&quot;# 消费者consumer2有3条待处理消息</span><br></pre></td></tr></table></figure><p>**<code>XPENDING key group start end count consumer</code>**：查看指定消费者具体读取了哪些数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看消费者consumer1具体读取了哪些数据</span><br><span class="line">127.0.0.1:6379&gt; XPENDING stream2 groupA - + 5 consumer1# 查看groupA组consumer1具体读取了哪些数据，设置最大返回5条</span><br><span class="line">1) 1) &quot;1681008731850-0&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) (integer) 2089450</span><br><span class="line">   4) (integer) 1</span><br><span class="line">2) 1) &quot;1681008731850-1&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) (integer) 2089450</span><br><span class="line">   4) (integer) 1</span><br><span class="line">3) 1) &quot;1681008731850-2&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) (integer) 2089450</span><br><span class="line">   4) (integer) 1</span><br></pre></td></tr></table></figure><hr><h4 id="XACK"><a href="#XACK" class="headerlink" title="XACK"></a>XACK</h4><p>**<code>XACK key group id [id ...]</code>**：向消息队列确认id对应的消息已处理完成，XACK会从待处理消息列表中删除该消息。</p><blockquote><p>返回值：该命令返回成功确认的消息数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XACK stream1 groupA 1681006080120-0# 确认id1681006080120-0处理完成</span><br><span class="line">(integer) 1# 成功确认一条</span><br><span class="line">127.0.0.1:6379&gt; XPENDING stream1 groupA</span><br><span class="line">1) (integer) 5# 待确认消息数减1</span><br><span class="line">2) &quot;1681006080120-1&quot;</span><br><span class="line">3) &quot;1681008731850-0&quot;</span><br><span class="line">4) 1) 1) &quot;consumer1&quot;</span><br><span class="line">      2) &quot;5&quot;</span><br></pre></td></tr></table></figure><hr><h4 id="XINFO"><a href="#XINFO" class="headerlink" title="XINFO"></a>XINFO</h4><p>**<code>XINFO stream key</code>**：获取流key的详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XINFO stream stream2 # 获取流stream2的详细信息</span><br><span class="line"> 1) &quot;length&quot;</span><br><span class="line"> 2) (integer) 6</span><br><span class="line"> 3) &quot;radix-tree-keys&quot;</span><br><span class="line"> 4) (integer) 1</span><br><span class="line"> 5) &quot;radix-tree-nodes&quot;</span><br><span class="line"> 6) (integer) 2</span><br><span class="line"> 7) &quot;last-generated-id&quot;</span><br><span class="line"> 8) &quot;1681008731850-5&quot;</span><br><span class="line"> 9) &quot;max-deleted-entry-id&quot;</span><br><span class="line">10) &quot;0-0&quot;</span><br><span class="line">11) &quot;entries-added&quot;</span><br><span class="line">12) (integer) 6</span><br><span class="line">13) &quot;recorded-first-entry-id&quot;</span><br><span class="line">14) &quot;1681008731850-0&quot;</span><br><span class="line">15) &quot;groups&quot;</span><br><span class="line">16) (integer) 2</span><br><span class="line">17) &quot;first-entry&quot;</span><br><span class="line">18) 1) &quot;1681008731850-0&quot;</span><br><span class="line">    2) 1) &quot;1&quot;</span><br><span class="line">       2) &quot;one&quot;</span><br><span class="line">19) &quot;last-entry&quot;</span><br><span class="line">20) 1) &quot;1681008731850-5&quot;</span><br><span class="line">    2) 1) &quot;6&quot;</span><br><span class="line">       2) &quot;six&quot;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>**<code>XINFO GROUPS key</code>**：获取流key中消费组信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XINFO GROUPS stream2# 获取流stream2中的消费组信息</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;groupA&quot;# 消费组groupA</span><br><span class="line">    3) &quot;consumers&quot;</span><br><span class="line">    4) (integer) 2</span><br><span class="line">    5) &quot;pending&quot;</span><br><span class="line">    6) (integer) 6</span><br><span class="line">    7) &quot;last-delivered-id&quot;</span><br><span class="line">    8) &quot;1681008731850-5&quot;</span><br><span class="line">    9) &quot;entries-read&quot;</span><br><span class="line">   10) (integer) 6</span><br><span class="line">   11) &quot;lag&quot;</span><br><span class="line">   12) (integer) 0</span><br><span class="line">2)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;groupB&quot;# 消费组groupB</span><br><span class="line">    3) &quot;consumers&quot;</span><br><span class="line">    4) (integer) 1</span><br><span class="line">    5) &quot;pending&quot;</span><br><span class="line">    6) (integer) 3</span><br><span class="line">    7) &quot;last-delivered-id&quot;</span><br><span class="line">    8) &quot;1681008731850-2&quot;</span><br><span class="line">    9) &quot;entries-read&quot;</span><br><span class="line">   10) (integer) 3</span><br><span class="line">   11) &quot;lag&quot;</span><br><span class="line">   12) (integer) 3</span><br></pre></td></tr></table></figure><p>**<code>XINFO CONSUMERS key group</code>**：获取流key中消费组group中消费者信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XINFO CONSUMERS stream2 groupA# 获取流stream2中消费组groupA中的消费者信息</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) &quot;pending&quot;</span><br><span class="line">   4) (integer) 3</span><br><span class="line">   5) &quot;idle&quot;</span><br><span class="line">   6) (integer) 30195569</span><br><span class="line">2) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;consumer2&quot;</span><br><span class="line">   3) &quot;pending&quot;</span><br><span class="line">   4) (integer) 3</span><br><span class="line">   5) &quot;idle&quot;</span><br><span class="line">   6) (integer) 30166362</span><br></pre></td></tr></table></figure><hr><hr><h3 id="十-Bitfield"><a href="#十-Bitfield" class="headerlink" title="十. Bitfield"></a>十. Bitfield</h3><blockquote><p><strong>位域</strong></p><p>Bitfield结构的底层也是String类型。<code>是一个操作位数据的数据结构,用于压缩数据，节省内存</code></p><p>Redis位字段允许设置、递增和获取任意位长度的整数值。例如可以对从无符号1位整数到有符号63位整数的任何数字进行操作。</p><p>这些值使用二进制编码的Redis字符串存储。位字段支持原子读、写和递增操作，这使它们成为管理计数器和类似数值的好选择。</p><p>例如 hello 等价于 0110100001100101011011000110110001101111，每八位对应一个字母，也对应一个十进制值。可以修改每一位的数字从而改变对应的数值从而改变对应的字母。</p></blockquote><hr><p><em><strong>Bitfield结构的常用命令：</strong></em></p><h4 id="BITFIELD"><a href="#BITFIELD" class="headerlink" title="BITFIELD"></a>BITFIELD</h4><p><strong><code>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] </code></strong> <strong><code>[OVERFLOW WRAP|SAT|FAIL]</code></strong></p><blockquote><p>此命令会把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。</p><p>下面是已支持的命令列表：</p><ul><li>GET ：返回指定的位域的数值。</li><li>SET ： 设置指定位域的数值并返回它的原值。</li><li>INCRBY ： 自增或自减（如果increment为负数）指定位域的值并返回它的新值。</li></ul><p>type表示多少位的有符号还是无符号整型。有符号整型需在位数前加<code>i</code>，无符号在位数前加<code>u</code>。例如，<code>u8</code>是一个8位的无符号整型，<code>i16</code>是一个16位的有符号整型。offset表示偏移量，比如i4表示以4个比特位为一个偏移量。</p><p>还有一个命令通过设置溢出行为来改变调用<code>INCRBY</code>指令的后序操作：OVERFLOW [WRAP|SAT|FAIL] wrap：使用回环方式处理有符号整数和无符号整数的溢出情况。 sat：使用饱和计算方式处理溢出，下溢计算的结果为最小的整数值，上溢计算的结果为最大的整数值。 fail：命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行。</p><p>有符号整型最大支持64位，而无符号整型最大支持63位。对无符号整型的限制，是由于当前Redis协议不能在响应消息中返回64位无符号整数。</p></blockquote><table><thead><tr><th>字母</th><th>数值</th><th>二进制（高位-&gt;低位）</th></tr></thead><tbody><tr><td>h</td><td>104</td><td>0110 1000</td></tr><tr><td>e</td><td>101</td><td>0110 0101</td></tr><tr><td>l</td><td>108</td><td>0110 1100</td></tr><tr><td>l</td><td>108</td><td>0110 1100</td></tr><tr><td>o</td><td>111</td><td>0110 1111</td></tr><tr><td>x</td><td>120</td><td>0111 1000</td></tr></tbody></table><ul><li><strong>GET和SET选项</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set mybitfield hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 0# 以8位位一组，偏移量0表示第一个字符</span><br><span class="line">1) (integer) 104# 返回该字符对应的十进制值数值</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 8# 偏移量8表示第二个字符</span><br><span class="line">1) (integer) 101</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 16</span><br><span class="line">1) (integer) 108</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 24</span><br><span class="line">1) (integer) 108</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield get i8 32</span><br><span class="line">1) (integer) 111</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD mybitfield set i8 32 120#将偏移量为32的那一组的数值替换为120(字母x)</span><br><span class="line">1) (integer) 111</span><br><span class="line">127.0.0.1:6379&gt; get mybitfield</span><br><span class="line">hellx</span><br></pre></td></tr></table></figure><ul><li><strong>INCRBY选项</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set fieldkey hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1# 从第三个比特位开始，对接下来的4位无符号数加1</span><br><span class="line">1) (integer) 11# 返回指定域增加后的数值</span><br><span class="line">127.0.0.1:6379&gt; get fieldkey# 因为比特位的数值发生了变化，所以对应的数值也会发生变化，对应的字母也就变了</span><br><span class="line">lello</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1</span><br><span class="line">1) (integer) 12</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1</span><br><span class="line">1) (integer) 13</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1</span><br><span class="line">1) (integer) 14</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1</span><br><span class="line">1) (integer) 15</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey incrby u4 2 1# 4位表示最大的数为15，溢出控制默认为wrap（循环溢出），超出后从0开始</span><br><span class="line">1) (integer) 0# 从0开始</span><br></pre></td></tr></table></figure><ul><li><strong>OVERFLOW选项</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set fieldkey2 a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey2 overflow sat set i8 0 126# 从偏移量0开始后八位对应的数值改为126</span><br><span class="line">1) (integer) 97# 返回之前的数值</span><br><span class="line">127.0.0.1:6379&gt; get fieldkey2</span><br><span class="line">&quot;~&quot;# 126对应这个~符号</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey2 overflow sat set i8 0 128# 将数值改为128（超出了8位表示的最大值127）</span><br><span class="line">1) (integer) 126# 返回之前的数值</span><br><span class="line">127.0.0.1:6379&gt; get fieldkey2</span><br><span class="line">&quot;\x7f&quot;# 127对应的编码</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey2 overflow sat set i8 0 128# 再次改为128</span><br><span class="line">1) (integer) 127# 使用sat溢出控制，超出了最大值的表示范围会取最大值127</span><br><span class="line">127.0.0.1:6379&gt; BITFIELD fieldkey2 overflow fail set i8 0 128# 使用fail溢出控制，再次改为128</span><br><span class="line">1) (nil)# 使用fail溢出控制，超出了最大值的表示范围返回nil</span><br></pre></td></tr></table></figure><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis持久化(Redis persistence)是指将数据写入持久存储，如固态硬盘(SSD)。</p><p>Redis提供了一系列持久性选项。这些包括:</p><ul><li><strong>RDB</strong>（redis 数据库）：RDB持久化方式能够在指定的时间间隔对数据进行快照存储。</li><li><strong>AOF</strong>（追加文件）：AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</li><li><strong>No persistence</strong>（没有持久化）：可以完全禁用持久性，这有时在缓存时使用。</li><li><strong>RDB+AOF</strong>：可以同时开启两种持久化方式，在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li></ul><hr><h3 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h3><blockquote><p>Redis Database缩写。在<code>指定的时间间隔</code>，对数据进行<code>快照存储</code>。RDB保存到磁盘的文件叫dump.rdb。<code>全量快照</code></p></blockquote><h4 id="1-1-快照"><a href="#1-1-快照" class="headerlink" title="1.1 快照"></a>1.1 快照</h4><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。也可以通过调用 SAVE或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p><p>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集: save 60 1000</p><h4 id="1-2-RDB优缺点"><a href="#1-2-RDB优缺点" class="headerlink" title="1.2 RDB优缺点"></a>1.2 RDB优缺点</h4><ul><li><strong>RDB的优点</strong><ul><li>RDB是一个非常<code>紧凑</code>的文件，它保存了某个时间点得数据集，非常适用于数据集的备份，比如可以在每个小时报保存一下过去24小时内的数据，同时每天保存过去30天的数据,这样即使出了问题也可以根据需求恢复到<code>不同版本</code>的数据集。</li><li>RDB是一个紧凑的单一文件，很方便传送到另一个远端数据中心，非常适用于<code>灾难恢复</code>。</li><li>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个<code>子进程</code>，接下来的工作全部由子进程来做，<code>父进程不需要再做其他IO操作</code>，所以RDB持久化方式可以最大化redis的性能。</li><li>与AOF相比，在恢复大的数据集的时候，RDB方式会<code>更快</code>一些。</li></ul></li><li><strong>RDB缺点</strong><ul><li>如果希望在redis<code>意外停止工作</code>（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合，虽然可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作)，但是Redis要完整的保存整个数据集是一个比较繁重的工作，通常会每隔5分钟或者更久做一次完整的保存，万一在Redis意外宕机，<code>可能会丢失几分钟的数据</code>。</li><li>RDB 需要经常fork子进程来保存数据集到硬盘上，当<code>数据集比较大</code>的时候，<code>fork</code>的过程是非常耗时的，可能会导致Redis在一些毫秒级内<code>不能响应</code>客户端的请求。如果数据集巨大并且CPU性能不是很好的情况下，这种情况会持续1秒，AOF也需要fork，但是可以调节重写日志文件的频率来提高数据集的耐久度。</li></ul></li></ul><h4 id="1-3-RDB配置"><a href="#1-3-RDB配置" class="headerlink" title="1.3 RDB配置"></a>1.3 RDB配置</h4><ul><li><p>配置dump.rdb文件保存路径</p><blockquote><p>下面是设置到了redis安装目录，当然也可以设置到其他目录下。默认是<code>./</code></p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-11_225736.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-11_225736.png" alt="2023-04-11_225736"></a></p></li><li><p>修改快照文件名</p><blockquote><p>快照文件名默认为dump.rdb，可以对其进行修改</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_025908.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_025908.png" alt="2023-04-12_025908"></a></p></li></ul><h4 id="1-4-触发RDB快照和恢复"><a href="#1-4-触发RDB快照和恢复" class="headerlink" title="1.4 触发RDB快照和恢复"></a>1.4 触发RDB快照和恢复</h4><h5 id="1-4-1-自动触发"><a href="#1-4-1-自动触发" class="headerlink" title="1.4.1 自动触发"></a>1.4.1 自动触发</h5><ul><li><p>设置redis.config文件中的自动触发时间：save</p><ul><li><p>修改为7秒内3次修改：save 7 3</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-11_222730.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-11_222730.png" alt="2023-04-11_222730"></a></p></li><li><p>添加数据触发快照</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-11_223005.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-11_223005.png" alt="2023-04-11_223005"></a></p></li></ul></li><li><p>FLUSHDB和FLUSHALL命令</p><blockquote><p>执行flushdb或者flushall命令也会<code>触发</code>RDB快照，不过里面是空的，以便下次启动redis服务是读取到的就是空文件。</p></blockquote></li><li><p>SHUTDOWN命令</p><blockquote><p>执行shutdown命令之前会将当前的数据进行一次快照保存。</p></blockquote></li></ul><h5 id="1-4-2-手动触发"><a href="#1-4-2-手动触发" class="headerlink" title="1.4.2 手动触发"></a>1.4.2 手动触发</h5><ul><li><p>SAVE命令</p><blockquote><p>SAVE命令在主程序中执行会<code>阻塞当前进程</code>，直到持久化工作完成，redis才能处理其他命令。**<code>工作中禁止</code>**使用该命令。 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name Alice</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; save# 立马将数据保存到快照中，如果数据量大会造成阻塞</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_010123.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_010123.png" alt="2023-04-12_010123"></a></p></li><li><p>BGSAVE命令</p><blockquote><p>BGSAVE命令会<code>fork一个子进程</code>在后台<code>异步进行</code>持久化工作，持久化期间redis可以执行其他命令。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name Cindy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started# 在后台执行持久化</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_010220.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_010220.png" alt="2023-04-12_010220"></a></p></li></ul><p><strong>LASTSAVE</strong>命令可以获取最后一次成功执行快照的时间。得到的是一个时间戳，可以通过<code>date -d @时间戳</code>命令获取对应的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LASTSAVE</span><br><span class="line">(integer) 1681223083</span><br><span class="line">127.0.0.1:6379&gt; quit</span><br><span class="line">[root@redis ~]# date -d @1681223083</span><br><span class="line">2023年 04月 11日 星期二 22:24:43 CST</span><br></pre></td></tr></table></figure><h5 id="1-4-3-修复快照数据"><a href="#1-4-3-修复快照数据" class="headerlink" title="1.4.3 修复快照数据"></a>1.4.3 修复快照数据</h5><blockquote><p>有些情况下快照保存的数据不完整导致无法读取快照数据，可以使用<code>redis-check-rdb</code>命令对rdb文件进行修复。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@redis redis-7.0.10]# redis-check-rdb dump.rdb </span><br><span class="line">[offset 0] Checking RDB file dump.rdb</span><br><span class="line">[offset 27] AUX FIELD redis-ver = &#x27;7.0.10&#x27;</span><br><span class="line">[offset 41] AUX FIELD redis-bits = &#x27;64&#x27;</span><br><span class="line">[offset 53] AUX FIELD ctime = &#x27;1681233313&#x27;</span><br><span class="line">[offset 68] AUX FIELD used-mem = &#x27;1104992&#x27;</span><br><span class="line">[offset 80] AUX FIELD aof-base = &#x27;0&#x27;</span><br><span class="line">[offset 82] Selecting DB ID 0</span><br><span class="line">[offset 155] Checksum OK</span><br><span class="line">[offset 155] \o/ RDB looks OK! \o/</span><br><span class="line">[info] 8 keys read</span><br><span class="line">[info] 0 expires</span><br><span class="line">[info] 0 already expired</span><br></pre></td></tr></table></figure><h5 id="1-4-4-恢复快照数据"><a href="#1-4-4-恢复快照数据" class="headerlink" title="1.4.4 恢复快照数据"></a>1.4.4 恢复快照数据</h5><blockquote><p>redis在启动服务时会读取配置的快照保存路径中的dump.rdb文件，所以只需要将备份的rdb文件放到配置的保存路径中，然后启动redis服务即可还原快照中的数据。</p></blockquote><h4 id="1-5-禁用RDB快照"><a href="#1-5-禁用RDB快照" class="headerlink" title="1.5 禁用RDB快照"></a>1.5 禁用RDB快照</h4><p><code>redis-cli config set save &quot;&quot;</code>：将save的值设置为空，即禁用了快照功能。</p><blockquote><p>在redis客户端则直接执行config set save “”即可。</p></blockquote><hr><hr><h3 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2. AOF"></a>2. AOF</h3><blockquote><p>Append Only File缩写。<code>记录</code>每次对服务器的<code>写操作</code>，当服务器重启的时候会<code>重新执行这些命令</code>来恢复原始的数据。</p></blockquote><h4 id="2-1-AOF优缺点"><a href="#2-1-AOF优缺点" class="headerlink" title="2.1 AOF优缺点"></a>2.1 AOF优缺点</h4><ul><li><strong>AOF优点：</strong><ul><li>使用AOF 会让Redis更加耐久：可以使用不同的写回(fsync)策略：no、everysec、always。使用默认的everysec策略，Redis的性能依然很好(fsync是由后台线程进行处理的，主线程会尽力处理客户端请求)，一旦出现故障，<code>最多丢失1秒</code>的数据。</li><li>AOF文件是一个<code>只进行追加</code>的日志文件，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，也也可使用redis-check-aof工具修复这些问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行<code>重写</code>： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 如果不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li></ul></li><li><strong>AOF缺点：</strong><ul><li>对于相同的数据集来说，AOF 文件的<code>体积</code>通常要<code>大</code>于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会<code>慢</code>于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入时，RDB 可以提供更有保证的最大延迟时间。</li></ul></li></ul><h4 id="2-2-AOF配置"><a href="#2-2-AOF配置" class="headerlink" title="2.2 AOF配置"></a>2.2 AOF配置</h4><ul><li><p>开启AOF</p><blockquote><p>AOF默认是关闭的，需要将配置文件中appendonly设置为yes。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_025125.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_025125.png" alt="2023-04-12_025125"></a></p></li><li><p>配置aof文件保存路径</p><blockquote><p>aof文件的保存路径和rdb的保存路径是同一个，只不过AOF会在该路径下创建一个appendonlydir文件夹，然后将aof文件保存在该文件夹下。<code>Redis7</code>的aof文件分为三个文件： <code>appendonly.aof.1.base.rdb</code> <code>基本</code>文件：存储aof<strong>重写后的数据</strong> <code>appendonly.aof.1.incre.aof</code> <code>追加</code>文件：存储aof<strong>追加的数据</strong>，达到一定大小后触发AOF重写。 <code>appendonly.aof.manifest</code> <code>清单</code>文件：<strong>追踪管理</strong>aof。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_034032.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_034032.png" alt="2023-04-12_034032"></a></p></li><li><p>修改aof文件名和目录名</p><blockquote><p>生成的aof目录名默认为appendonlydir，文件名默认为appendonly.aof，可以在配置文件中修改。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/image-20230412032737462.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230412032737462.png" alt="image-20230412032737462"></a></p></li></ul><h4 id="2-3-三种写回策略"><a href="#2-3-三种写回策略" class="headerlink" title="2.3 三种写回策略"></a>2.3 三种写回策略</h4><p> <strong>AOF有三种写回策略</strong>：</p><ul><li><strong>Always</strong>：同步写回，每个写命令执行完立刻同步地将日志写入磁盘。</li><li><strong>Everysec</strong>：每秒写回，每个写命令执行完，先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区的内容写入磁盘。</li><li><strong>No</strong>：操作系统控制的写回，每个写命令执行完，先把日志写到AOF的内存缓冲区，由操作系统决定何时将缓冲区内容写入磁盘。</li></ul><table><thead><tr><th>配置项</th><th>写回时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Always</td><td><code>同步</code>写回</td><td>可靠性高，数据基本不丢失</td><td>每个写命令都要同步记录，<code>性能影响</code>较大</td></tr><tr><td>Everysec</td><td><code>每秒</code>写回（默认）</td><td>性能适中</td><td>宕机时<code>丢失一秒</code>内的数据</td></tr><tr><td>No</td><td>操作系统<code>控制</code>的写回</td><td>性能好</td><td>宕机时<code>丢失</code>数据<code>较多</code></td></tr></tbody></table><h4 id="2-4-AOF的恢复和修复"><a href="#2-4-AOF的恢复和修复" class="headerlink" title="2.4 AOF的恢复和修复"></a>2.4 AOF的恢复和修复</h4><ul><li><p>AOF文件数据恢复</p><blockquote><p>在同时开启RDB和AOF持久化时，重启redis服务只会加载aof文件，不会加载rdb文件，即使启动时没有appendonlydir目录，也会创建一个新的appendonlydir目录。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_050612.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_050612.png" alt="2023-04-12_050612"></a></p></li><li><p>AOF文件数据修复</p><blockquote><p>在开启了AOF后，当AOF文件出现异常时，redis服务无法正常启动。可以使用<code>redis-check-aof --fix 文件名</code>命令修复文件。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_053017.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_053017.png" alt="2023-04-12_053017"></a></p></li><li><p>AOF紧急恢复</p><blockquote><p>如果误执行了FLUSHALL操作，先停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。因为FLUSHALL或者FLUSHDB也是写命令，会被追加到aof文件中。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_060804.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_060804.png" alt="2023-04-12_060804"></a></p></li></ul><h4 id="2-5-触发AOF日志重写"><a href="#2-5-触发AOF日志重写" class="headerlink" title="2.5 触发AOF日志重写"></a>2.5 触发AOF日志重写</h4><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。</p><p>举个例子， 如果对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要记录100 条记录。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p><p>为了处理这种情况， Redis 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建，即自动执行BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4后则可以自动触发 AOF 重写。</p><h5 id="2-5-1-自动触发"><a href="#2-5-1-自动触发" class="headerlink" title="2.5.1 自动触发"></a>2.5.1 自动触发</h5><blockquote><p>自动触发需要满足配置文件中的设置，官方默认设置是： <code>auto-aof-rewrite-percentage 100</code>：根据上次重写后的aof大小，判断当前aof大小是不是增长了1倍。100%表示一倍。 <code>auto-aof-rewrite-min-size 64mb</code>：重写时满足的文件大小，即incr.aof文件超过了64兆才会重写。</p><p>注意同时满足这两个条件才会触发。</p></blockquote><p>下面将auto-aof-rewrite-min-size改为1kb，测试AOF日志重写</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_071956.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_071956.png" alt="2023-04-12_071956"></a></p><p>rdb文件的内容是无法查看的，所以还是无法确定重写后的数据是否保存到了base.rdb文件中，可以先将<code>aof-use-rdb-preamble</code>设置为no，表示禁用aof+rdb混合模式，删除appendonlydir目录然后重启redis服务，这样就不会生成base.rdb文件，而是生成base.aof文件，重复上面的写操作，最后查看aof文件内容。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_073207.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_073207.png" alt="2023-04-12_073207"></a></p><p>可以看到，重写的数据确实写入了base文件，并且base.rdb文件大小比base.aof文件大小小得多，所以通常建议开启aof+rdb混合模式。</p><h5 id="2-5-2-手动触发"><a href="#2-5-2-手动触发" class="headerlink" title="2.5.2 手动触发"></a>2.5.2 手动触发</h5><blockquote><p>执行命令<code>BGREWRITEAOF</code>即可执行AOF重写。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-12_074803.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-12_074803.png" alt="2023-04-12_074803"></a></p><h4 id="2-6-AOF工作流程"><a href="#2-6-AOF工作流程" class="headerlink" title="2.6 AOF工作流程"></a>2.6 AOF工作流程</h4><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/aof%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/aof%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="aof工作流程"></a></p><p>①Client作为命令的来源，会有多个源头以及源源不断的请求命令。</p><p>②在这些命令到达Redis Server 以后并不是直接写入AOF文件，会将其这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些<code>命令达到一定量</code>以后再<code>写入</code>磁盘，避免频繁的磁盘IO操作。</p><p>③AOF缓冲会根据AOF缓冲区同步文件的<code>三种写回策略</code>将命令<code>写入</code>磁盘上的<code>AOF文件</code>。</p><p>④随着写入AOF内容的增加为<code>避免文件膨胀</code>，会根据规则进行<code>命令的合并</code>(又称AOF重写)，从而起到AOF<code>文件压缩</code>的目的。</p><p>⑤当Redis Server 服务器重启的时候会<code>从AOF文件载入数据</code>。</p><h4 id="2-7-AOF重写原理"><a href="#2-7-AOF重写原理" class="headerlink" title="2.7 AOF重写原理"></a>2.7 AOF重写原理</h4><ol><li>在重写开始前，redis会fork一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li><li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</li><li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</li><li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中。</li><li>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</li></ol><h3 id="3-AOF-RDB混合模式"><a href="#3-AOF-RDB混合模式" class="headerlink" title="3. AOF+RDB混合模式"></a>3. AOF+RDB混合模式</h3><p>首先开启AOF：<code>appendonly yes</code>，默认是关闭的。</p><p>开启AOF+RDB混合模式：<code>aof-use-rdb-preamble yes</code>，默认是开启的。</p><p>同时开启AOF和RDB持久化，当Redis重启时会<code>优先加载AOF</code>文件来恢复原始的数据，因为在通常情况下，AOF保存的数据集要比RDB文件保存的数据集要<code>完整</code>。</p><p>在持久化时，<code>先使用RDB进行快照存储</code>，然后使用AOF持久化记录所有写的操作，当重写策略满足或者手动触发<code>重写</code>的时候，将<code>最新的数据存储为新的RDB记录</code>。这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据的完整性，又提高了恢复数据的性能</p><h3 id="4-纯缓存模式"><a href="#4-纯缓存模式" class="headerlink" title="4. 纯缓存模式"></a>4. 纯缓存模式</h3><p>纯缓存模式即同时关闭AOF和RDB，这样可以<code>最大化</code>redis的<code>读写性能</code>，但无法保证数据的安全性。禁用了自动，手动依然可以。</p><p>关闭RDB：修改配置文件<code>save &quot;&quot;</code></p><blockquote><p>禁用RDB持久化模式，仍然可以使用命令save、bgsave生成rdb文件。</p></blockquote><p>关闭AOF：修改配置文件<code>appendonly no</code></p><blockquote><p>禁用AOF持久化模式，仍然可以使用命令bgrewriteaof生成aof文件。</p></blockquote><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务（Transaction）是<code>一组</code> Redis 命令的集合，这些命令被当作一个整体，按顺序地<code>串行化执行</code>，而不会被其他命令插入。</p><p>Redis 事务使用 MULTI、EXEC、WATCH、DISCARD 和 UNWATCH 这些命令来实现。</p><hr><h3 id="1-Redis事务特性"><a href="#1-Redis事务特性" class="headerlink" title="1. Redis事务特性"></a>1. Redis事务特性</h3><ul><li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，<code>不会被其他客户端发送来的命令请求所打断</code>。</li><li>不保证原子性：Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，<code>没有</code>执行到一半进行<code>回滚</code>的能力。</li><li>排他性：Redis会<code>保证</code>一个事务内的命令<code>依次</code>执行，不会被其他命令插入。</li></ul><h3 id="2-Redis事务命令"><a href="#2-Redis事务命令" class="headerlink" title="2. Redis事务命令"></a>2. Redis事务命令</h3><blockquote><p><code>MULTI</code>：开启事务</p><p><code>EXEC</code>：执行事务</p><p><code>DISCARD</code>：取消事务</p><p><code>WATCH key [key ...]</code>：监控指定的key</p><p><code>UNWATCH </code>：取消监控。</p></blockquote><h4 id="MULTI"><a href="#MULTI" class="headerlink" title="MULTI"></a>MULTI</h4><blockquote><p>标记一个事务块的开始。执行的命令都会放到一个队列中，通过EXEC命令统一执行。</p></blockquote><h4 id="EXEC"><a href="#EXEC" class="headerlink" title="EXEC"></a>EXEC</h4><blockquote><p>执行事务队列中的命令。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_005226.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_005226.png" alt="2023-04-13_005226"></a></p><h4 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a>DISCARD</h4><blockquote><p>放弃事务。在开启了事务后，若不想执行命令了，可以通过DISCARD命令来取消事务。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_010054.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_010054.png" alt="2023-04-13_010054"></a></p><h4 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h4><blockquote><p>监控指定的key的变化，要先开启监控，再开启事务。若监控的数据被篡改了，则事务中无法再对其修改，会返回nil。</p><p>执行完EXEC命令后，之前加的监控都会失效。</p><p>redis使用watch来提供乐观锁，类似于<code>CAS</code>(Check and Set)。</p><p>乐观锁(Optimistic Lock)， 顾名思义就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。如果有则取消当前操作让他人操作生效。乐观锁策略：提交版本要比当前记录版本高。</p><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_014123.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_014123.png" alt="2023-04-13_014123"></a></p><h4 id="UNWATCH"><a href="#UNWATCH" class="headerlink" title="UNWATCH"></a>UNWATCH</h4><blockquote><p>取消监控。在对某个key监控后，已经发现了它被篡改过了，可以使用unwatch命令取消对该key的监控。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_015330.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_015330.png" alt="2023-04-13_015330"></a></p><h3 id="3-不保证原子性"><a href="#3-不保证原子性" class="headerlink" title="3. 不保证原子性"></a>3. 不保证原子性</h3><h4 id="”全体连坐“"><a href="#”全体连坐“" class="headerlink" title="”全体连坐“"></a>”全体连坐“</h4><blockquote><p>要么都执行，要么都不执行。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_021448.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_021448.png" alt="2023-04-13_021448"></a></p><h4 id="“冤头债主”"><a href="#“冤头债主”" class="headerlink" title="“冤头债主”"></a>“冤头债主”</h4><blockquote><p>错误的命令报错归报错，正确的命令依旧执行，即使在错误命令之后也会执行。<code>因为放入队列的语句只进行语法检查</code></p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_020726.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_020726.png" alt="2023-04-13_020726"></a></p><h3 id="4-事务执行流程"><a href="#4-事务执行流程" class="headerlink" title="4. 事务执行流程"></a>4. 事务执行流程</h3><p> （1）开启：以MULTI命令开启一个事务</p><p> （2）入队：将多个命令假如到事务队列中，接到这些命令并不会立即执行。</p><p> （3）执行：由EXEC命令执行事务队列中的命令。</p><h2 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h2><p>Redis 管道（Pipeline）是一种在客户端和 Redis 服务器之间建立的双向通道，它可以让客户端在一次请求中发送多个命令并一次性接收多个命令的响应结果。通过使用 Redis 管道，客户端可以减少网络通信的次数，从而提高 Redis 的吞吐量和性能。</p><p>在传统的 Redis 操作中，每个命令都需要通过网络发送到 Redis 服务器，然后等待 Redis 服务器返回响应结果后再进行下一个命令的操作，这样就会产生大量的<code>网络通信开销</code>。而使用 Redis 管道，客户端可以将<code>多个命令一次性发送</code>到 Redis 服务器，然后<code>一次性接收所有命令的响应结果</code>，从而减少网络通信的次数和开销。</p><hr><h3 id="1-pipeline的使用"><a href="#1-pipeline的使用" class="headerlink" title="1. pipeline的使用"></a>1. pipeline的使用</h3><blockquote><p>首先创建一个文件，写入需要执行的命令集。 在Linux终端使用<code>cat cmd.txt | redis-cli -a 123456 --pipe</code>命令将命令集传输到服务器。 (管道符”|“表示将前面命令的结果集作为参数传输给后面的命令)</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_030844.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_030844.png" alt="2023-04-13_030844"></a></p><h3 id="2-Pipeline小总结"><a href="#2-Pipeline小总结" class="headerlink" title="2. Pipeline小总结"></a>2. Pipeline小总结</h3><ul><li>Pipeline与原生批量命令对比：<ul><li>原生批量命令（例如mset、mget）具有原子性，pipeline是非原子性。</li><li>原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令。</li><li>原生批命令是redis服务端实现，而pipeline需要redis服务端和客户端共同完成。</li></ul></li><li>Pipeline与事务对比：<ul><li>事务具有原子性，<code>管道不具有原子性</code>。</li><li>管道一次性将命令发送给服务器，事务是一条一条的发，事务只有在接收到EXEC命令后才会执行。</li><li><code>执行事务时会阻塞其他命令的执行，而执行管道中的命令不会</code>。</li></ul></li><li>使用Pipeline注意事项：<ul><li>pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，还会继续执行后续的指令。</li><li>使用pipeline传输的<code>命令也不能太多</code>，如果数据量大客户端的阻塞时间可能会过久，同时服务端此时也被迫回复一个队列答复，占用很多内存。</li></ul></li></ul><h2 id="Redis发布和订阅-了解"><a href="#Redis发布和订阅-了解" class="headerlink" title="Redis发布和订阅(了解)"></a>Redis发布和订阅(了解)</h2><p>Redis 发布和订阅（Publish&#x2F;Subscribe，简称 Pub&#x2F;Sub）是一种消息传递模式，用于在 Redis 中实现消息的发布和订阅。</p><p>在 Redis 中，发布者（Publisher）可以将消息发送到一个或多个频道（Channel），订阅者（Subscriber）可以订阅一个或多个频道，以接收发布者发送的消息。当发布者在某个频道上发布一条消息时，所有订阅该频道的订阅者都会收到这条消息。</p><p>Redis Pub&#x2F;Sub 是基于消息传递的异步通信模型，可以用于构建实时系统、聊天室、实时广播等应用场景。</p><hr><h3 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h3><h4 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h4><p>**<code>SUBSCRIBE channel [channel ...]</code>**：订阅一个或多个频道</p><blockquote><p>一旦客户进入了订阅状态，客户端就只能接受订阅相关的命令SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE和PUNSUBSCRIBE，除了这些命令，其他命令一律失效。按Ctrl+C结束订阅状态。</p><p>返回值：发布类型、频道名称、第几个频道</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_215044.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_215044.png" alt="2023-04-13_215044"></a></p><h4 id="PUBLISH"><a href="#PUBLISH" class="headerlink" title="PUBLISH"></a>PUBLISH</h4><p>**<code>PUBLISH channel message</code>**：发布消息到指定频道。</p><blockquote><p>返回值为收到消息的客户端数量。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_221127.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_221127.png" alt="2023-04-13_221127"></a></p><h4 id="PSUBSCRIBE"><a href="#PSUBSCRIBE" class="headerlink" title="PSUBSCRIBE"></a>PSUBSCRIBE</h4><p>**<code>PSUBSCRIBE pattern [pattern ...]</code>**：按照匹配模式批量订阅。</p><blockquote><p>支持的模式有：?表示任意一个字符；<em>表示任意数量的任意字符；[]表示中括号中的指定字符。比如： h?llo：可以匹配hallo、hbllo、hello… h</em>llo：可以匹配hello、heeello、habcdello… h[abc]llo：只能匹配hallo、hbllo、hcllo</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_224853.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_224853.png" alt="2023-04-13_224853"></a></p><h4 id="PUBSUB"><a href="#PUBSUB" class="headerlink" title="PUBSUB"></a>PUBSUB</h4><p>PUBSUB 是自省命令，能够检测PUB&#x2F;SUB子系统的状态。</p><p>**<code>PUBSUB CHANNELS [pattern] </code>**：返回当前活跃的频道。</p><blockquote><p>只会统计使用SUBSCRIBE订阅的频道。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_230814.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_230814.png" alt="2023-04-13_230814"></a></p><p>**<code>PUBSUB NUMSUB channel [channel ...]</code>**：返回指定频道订阅者的个数。</p><blockquote><p>只会统计使用SUBSCRIBE订阅的订阅者个数。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-13_231329.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-13_231329.png" alt="2023-04-13_231329"></a></p><p>**<code>PUBSUB UNMPAT</code>**：返回订阅模式(PSUBSCRIBE)的数量。</p><blockquote><p>这个命令返回的不是订阅模式的订阅者数量， 而是所有Redis客户端(订阅者)订阅的所有模式的数量总和。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBSUB NUMPAT</span><br><span class="line">(integer) 2# 包括了客户端1，客户端2，客户端3的订阅模式的数量</span><br></pre></td></tr></table></figure><h4 id="UNSUBSCRIBE"><a href="#UNSUBSCRIBE" class="headerlink" title="UNSUBSCRIBE"></a>UNSUBSCRIBE</h4><p>**<code>UNSUBSCRIBE channel [channel ...]</code>**：指示客户端退订指定频道，若没有指定频道则退订所有频道。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; UNSUBSCRIBE c2# 退定频道c1</span><br><span class="line">1) &quot;unsubscribe&quot;</span><br><span class="line">2) &quot;c1&quot;</span><br><span class="line">3) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt; UNSUBSCRIBE# 退订所有频道</span><br><span class="line">1) &quot;unsubscribe&quot;</span><br><span class="line">2) (nil)</span><br><span class="line">3) (integer) 0</span><br></pre></td></tr></table></figure><h4 id="PUNSUBSCRIBE"><a href="#PUNSUBSCRIBE" class="headerlink" title="PUNSUBSCRIBE"></a>PUNSUBSCRIBE</h4><p>**<code>PUNSUBSCRIBE pattern [pattern ...]</code>**：指示客户端退订指定模式，若没有提供模式则退定所有模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUNSUBSCRIBE c*# 退定订阅模式c*</span><br><span class="line">1) &quot;punsubscribe&quot;</span><br><span class="line">2) &quot;c*&quot;</span><br><span class="line">3) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt; PUNSUBSCRIBE# 退订所有订阅模式</span><br><span class="line">1) &quot;punsubscribe&quot;</span><br><span class="line">2) (nil)</span><br><span class="line">3) (integer) 0</span><br></pre></td></tr></table></figure><h3 id="2-小总结"><a href="#2-小总结" class="headerlink" title="2. 小总结"></a>2. 小总结</h3><ul><li>发布的<code>消息</code>在Redis系统<code>不能持久化</code>，因此必须先执行订阅，再等待消息发布，如果先发布了消息且该消息没有订阅者接收，那么该消息被直接丢弃。</li><li>消息只管发送，对于发布者而言消息是即发即失的，也<code>没有ACK机制</code>，无法保证消息是否消费成功。</li><li>Redis5.0新增了Stream数据结构，不但支持多播，还支持数据持久化，比Pub&#x2F;Sub更加强大。</li></ul><h2 id="Redis复制"><a href="#Redis复制" class="headerlink" title="Redis复制"></a>Redis复制</h2><p>Redis 复制（Replication）是 Redis 的一项核心功能，用于将一个 Redis 数据库的所有数据复制到另一个 Redis 实例上。Redis 复制可以提高系统的可用性、可靠性和扩展性，使得在发生故障时可以快速地恢复数据。</p><p>Redis 复制支持<code>主从复制</code>和<code>从从复制</code>两种方式，可以根据实际情况选择不同的方式来部署和管理 Redis 实例。<code>实现读写分离，就是主机复制写，从机负责读</code></p><ul><li><p><strong>主从复制</strong></p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_001017.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_001017.png" alt="2023-04-15_001017"></a></p></li><li><p><strong>从从复制</strong></p></li></ul><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_001151.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_001151.png" alt="2023-04-15_001151"></a></p><hr><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h3><p>（1）克隆两个虚拟机，一主二仆，Redis设主节点，Redis1和Redis2设从节点。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_052056.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_052056.png" alt="2023-04-14_052056"></a></p><p>（2）配置网络IP：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_055012.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_055012.png" alt="2023-04-14_055012"></a></p><p>（3）关闭防火墙：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_202754.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_202754.png" alt="2023-04-15_202754"></a></p><p>（4）修改redis.conf配置文件</p><ul><li><p><strong>基础配置</strong></p><ul><li>开启后台运行：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053032.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053032.png" alt="2023-04-14_053032"></a></li><li>注释bind 127.0.0.1：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053304.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053304.png" alt="2023-04-14_053304"></a></li><li>关闭保护模式：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053407.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053407.png" alt="2023-04-14_053407"></a></li><li>指定端口号：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053526.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053526.png" alt="2023-04-14_053526"></a></li><li>持久化文件保存目录：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_053736.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_053736.png" alt="2023-04-14_053736"></a></li><li>修改持久化文件名：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_055701.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_055701.png" alt="2023-04-14_055701"></a></li><li>设置日志文件名：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_054025.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054025.png" alt="2023-04-14_054025"></a></li><li>配置密码：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_054232.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054232.png" alt="2023-04-14_054232"></a></li></ul></li><li><p><strong>主要配置</strong></p><blockquote><p>”配从不配主“： 在从节点的redis.conf文件配置主节点的ip和端口号：<code>replicaof 主节点IP 主节点Redis服务端口号</code> 在从节点的redis.conf文件配置连接主节点Redis服务的密码：<code>masterauth 密码</code></p></blockquote><ul><li>配置从节点访问的主节点：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_054622.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054622.png" alt="2023-04-14_054622"></a></li><li>配置从节点访问的主节点的密码：<a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_054759.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_054759.png" alt="2023-04-14_054759"></a></li></ul></li></ul><h3 id="2-基本命令"><a href="#2-基本命令" class="headerlink" title="2. 基本命令"></a>2. 基本命令</h3><p>从节点配置了需要连接的主节点后，打开Redis客户端即可自动连接到主节点。并且开始同步主节点的数据。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_113140.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_113140.png" alt="2023-04-14_113140"></a></p><p>**<code>INFO REPLICATION</code>**：查看主从关系和配置信息</p><ul><li>查看主节点信息</li></ul><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_105932.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_105932.png" alt="2023-04-14_105932"></a></p><ul><li>查看从节点信息</li></ul><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_110313.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_110313.png" alt="2023-04-14_110313"></a></p><p>**<code>replicaof 主节点IP 主节点端口</code>**：配置需要连接的主节点IP和端口。一般写入进redis.conf文件中</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_111840.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_111840.png" alt="2023-04-14_111840"></a></p><p>**<code>slaveof 主节点IP 主节点端口</code>**：临时更换需要连接的主节点IP和端口。</p><blockquote><p>这是一个临时的主从关系，每次与主节点断 开后都需要重新配置。</p><p>在运行期间修改slave节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原数据库的同步关系，开始和新配置的主数据库同步，并且清除原有的数据。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_113853.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_113853.png" alt="2023-04-14_113853"></a></p><p>将从节点redis2的追随的主节点更改为redis1后，查看redis1的信息：是redis的从节点，也是redis2的主节点。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_114241.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_114241.png" alt="2023-04-14_114241"></a></p><p>**<code>slaveof no one</code>**：停止当前从节点与主节点的的数据同步。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_221538.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_221538.png" alt="2023-04-14_221538"></a></p><h3 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h3><ul><li><p>slave可以执行写命令吗？</p><blockquote><p>slave不可以执行写命令。<code>master负责写命令，slave负责读命令，当然master也可以读命令</code>。</p><p>即使slave是另一台slave的master，也不能执行写命令。 </p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_223633.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_223633.png" alt="2023-04-14_223633"></a></p></li><li><p>slave是从头开始复制还是从切入点开始复制?</p><blockquote><p>在 Redis 复制中，从节点（Slave）可以选择从头开始复制或者从切入点开始复制。</p><p>当从节点第一次连接主节点时，如果主节点没有持久化数据，从节点将从头开始复制。即主节点会将自己的全部数据发送给从节点，从节点将接收并保存全部数据。</p><p>当从节点与主节点已经建立了连接，并且已经有了初始数据同步，如果从节点断开与主节点的连接后重新连接，从节点可以选择从上次同步的位置（复制偏移量）继续同步数据，这样可以避免从头开始复制所带来的性能影响和数据冗余。 （master会检查backlog里面的offset，master和slave都会保存一个复制的offset和一个masterId）</p><p>需要注意的是，如果从节点断开与主节点的连接时间过长，主节点可能已经自动执行了 BGSAVE 命令，生成了新的 RDB 文件，此时从节点需要从头开始复制。此外，如果从节点的内存不足，也可能需要从头开始复制，以避免内存溢出。</p><p>比如master写到k3，slave启动后会同步k3及之前的数据，然后跟随master同步数据。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-14_235542.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-14_235542.png" alt="2023-04-14_235542"></a></p></li><li><p>主节点SHUTDOWN后，从节点会上位吗？</p><blockquote><p>主节点关闭后，从节点不会变成主节点，它们会<code>等待主节点重新启动</code>，但是从<code>节点的数据可以正常读取</code>。</p><p>主节点重启后，主从关系依旧存在。</p></blockquote></li></ul><h3 id="4-Redis复制流程"><a href="#4-Redis复制流程" class="headerlink" title="4. Redis复制流程"></a>4. Redis复制流程</h3><p>（1）从节点向主节点发送 SYNC 命令，请求<code>全量复制</code>。</p><p>（2）主节点接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件，并在生成过程中记录所有执行的写命令。</p><p>（3）主节点在 BGSAVE 命令执行完毕后，将<code>生成的 RDB 文件发送给从节点</code>，同时将在执行 BGSAVE 命令期间记录的<code>写命令发送给从节点</code>，让从节点进行执行。</p><p>（4）从节点接收到主节点发送的 RDB 文件和写命令，并执行相应的操作来保持与主节点的数据一致。</p><p>（5）从节点<code>持续监听</code>主节点发来的新命令，并将其执行，以保持与主节点的数据同步。</p><p>（6）为了保持主节点和从节点之间的通信，<code>master</code>会发出<code>PING包</code>的周期默认是10秒：<code>repl-ping-replica-period 10</code>（在661行）</p><p>（6）当主节点发生故障时，从节点会尝试与其他主节点建立连接，并<code>选举出一个新的主节点</code>，从而成为新的从节点，保证系统的可用性 和可靠性。</p><blockquote><p>需要注意的是，Redis 复制是异步的，因此从节点可能存在数据不一致的情况。为了避免数据不一致，可以设置 Redis 的<code>复制偏移量</code>（replication offset），当从节点与主节点<code>连接断开</code>后，从节点可以通过该偏移量<code>快速地同步</code>数据。<code>类似断点续传</code></p></blockquote><h3 id="5-Redis复制的缺点"><a href="#5-Redis复制的缺点" class="headerlink" title="5. Redis复制的缺点"></a>5. Redis复制的缺点</h3><p>（1）<em>数据同步延迟</em>：由于 Redis 复制是异步的，从节点的数据可能会与主节点存在一定的延迟，因此从节点可能无法实时获取到最新的 数据。</p><p>（2）<em>单点故障</em>：当主节点发生故障时，需要手动进行故障转移或者使用集群来保证系统的可用性。</p><p>（3）<em>网络通信问题</em>：当网络出现故障或者通信延迟过高时，复制的效率会受到影响，从节点可能无法及时接收到主节点发送的数据。</p><p>（4）<em>内存消耗问题</em>：当从节点处理不过来主节点发送过来的写命令时，从节点会自动触发执行全量复制，这会导致从节点内存消耗变大</p><p>（5）<em>数据安全问题</em>：当主节点的数据被误删或者篡改时，从节点也会受到影响，因此需要采取一定的措施来保证数据的安全性。</p><blockquote><p>需要注意的是，这些缺点并不是 Redis 复制本身的问题，而是分布式系统中常见的问题，需要根据实际情况进行综合考虑和处理。</p></blockquote><h2 id="Redis哨兵-Sentinel"><a href="#Redis哨兵-Sentinel" class="headerlink" title="Redis哨兵(Sentinel)"></a>Redis哨兵(Sentinel)</h2><p>Redis Sentinel（哨兵）是 Redis 的高可用性解决方案之一，它可以用于监控和管理 Redis 主从复制集群，并在主节点发生故障时自动将从节点升级为新的主节点，从而保证系统的高可用性和可靠性。</p><p>Redis Sentinel 的主要功能如下：</p><ol><li>监控 Redis 主节点和从节点的状态，包括节点的可用性、延迟等情况。</li><li>自动发现和识别 Redis 主从复制集群的拓扑结构。</li><li>在主节点发生故障时，自动将从节点升级为新的主节点，并将其他从节点重新连接到新的主节点。</li><li>支持 Redis 集群的自动故障转移、故障恢复和配置管理等功能。</li><li>提供监控和管理 Redis 集群的 API 和命令行工具。</li></ol><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/sentinel.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/sentinel.png" alt="sentinel"></a></p><hr><h3 id="1-环境配置-1"><a href="#1-环境配置-1" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h3><p><strong>（1）配置三个哨兵实例</strong></p><blockquote><p>三个哨兵实例需要三台虚拟机，考虑到机器性能有限，这里将三个哨兵实例配置到一台虚拟机上(这里配置到主节点的那台虚拟机)，配置三份不同的哨兵配置文件即可：sentinel26379.conf、sentinel26380.conf、sentinel26381.conf，将它们存放到&#x2F;myredis下。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_030538.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_030538.png" alt="2023-04-15_030538"></a></p><p><strong>（2）修改哨兵配置文件的内容</strong></p><ul><li><p><strong>基础配置</strong></p><ul><li>关闭保护模式：<code>protected-mode no</code></li><li>开启后台运行：<code>daemonize yes</code></li><li>配置哨兵服务端口号：<code>port 26379</code> （三个文件要不一样）</li><li>日志文件路径：<code>logfile &quot;/myredis/sentinel26379.log&quot;</code></li><li>pid文件路径：<code>pidfile /var/run/redis-sentinel26379.pid</code></li><li>工作目录：<code>dir /myredis</code></li></ul></li><li><p><strong>主要配置</strong></p><ul><li><p>设置要监控的master：**<code>master monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code>**</p><blockquote><p>master-name：给master取的名字。</p><p>quorum：同意故障迁移的法定票数。即表示有几个哨兵认可主观下线。达到一定票数后认定为客观下线(宕机、不可用)</p></blockquote></li><li><p>配置连接master服务的密码：**<code>sentinel-auth-pass &lt;master-name&gt; &lt;password&gt;</code>**</p></li></ul></li><li><p><strong>其他配置</strong>（使用默认即可）</p><ul><li><p><code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</code></p><blockquote><p>指定多少毫秒之后，主节点没有应答哨兵，此时哨兵主观上认为主节点下线</p></blockquote></li><li><p><code>sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;</code></p><blockquote><p>表示允许并行同步的slave个数，当master挂了后，哨兵会选出新的master，剩余的slave会向新的master发起同步数据</p></blockquote></li><li><p><code>sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</code></p><blockquote><p>故障转移的超时时间，进行故障转移时，如果超过设置的毫秒，表示故障转移失败</p></blockquote></li><li><p><code>sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; </code></p><blockquote><p>配置当某一事件发生时所需要执行的脚本</p></blockquote></li><li><p><code>sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code></p><blockquote><p>客户端重新配置主节点参数脚本</p></blockquote></li></ul></li></ul><p>去除配置文件的注释，最终配置文件sentinel26379.conf的内容如下，sentinel26380.conf和sentinel26381.conf稍作修改即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">protected-mode</span> <span class="literal">no</span></span><br><span class="line"><span class="string">port</span> <span class="number">26379</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;/myredis/sentinel26379.log&quot;</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/var/run/redis-sentinel26379.pid</span></span><br><span class="line"><span class="string">dir</span> <span class="string">/myredis</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">192.168</span><span class="number">.101</span><span class="number">.110</span> <span class="number">6379 </span><span class="number">2</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">auth-pass</span> <span class="string">mymaster</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_035110.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_035110.png" alt="2023-04-15_035110"></a></p><p><strong>（3）配置主节点的访问密码</strong></p><blockquote><p>主节点宕机后，哨兵会选举一个从节点作为主节点，而之前的主节点会变成从节点，所以需要配置访问新主节点的密码。</p><p>这里所有节点都设置为同一密码，方便操作。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_040008.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_040008.png" alt="2023-04-15_040008"></a></p><h3 id="2-实操演示"><a href="#2-实操演示" class="headerlink" title="2. 实操演示"></a>2. 实操演示</h3><h4 id="2-1-启动三个redis实例"><a href="#2-1-启动三个redis实例" class="headerlink" title="2.1 启动三个redis实例"></a>2.1 启动三个redis实例</h4><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_041926.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_041926.png" alt="2023-04-15_041926"></a></p><h4 id="2-2-启动三个哨兵实例"><a href="#2-2-启动三个哨兵实例" class="headerlink" title="2.2 启动三个哨兵实例"></a>2.2 启动三个哨兵实例</h4><blockquote><p>这里在redis(6379)那台机器上启动三个哨兵实例。</p><p>启动哨兵服务有两种方式：</p><ul><li>使用redis-sentinel程序启动：<code>redis-sentinel sentinel.conf</code></li><li>使用redis-server程序启动：<code>redis-server sentinel.conf --sentinel</code></li></ul></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_043016.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_043016.png" alt="2023-04-15_043016"></a></p><h4 id="2-3-测试主从复制"><a href="#2-3-测试主从复制" class="headerlink" title="2.3 测试主从复制"></a>2.3 测试主从复制</h4><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_044818.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_044818.png" alt="2023-04-15_044818"></a></p><h4 id="2-4-查看sentinel日志文件"><a href="#2-4-查看sentinel日志文件" class="headerlink" title="2.4 查看sentinel日志文件"></a>2.4 查看sentinel日志文件</h4><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_045331.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_045331.png" alt="2023-04-15_045331"></a></p><p>下面查看sentinel26379.log文件的主要内容：</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_045716.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_045716.png" alt="2023-04-15_045716"></a></p><p>新配置保存到磁盘的意思就是新配置信息写入到sentinel.conf文件中，下面查看sentinel26379.conf文件新增的内容：</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_065615.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_065615.png" alt="2023-04-15_065615"></a></p><h4 id="2-4-模拟master节点宕机"><a href="#2-4-模拟master节点宕机" class="headerlink" title="2.4 模拟master节点宕机"></a>2.4 模拟master节点宕机</h4><blockquote><p>关闭master节点后，哨兵会重新选举一个从节点作为新的主节点。</p><p>首先三个哨兵实例会投票选举一个哨兵实例作为领导者，然后由该哨兵实例来选举一个新的主节点并且进行故障迁移(failover)</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_055113.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_055113.png" alt="2023-04-15_055113"></a></p><ul><li><p>查看sentinel26379.log日志文件了解哨兵选举的过程：</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_052907.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_052907.png" alt="2023-04-15_052907"></a></p></li><li><p>查看redis(6379)实例的redis.conf文件哨兵leader新增的内容：</p><blockquote><p>redis(6379)实例由之前的主节点变成从节点</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_062500.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_062500.png" alt="2023-04-15_062500"></a></p></li><li><p>查看redis1(6380)实例的redis.conf文件哨兵leader修改的内容：</p><blockquote><p>redis1(6380)实例由之前的从节点变成主节点</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/image-20230415063454674.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/image-20230415063454674.png" alt="image-20230415063454674"></a></p></li><li><p>查看redis2(6381)实例的redis.conf文件哨兵leader修改的内容：</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_064629.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_064629.png" alt="2023-04-15_064629"></a></p></li></ul><hr><h3 id="3-哨兵选举的流程"><a href="#3-哨兵选举的流程" class="headerlink" title="3. 哨兵选举的流程"></a>3. 哨兵选举的流程</h3><ol><li><p><strong>哨兵检测到主节点不可用：当哨兵检测到主节点不可用时，会将主节点标记为下线状态(sdown)，并向其他哨兵发送通知，通知其他哨兵主节点已经下线，其他哨兵也标记主节点下线后(odown)，确定主节点不可用。</strong></p><blockquote><p><code>主观下线</code>(sdown)：指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。主观下线就是说如果服务器在<code>sentinel down-after-milliseconds</code>给定的毫秒数之内<code>没有回应PING命令或者返回一个错误消息</code>， 那么这个Sentinel会主观的(单方面的)认为这个master不可以用了。</p><p><code>客观下线</code>(odown)：客观下线需要<code>多个哨兵达成一致意见</code>才能认为主节点真正不可用。 quorum(票数)这个参数是进行客观下线的一个依据。法定人数&#x2F;法定票数(quorum)。</p></blockquote></li><li><p><strong>哨兵投票选举哨兵leader：哨兵在检测到主节点不可用后，会进入选举状态，此时哨兵将开始选举哨兵的领导者。</strong></p><blockquote><p>监视该主节点的所有哨兵都有可能被选为<code>领导者</code>，选举使用的算法是Raft算法；Raft算法的基本思路是<code>先到先得</code>：</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/%E5%93%A8%E5%85%B5%E9%80%89%E4%B8%BE.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/%E5%93%A8%E5%85%B5%E9%80%89%E4%B8%BE.png" alt="哨兵选举"></a></p></li><li><p><strong>哨兵leader开始推动故障切换流程并选举出一个新的master</strong></p><blockquote><p>在从节点中选出新的master的规则： ①redis.<code>conf</code>中<code>优先级</code>slave-priority或replica-priority高的从节点优先（数值越小优先级越高） ②<code>复制偏移量</code>(offset)<code>大</code>的从节点优先。 ③<code>Run ID最小</code>的从节点优先(按字典顺序、ASCII码值比较)，每个redis实例启动后都会随机生成一个40位的run id。</p><p>复制偏移量是一个相对值，表示已复制的字节数</p><p>Run ID是reids实例启动的标识</p></blockquote></li><li><p><strong>选举出新的master后由<code>Sentinel leader完成failover工作</code>(故障切换)</strong></p><ul><li>执行slaveof no one命令让选出来的从节点成为新的主节点，并通过slaveof命令让其他节点（包括原来的master）成为新主节点的从节点。</li><li>Sentinel leader会向被重新配置的实例发送一个 CONFIG REWRI TE 命令， 从而确保这些配置会持久化在硬盘里(写入配置文件)。</li></ul></li></ol><hr><h3 id="4-小总结"><a href="#4-小总结" class="headerlink" title="4. 小总结"></a>4. 小总结</h3><ul><li><p>哨兵实例的数量应为<code>多个</code>，哨兵本身应该集群，保证高可用</p></li><li><p>哨兵实例的个数应该为<code>奇数</code>，方便投票选出Sentinel Leader，方便raft算法执行</p></li><li><p>各个哨兵实例的<code>配置</code>应该<code>一致</code></p></li><li><p>哨兵集群+主从复制，并<code>不能保证数据零丢失</code>（引出集群cluster，集群可以解决这一问题）</p><blockquote><p><code>master宕机</code>后，哨兵需要在一定时间内<code>选出</code>新的master并执行failover操作，这段时间内<code>从节点无法写入数据</code>，造成<code>数据丢失</code>。</p></blockquote></li></ul><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>Redis 集群是 Redis 数据库的分布式解决方案，它可以将数据分散存储在多个节点上，以支持大规模数据存储和高并发访问。</p><p>Redis 集群使用的是基于槽的分区策略，即将数据分成固定数量的槽，每个槽由一个主节点和多个从节点组成。客户端请求会根据键值的哈希值被路由到对应的槽上，从而实现数据的分布式存储和访问。同时，Redis 集群还提供了多种操作槽的命令，以支持集群的管理和维护。</p><p>Redis 集群的主要特点包括：</p><ol><li>分布式存储：Redis 集群将数据分散存储在多个节点上，每个节点负责处理一部分数据，从而实现数据的分布式存储和访问。集群可以扩展到数千个节点，以支持海量数据存储和高并发访问。建议控制在1000个以内的节点数。</li><li><code>高可用性</code>：Redis 集群通过多副本机制和自动故障转移机制，保证数据的可靠性和可用性。每个节点都有多个副本，其中一个副本为主节点，负责处理客户端请求，其他副本为从节点，负责复制主节点的数据。当主节点宕机时，从节点会自动选举一个新的主节点，以保证数据的连续性和可用性。</li><li>数据<code>自动分片</code>：Redis 集群将数据自动分片存储在多个节点上，以实现数据的均衡分布和高效访问。每个节点都负责处理一部分数据，同时维护一份槽指派表，记录每个槽对应的主节点和从节点。客户端请求会根据键值的哈希值被路由到对应的槽上，从而实现数据的分布式存储和访问。</li><li>支持<code>在线扩容缩容</code>：Redis 集群支持在线添加和删除节点，以扩展或缩小集群的容量，而无需停机或数据迁移。集群会<code>自动将数据重新分片和迁移</code>，以保证数据的连续性和可用性。</li><li>负载均衡：Redis 集群通过智能路由算法，将客户端请求均匀地分发到不同的节点上，以实现负载均衡和性能优化。客户端可以通过集群模式下的代理节点（cluster-enabled proxy）进行连接，代理节点会自动将请求路由到正确的节点上。</li></ol><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/cluster.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/cluster.png" alt="cluster"></a></p><hr><h3 id="1-redis集群槽位"><a href="#1-redis集群槽位" class="headerlink" title="1. redis集群槽位"></a>1. redis集群槽位</h3><p>在 Redis 集群中，槽位（slot）是<code>将数据进行分片的基本单位</code>，也是实现数据分布式存储和访问的重要机制。Redis 集群默认将 <code>16384</code> 个槽位均分给不同的节点，<code>每个节点负责处理一部分槽位</code>，从而实现数据的分布式存储和访问。</p><p>具体来说，Redis 集群使用<code>哈希槽（hash slot）</code>的方式<code>将数据进行分片</code>，每个槽对应着一个整数编号，从 0 开始，一直到 16383。每个节点会负责处理一部分槽位，同时维护一份<code>槽指派表（slot map）</code>，记录每个槽对应的主节点和从节点。</p><p>客户端请求会&#x3D;&#x3D;根据键值的哈希值被路由到对应的槽&#x3D;&#x3D;上，从而实现数据的分布式存储和访问。具体来说，客户端会将键值的哈希值对 16384 取模，得到一个槽号，然后将请求发送到对应的槽所在的节点上。如果该节点是主节点，它会将请求处理后的结果返回给客户端；如果该节点是从节点，则会将请求转发给对应的主节点进行处理。</p><p>需要注意的是，<code>槽的数量是固定的</code>，因此如果需要扩展 Redis 集群的容量，就需要将一些<code>槽移动到新的节点上</code>，以实现数据的重新分片和迁移。Redis 集群提供了多种操作槽的命令，以支持集群的管理和维护。</p><hr><h3 id="2-redis集群分片"><a href="#2-redis集群分片" class="headerlink" title="2. redis集群分片"></a>2. redis集群分片</h3><p>在 Redis 集群中，数据分片（sharding）是将数据划分成多个部分，分别存储在不同的节点上，从而实现分布式存储和访问的基本方式。Redis 集群使用哈希槽（hash slot）的方式将数据进行分片，每个节点负责处理一部分槽位，从而实现数据的分布式存储和访问。</p><p>具体来说，Redis 集群默认将 16384 个槽位均分给不同的节点，每个节点负责处理一部分槽位，同时维护一份槽指派表（slot map），记录每个槽对应的主节点和从节点。客户端请求会根据键值的哈希值被路由到对应的槽上，从而实现数据的分布式存储和访问。</p><p>数据分片能够提高 Redis 集群的容量和可用性，减少单节点的负载压力，并支持横向扩展和动态扩容。同时，数据分片也会带来一些挑战和问题，例如数据迁移、节点失效、一致性维护等方面的问题，需要进行合理的设计和实现。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/redis%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/redis%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87.png" alt="redis集群分片"></a></p><hr><h3 id="3-redis槽位映射"><a href="#3-redis槽位映射" class="headerlink" title="3. redis槽位映射"></a>3. redis槽位映射</h3><ul><li><p><strong><code>哈希取余</code>分区</strong></p><p>哈希取余分区是一种常见的数据分区技术，它将数据划分成多个分区，并将每个分区分配给集群中的不同节点，从而实现分布式存储和访问。</p><p>在哈希取余分区中，首先根据某个键的哈希值对分区总数取模，得到该键所在的分区编号，然后将该键存储在对应的节点上。当需要访问某个键值对时，同样通过哈希值计算得到该键所在的分区编号，然后访问对应的节点，从而实现数据的分布式访问。</p><p>哈希取余分区技术简单易懂，易于实现，可以<code>较好地均衡数据在各个节点之间的分布</code>，从而提高系统的可扩展性和可用性。但是，该技术存在<code>数据倾斜和数据迁移</code>等问题。如果某个键的哈希值对分区总数取模后恰好落在某个分区上，那么该分区的负载将会比其他分区更重，可能会导致性能问题。此外，在节点的动态扩容和缩容时，会需要进行数据迁移，对系统的稳定性和性能也会带来影响。</p><p><code>在出现变动的时候，比如哈希的分母出现了变化，那么各种映射都要重新计算</code></p></li><li><p><strong><code>一致性哈希</code>算法分区</strong></p><p>一致性哈希算法（Consistent Hashing Algorithm）是一种用于分布式存储系统的数据分区技术，它可以使得数据在集群中的分布更加均匀，同时减少在数据分区发生变化时需要重新分配的数据量。</p><p>在一致性哈希算法中，所有的数据被分成一定数量的分区，<code>每个分区被映射到一个哈希环上</code>。<code>每个节点也被映射到哈希环上</code>，并负责其所在的某些分区。当需要存储一个数据时，<code>先对该数据进行哈希</code>，<code>然后将哈希值映射到哈希环上</code>，**<code>找到最近的节点</code>**，并将数据存储在该节点上。当需要读取一个数据时，也先对该数据进行哈希，并映射到哈希环上，然后从离该数据最近的节点上读取数据。</p><p>一致性哈希算法的核心思想是<code>将哈希环视为一个环形空间</code>，并将节点和数据视为该空间上的点。通过在哈希环上的均匀分布，可以使得数据在集群中的分布更加均匀。当某个节点宕机时，只会影响该节点所负责的一部分分区，不会影响整个集群，从而提高了系统的可用性和稳定性。同时，一致性哈希算法也能够自动地将数据重新映射到新的节点上，从而减少了数据的迁移量和系统的维护成本。</p><p>一致性哈希算法已经被广泛地应用于各种分布式系统中，包括缓存系统、负载均衡系统、分布式文件系统等</p><p><code>其实就是根据查询映射到环上的位置去找最近的节点映射位置</code></p><p>存在<code>数据倾斜</code>的问题，因为寻找方向是固定的，都是顺时针或者逆时针,所以会存在<code>分布不均匀</code>的情况</p><blockquote><p>一致性<code>哈希环</code></p><p>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32)，这样让它逻辑上形成了一个环形空间。</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%8E%AF.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%8E%AF.png" alt="一致性哈希环"></a></p></blockquote></li><li><p><strong>哈希槽分区</strong></p><p>哈希槽分区是 Redis 集群中常用的数据分区技术，它将整个数据集划分为固定数量的槽位（slot），然后将每个槽位分配到集群中不同的节点上，从而实现数据的分布式存储和访问。</p><p>在哈希槽分区中，每个槽位都对应着一个哈希值范围，例如 0 到 16383。当需要存储某个键值对时，先计算出该键的哈希值，然后确定该哈希值所在的槽位，最后将键值对存储在负责管理该槽位的节点上。当需要访问某个键值对时，同样先计算出该键的哈希值，然后确定该哈希值所在的槽位，最后访问负责管理该槽位的节点，从而实现数据的分布式访问。</p><p>哈希槽分区技术具有简单、可扩展性强等优点，它可以自动完成节点的动态扩容和缩容，并且在数据迁移时可以只迁移部分槽位，从而降低数据迁移的成本和风险。但是，该技术也存在一些问题，例如槽位的分配不均匀可能会导致某些节点的负载过重，从而影响系统的性能和可用性，此时可以通过手动调整槽位分配来解决这个问题。</p></li></ul><hr><h3 id="4-集群环境搭建"><a href="#4-集群环境搭建" class="headerlink" title="4. 集群环境搭建"></a>4. 集群环境搭建</h3><p><strong>（1）三主三从redis集群配置</strong></p><p>由于机器性能有限，这里只配置了三台虚拟机，一台虚拟机配置两个redis实例</p><blockquote><p>192.168.101.110 (下面简称110)配置端口为6381和6382两个实例，配置文件分别为cluster6381.conf和cluster6382.conf 192.168.101.111 (下面简称111)配置端口为6383和6384两个实例，配置文件分别为cluster6383.conf和cluster6384.conf 192.168.101.112 (下面简称112)配置端口为6385和6386两个实例，配置文件分别为cluster6385.conf和cluster6386.conf</p></blockquote><p>以实例cluster6381.conf为例，配置文件内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">port 6381</span><br><span class="line">logfile &quot;/myredis/cluster/cluster6381.log&quot;</span><br><span class="line">pidfile /myredis/ccluster6381.pid</span><br><span class="line">dir /myredis/cluster</span><br><span class="line">dbfilename dump6381.rdb</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly6381.aof&quot;</span><br><span class="line">requirepass 123456</span><br><span class="line">masterauth 123456</span><br><span class="line"> </span><br><span class="line">cluster-enabled yes# 开启集群</span><br><span class="line">cluster-config-file nodes-6381.conf# 集群生成的配置文件</span><br><span class="line">cluster-node-timeout 5000# 集群节点之间的超时时间</span><br></pre></td></tr></table></figure><p>在每台虚拟机的根目录创建<code>/myredis/cluster</code>目录，然后在该目录创建两个配置文件：</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_125434.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_125434.png" alt="2023-04-15_125434"></a></p><p>查看cluster6381.conf文件内容：</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_124752.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_124752.png" alt="2023-04-15_124752"></a></p><p><strong>（2）启动六台redis实例</strong></p><blockquote><p>启动集群实例和之前启动redis实例一样，只不过配置文件中配置了开启集群，会以集群的方式启动redis实例。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_130446.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_130446.png" alt="2023-04-15_130446"></a></p><p><strong>（3）构建主从关系</strong></p><p>使用命令构建集群间的主从关系：**<code>redis-cli -a 密码 --cluster create --cluster-replicas 1 IP:端口号 [IP:端口号]</code>**</p><blockquote><p>选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点</p><p><code>IP:端口号</code>是redis实例的地址和端口号，多个redis实例构成一个集群</p><p>主从关系是随机分配的(个人见解：一般按照输入的顺序基数位为master，偶数位为slave)，其master-slave关系是随机分配的。</p></blockquote><p>在任意一个虚拟机中执行这个命令都可以，下面在110虚拟机中执行此命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[root@redis cluster]# redis-cli -a 123456 --cluster create --cluster-replicas 1 192.168.101.110:6381 192.168.101.110:6382 192.168.101.111:6383 192.168.101.111:6384 192.168.101.112:6385 192.168.101.112:6386</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460# 1号主节点分配了0-5460的槽位</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922# 2号主节点分配了5461-10922的槽位</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383# 3号主节点分配了10923-16383的槽位</span><br><span class="line">Adding replica 192.168.101.111:6384 to 192.168.101.110:6381#111机器的6384实例同步110机器的6381实例</span><br><span class="line">Adding replica 192.168.101.112:6386 to 192.168.101.111:6383#112机器的6386实例同步111机器的6383实例</span><br><span class="line">Adding replica 192.168.101.110:6382 to 192.168.101.112:6385#110机器的6382实例同步112机器的6385实例</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381# 主节点id IP:端口号</span><br><span class="line">   slots:[0-5460] (5461 slots) master# 分配了5461个槽位</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382# 从节点id IP:端口号</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec# 从属154d23(主节点id，对应6385)</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes# 是否保存这些配置，输入yes保存</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">..</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.110:6381)</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   slots: (0 slots) slave# 从节点分配了0个槽位</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>重连6381实例再查看集群信息：<code>CLUSTER INFO</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@redis cluster]# redis-cli -a 123456 -p 6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6381&gt; CLUSTER INFO# 查看集群信息</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:3652</span><br><span class="line">cluster_stats_messages_pong_sent:3675</span><br><span class="line">cluster_stats_messages_sent:7327</span><br><span class="line">cluster_stats_messages_ping_received:3670</span><br><span class="line">cluster_stats_messages_pong_received:3652</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:7327</span><br><span class="line">total_cluster_links_buffer_limit_exceeded:0</span><br></pre></td></tr></table></figure><p>查看集群节点的状态信息：<code>CLUSTER NODES</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@redis cluster]# redis-cli -a 123456 -p 6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6381&gt; CLUSTER NODES# 查看集群节点状态信息</span><br><span class="line">e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381@16381 myself,master - 0 1681569469000 1 connected 0-5460# myself,master表示当前所在的节点，是主节点。前面的一大串是该节点的id、IP端口信息</span><br><span class="line">851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384@16384 slave e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 0 1681569472503 1 connected# 从节点851c41(6384)同步e4d44f(6381)</span><br><span class="line">1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383@16383 master - 0 1681569472000 3 connected 5461-10922</span><br><span class="line">202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382@16382 slave 154d23ad6fb321801ebe84e8066411e3f3fc05ec 0 1681569472000 5 connected</span><br><span class="line">e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386@16386 slave 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 0 1681569472503 3 connected</span><br><span class="line">154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385@16385 master - 0 1681569472604 5 connected 10923-16383</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_224005.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_224005.png" alt="2023-04-15_224005"></a></p><hr><h3 id="5-测试集群读写"><a href="#5-测试集群读写" class="headerlink" title="5. 测试集群读写"></a>5. 测试集群读写</h3><blockquote><p>每个key都有自己的哈希值，根据哈希值通过某种算法算出对应的槽位，该<code>key只能存储到该槽位所在的节点上</code>。</p><p>然而这种情况并不是我们想要的，可以在<code>连接redis客户端时</code>添加<code>-c</code>参数，这样会帮我们把数据<code>路由</code>到指定的槽位上，即使在不同的节点上也能随便存储数据。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_232003.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_232003.png" alt="2023-04-15_232003"></a></p><p>查看某个key对应的槽位值：<code>CLUSTER KEYSLOT key</code></p><blockquote><p>任何字符都有对应的哈希值，所以任何字符都能计算出对应的槽位</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_232246.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_232246.png" alt="2023-04-15_232246"></a></p><p>查看某个槽位是否被占用：<code>CLUSTER COUNTKEYSINSLOT 槽位号</code></p><blockquote><p>返回1表示该槽位被占用；返回0表示该槽位没有被占用。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_021649.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_021649.png" alt="2023-04-16_021649"></a></p><hr><h3 id="6-测试集群主从切换"><a href="#6-测试集群主从切换" class="headerlink" title="6. 测试集群主从切换"></a>6. 测试集群主从切换</h3><ul><li><p>首先查看当前节点主从关系：<code>INFO REPLICATION</code></p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-15_233204.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_233204.png" alt="2023-04-15_233204"></a></p></li><li><p>手动关闭主节点6381，查看集群节点状态</p><blockquote><p>在其他任何集群节点查看集群节点的状态都可以。</p><p>主节点宕机后，从节点会成为新的master。</p></blockquote><p><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-15_234248.png" alt="2023-04-15_234248"></p></li><li><p>重新连接节点6381，查看集群节点状态</p><blockquote><p>恢复6381节点后，该节点会变成新master的slave。</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_000001.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_000001.png" alt="2023-04-16_000001"></a></p></li><li><p>恢复6381master的身份：<code>CLUSTER FAILOVER</code></p><blockquote><p>使用<code>cluster failover</code>可以恢复发生故障前的主从关系</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_000849.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_000849.png" alt="2023-04-16_000849"></a></p></li></ul><hr><h3 id="7-redis集群扩容"><a href="#7-redis集群扩容" class="headerlink" title="7. redis集群扩容"></a>7. redis集群扩容</h3><p>在112虚拟机上新建两个redis实例6387和6388，此时112虚拟机上有4个redis实例分别是6385、6386、6387、6388</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_002143.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_002143.png" alt="2023-04-16_002143"></a></p><p>启动这两个新节点，此时它们都是master</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_002446.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_002446.png" alt="2023-04-16_002446"></a></p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_002814.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_002814.png" alt="2023-04-16_002814"></a></p><p>将6387节点作为master加入到集群中：**<code>redis-cli -a 密码 --cluster add-node IP:port IP:port</code>**</p><blockquote><p>前者<code>IP:port</code>为需要加入到集群的节点ip和端口 后者<code>IP:port</code>指集群中任一节点的ip和端口（可以理解为推荐人）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster add-node 192.168.101.112:6387 192.168.101.110:6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Adding node 192.168.101.112:6387 to cluster 192.168.101.110:6381</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.110:6381)</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">&gt;&gt;&gt; Getting functions from cluster</span><br><span class="line">&gt;&gt;&gt; Send FUNCTION LIST to 192.168.101.112:6387 to verify there is no functions in it</span><br><span class="line">&gt;&gt;&gt; Send FUNCTION RESTORE to 192.168.101.112:6387</span><br><span class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 192.168.101.112:6387 to make it join the cluster.</span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure><p>检查集群情况：**<code>redis-cli -a 密码 --cluster check IP:port</code>**</p><blockquote><p>只需要指定集群中任意一个在线的节点的地址(IP:端口号)， 就会自动找到集群中的其他节点，即可查看整个集群的信息。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@redis1 ~]# redis-cli -a 123456 --cluster check 192.168.101.110:6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">192.168.101.110:6381 (e4d44fbd...) -&gt; 2 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.101.112:6385 (154d23ad...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.101.112:6387 (b1ef21d8...) -&gt; 0 keys | 0 slots | 0 slaves.#可以看到节点6387加入了集群但是没有分配槽位</span><br><span class="line">192.168.101.111:6383 (1b9c2607...) -&gt; 1 keys | 5462 slots | 1 slaves.</span><br><span class="line">[OK] 4 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.110:6381)</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: b1ef21d88293bc1560f61a46c4fca8b601d59d60 192.168.101.112:6387</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>重新分派槽号：**<code>redis-cli -a 密码 --cluster reshard IP:port</code>**</p><blockquote><p>只需要指定集群中任意一个在线的节点的地址(IP:端口号)即可。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster reshard 192.168.101.110:6381</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.110:6381)</span><br><span class="line">M: e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6 192.168.101.110:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 154d23ad6fb321801ebe84e8066411e3f3fc05ec 192.168.101.112:6385</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: b1ef21d88293bc1560f61a46c4fca8b601d59d60 192.168.101.112:6387</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">M: 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d 192.168.101.111:6383</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e2512f82160d0e044b40dade1f6e2df7a942c83c 192.168.101.112:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1b9c2607caafa82ab53a407f4979b00c9ee1ea9d</span><br><span class="line">S: 202075b6488c250e6f8227c44b905f7781162f30 192.168.101.110:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 154d23ad6fb321801ebe84e8066411e3f3fc05ec</span><br><span class="line">S: 851c4e7c78ddfb59672dcdfae5e29a2372fdc192 192.168.101.111:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e4d44fbdc683d3882b39f7b02d5a78bc4c0b36a6</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 4096</span><br><span class="line">What is the receiving node ID? b1ef21d88293bc1560f61a46c4fca8b601d59d60# 指定一个节点id接收槽位</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  # all表示现有的三个分片平均拿出一点槽位分给新节点</span><br><span class="line">  Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type &#x27;done&#x27; once you entered all the source nodes IDs.</span><br><span class="line">Source node #1: all</span><br><span class="line"></span><br><span class="line">Ready to move 4096 slots.</span><br></pre></td></tr></table></figure><p>再次检查集群情况</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_011920.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_011920.png" alt="2023-04-16_011920"></a></p><p>为集群中新主节点添加从节点： <strong><code>redis-cli -a 密码 --cluster add-node IP:port IP:port --cluster-slave --cluster-master-id 新主节点id</code></strong></p><blockquote><p>前者<code>IP:port</code>指从节点的地址，后者<code>IP:port</code>为集群中任意一个在线节点的地址</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster add-node 192.168.101.112:6388 192.168.101.112:6387 --cluster-slave --cluster-master-id b1ef21d88293bc1560f61a46c4fca8b601d59d60</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Adding node 192.168.101.112:6388 to cluster 192.168.101.112:6387</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.101.112:6387)</span><br></pre></td></tr></table></figure><p>再次检查集群情况</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_011706.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_011706.png" alt="2023-04-16_011706"></a></p><hr><h3 id="8-redis集群缩容"><a href="#8-redis集群缩容" class="headerlink" title="8. redis集群缩容"></a>8. redis集群缩容</h3><p>首先先将从节点6388删除：**<code>redis-cli -a 密码 --cluster del-node IP:从节点端口 从节点id</code>**</p><blockquote><p>节点id可以通过检查集群情况命令查看：<code>redis-cli -a 密码 --cluster check IP:port</code> 也可以通过<code>CLUSTER NODES</code>命令查看。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster del-node 192.168.101.112:6388 8bc4986317910e2f57d67609931645b41d5a90e3# 删除6388j</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Removing node 8bc4986317910e2f57d67609931645b41d5a90e3 from cluster 192.168.101.112:6388</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER RESET SOFT to the deleted node.</span><br></pre></td></tr></table></figure><p>将主节点6387的槽号清空重新分配</p><blockquote><p>这里将清空的槽号全部分配给6381节点（当然也可以平均分配回之前的三个主节点，只不过要操作三次）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 重新分配槽号</span><br><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster reshard 192.168.101.110:6381</span><br></pre></td></tr></table></figure><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_014559.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_014559.png" alt="2023-04-16_014559"></a></p><p>移除槽位后检查集群情况</p><blockquote><p>6387节点槽位被清空，成为了6381节点的从节点</p><p>这和加入6387节点到集群时填写的集群中的<code>IP:port</code>有关（6381相当于推荐人）</p></blockquote><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_015556.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_015556.png" alt="2023-04-16_015556"></a></p><p>此时节点6387是一个从节点，将节点6387删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@redis2 cluster]# redis-cli -a 123456 --cluster del-node 192.168.101.112:6387 b1ef21d88293bc1560f61a46c4fca8b601d59d60</span><br></pre></td></tr></table></figure><p>再次检查集群情况</p><p><a href="https://github.com/loneasing/mynote/blob/master/Redis7/img/2023-04-16_020413.png"><img src="https://github.com/loneasing/mynote/raw/master/Redis7/img/2023-04-16_020413.png" alt="2023-04-16_020413"></a></p><h3 id="9-关于16384"><a href="#9-关于16384" class="headerlink" title="9. 关于16384"></a>9. 关于16384</h3><p>在 Redis 集群中，每个节点都会通过<code>发送心跳信息</code>来保持与其他节点的连接和状态同步。心跳信息通常包含了一些关键的集群信息，如节点的 IP 地址、端口号、节点角色、复制偏移量等。</p><p>心跳信息<code>包含了节点负责的槽位信息</code>，如果槽位太多，发送的就很多，16384是一个均衡后的结果。65536是CRC16的上限，可是浪费带宽，一般节点数量也不会超过1000，16834够用了</p><h3 id="10-关于强一致"><a href="#10-关于强一致" class="headerlink" title="10. 关于强一致"></a>10. 关于强一致</h3><p>Redis集群不保证强一致性，也就是在特定条件下，redis集群可能丢掉一些被系统收到的写入请求命令，也就是master写到从的时候如果断了，是无法同步过去的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA算法应用基础</title>
      <link href="/2023/06/11/JAVA%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/06/11/JAVA%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Linkedlist"><a href="#Linkedlist" class="headerlink" title="Linkedlist"></a>Linkedlist</h2><p>链表结构</p><p>LinkedList 实现了 Queue 接口，可作为队列使用。</p><p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p><p>LinkedList 实现了 Deque 接口，可作为队列使用。</p><p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   LinkedList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">   sites.add(<span class="string">&quot;队尾添加元素,返回true&quot;</span>);</span><br><span class="line">   sites.addFirst(<span class="string">&quot;队头添加元素&quot;</span>);</span><br><span class="line">   sites.addLast(<span class="string">&quot;队尾添加元素,无返回&quot;</span>);</span><br><span class="line">   sites.removeFirst(<span class="string">&quot;移除头部元素&quot;</span>);</span><br><span class="line">   sites.removeLast(<span class="string">&quot;移除尾部元素&quot;</span>);</span><br><span class="line">   sites.size()</span><br><span class="line">   sites.get(i)</span><br><span class="line">   sites.getLast()</span><br><span class="line">   <span class="keyword">for</span>(String i : sites)&#123;</span><br><span class="line">       System.out,println(i);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> T[] toArray(T[] a)返回一个由链表元素转换类型而成的数组。</span><br><span class="line">   <span class="keyword">public</span> Object[] toArray()返回一个由链表元素组成的数组。</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>链表末尾添加元素，返回是否成功，成功为 <span class="literal">true</span>，失败为 <span class="literal">false</span>。</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>向指定位置插入元素。</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection c)</span>将一个集合的所有元素添加到链表后面，返回是否成功，成功为 <span class="literal">true</span>，失败为 <span class="literal">false</span>。</span><br><span class="line">   <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>删除指定位置的元素。</span><br></pre></td></tr></table></figure><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-add.html">add()</a></td><td align="left">将元素插入到指定位置的 arraylist 中</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-addall.html">addAll()</a></td><td align="left">添加集合中的所有元素到 arraylist 中</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-clear.html">clear()</a></td><td align="left">删除 arraylist 中的所有元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-clone.html">clone()</a></td><td align="left">复制一份 arraylist</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-contains.html">contains()</a></td><td align="left">判断元素是否在 arraylist</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-get.html">get()</a></td><td align="left">通过索引值获取 arraylist 中的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-indexof.html">indexOf()</a></td><td align="left">返回 arraylist 中元素的索引值</td></tr></tbody></table><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>基础思想：以某个哨兵为基准数，将小于的元素移动至左边，大于的元素移动至右边。</p><p>然后对于两边分别设置哨兵，递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] q ,<span class="type">int</span> l ,<span class="type">int</span> r)</span>&#123;<span class="comment">// quicksort(q,0,n-1)</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span>;<span class="comment">// 终止于递归数组只有一个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> q[l+r &gt;&gt; <span class="number">1</span>];<span class="comment">// 一般取中间的某个值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l-<span class="number">1</span>,j = r+<span class="number">1</span>;<span class="comment">// 注意-1和+1，扩大范围，适应后面的++</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;<span class="comment">// 对于两边不满足条件元素的进行遍历</span></span><br><span class="line">        <span class="keyword">while</span>(q[++i] &lt; x);<span class="comment">// 找到左边大于哨兵的地址注意++在前面</span></span><br><span class="line">        <span class="keyword">while</span>(q[--j] &gt; x);<span class="comment">// 找到右边小于哨兵的地址</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;<span class="comment">// 如果仍然在寻找中，则交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> q[j];</span><br><span class="line">            q[i] = q[j];</span><br><span class="line">            q[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一遍找完</span></span><br><span class="line">    quicksort(q,l,j);</span><br><span class="line">    quicksort(q,j+<span class="number">1</span>,r);<span class="comment">// 注意+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();<span class="comment">//创建一个优先队列 </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x,y) -&gt; (y-x)); <span class="comment">// 创建一个倒序的优先队列</span></span><br></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque有三种用途：</span><br><span class="line">普通队列(一端进另一端出):</span><br><span class="line"><span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>()或<span class="type">Deque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>()</span><br><span class="line">双端队列(两端都可进出)</span><br><span class="line"><span class="type">Deque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>()</span><br><span class="line">堆栈</span><br><span class="line"><span class="type">Deque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>()</span><br></pre></td></tr></table></figure><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuilder和new String有以下区别：</p><ol><li>可变性：StringBuilder是可变的字符串，可以通过追加、插入、删除等操作修改其内容。而new String创建的字符串对象是不可变的，一旦创建后就不能被修改。</li><li>内存占用：使用StringBuilder进行字符串拼接时，会在同一个StringBuilder对象上进行操作，不会产生额外的字符串对象，从而减少了内存的占用。而使用new String进行字符串拼接时，每次拼接都会创建一个新的字符串对象，增加了内存的开销。</li><li>线程安全性：StringBuilder是非线程安全的，适用于单线程环境下的字符串操作。而String对象是不可变的，可以保证在多线程环境下的线程安全性。</li><li>性能：由于StringBuilder是可变的，不需要频繁地创建新的字符串对象，所以在进行大量字符串拼接操作时，使用StringBuilder通常比使用new String具有更好的性能。</li></ol><p>综上所述，如果需要频繁地进行字符串拼接或修改操作，建议使用StringBuilder，而如果不需要修改字符串内容或需要保证线程安全性，则可以使用new String创建不可变字符串对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">res.append(strs[i] + <span class="string">&quot; &quot;</span>)；</span><br></pre></td></tr></table></figure><h2 id="关于compareTo-函数"><a href="#关于compareTo-函数" class="headerlink" title="关于compareTo()函数"></a>关于compareTo()函数</h2><p>如果给的参数是字符串，比如比较1011和1101</p><p>根据字典顺序，字符串 “1011” 在字符串 “1101” 之前。字典顺序是通过逐个比较字符串的字符来确定的。</p><p>在比较这两个字符串时，从左到右逐个比较对应位置上的字符，直到找到第一个不相等的字符。在这个例子中，第一个字符是 “1”，在两个字符串中都存在，所以继续比较下一个字符。第二个字符是 “1”，在两个字符串中也都存在，继续比较下一个字符。第三个字符是 “0”，在两个字符串中仍然都存在，继续比较最后一个字符。第四个字符是 “1”，在两个字符串中仍然都存在。</p><p>由于在比较过程中没有找到不相等的字符，所以字符串 “1011” 在字典顺序上小于字符串 “1101”。</p><h2 id="Int转为String"><a href="#Int转为String" class="headerlink" title="Int转为String"></a>Int转为String</h2><p>两种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toString(num);</span><br></pre></td></tr></table></figure><h2 id="截取字符串、分割"><a href="#截取字符串、分割" class="headerlink" title="截取字符串、分割"></a>截取字符串、分割</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.substring(<span class="number">0</span>,<span class="number">2</span>);<span class="comment">// 截出01</span></span><br><span class="line"></span><br><span class="line">String[] str = s.trim().split(<span class="string">&quot; &quot;</span>);<span class="comment">// tirm()删除首位空格，分割字符串</span></span><br></pre></td></tr></table></figure><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>以集合的角度看待问题。</p><p>1.状态表示f(i,j)</p><p>集合：是哪个集合的内容（方案）</p><p>属性：i、j表示了什么属性最大值</p><p>2.状态计算</p><p>集合划分：也就是最后一步可以从哪些方向过去</p><h2 id="字符串转数组"><a href="#字符串转数组" class="headerlink" title="字符串转数组"></a>字符串转数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转char数组</span></span><br><span class="line"><span class="type">char</span> arr[] = str.toCharArray();</span><br><span class="line"><span class="comment">// 转string数组</span></span><br><span class="line">String arr[] = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">// 直接获取第i位的字符</span></span><br><span class="line">tmp  = str.charAt(i);</span><br></pre></td></tr></table></figure><h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map.entrySet()返回示例[1=Google, 2=Runoob, 3=Taobao]，返回的是一个集合</span></span><br><span class="line"><span class="comment">//增强for获取实体，无法remove等操作</span></span><br><span class="line">Map&lt;Integer ,Integer&gt; map = HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer , Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(entry.getValue() == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> entry.getKey();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只能获取values，不能获取key</span></span><br><span class="line"><span class="keyword">for</span>(String v : map,values())&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map的entrySet()方法返回一个实现Map.Entry接口的对象合集，集合中的每个对象都是底层Map中一个特定的键值对</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java ， leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YaoguaiMall</title>
      <link href="/2023/06/01/yaoguaimall/"/>
      <url>/2023/06/01/yaoguaimall/</url>
      
        <content type="html"><![CDATA[<h1 id="YaoGuaiMall"><a href="#YaoGuaiMall" class="headerlink" title="YaoGuaiMall"></a>YaoGuaiMall</h1><h2 id="一、虚拟环境"><a href="#一、虚拟环境" class="headerlink" title="一、虚拟环境"></a>一、虚拟环境</h2><p>虚拟机使用VirtualBox。</p><p>不用去下载linux镜像，使用vagrant（一个软件）快速创建虚拟机。他会去官方仓库下载安装。</p><p>安装好开机后使用<code>vagrant ssh</code>进行连接。</p><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>虚拟机可以使用端口转发：将virtualbox内各组件的端口和windows的端口进行映射，比如将virtualbox中MySQL的3306端口和Windows的3333端口进行绑定。</p><p>太麻烦了，不推荐使用。</p><p>这里使用vagrant 的私有网络，给虚拟机设置ip地址。在Windows使用ipconfig命令</p><p>![1685597379518](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1685597379518.png)</p><p>得到虚拟机的IP地址，将其填入vagrant的私有网络地址（vagrant配置文件），这样虚拟机就有了一个ip地址（可以自定义）。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker是一种开源的容器化平台，用于构建、打包、部署和运行应用程序。</p><p>比如需要安装一个软件，就先安装docker，然后让docker去下载镜像，然后启动这个软件。镜像 地址在dockerhub</p><p>一般安装需要管理员权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root // 登录管理员账号默认密码vagrant</span><br></pre></td></tr></table></figure><p><strong>docker运行的每个组件都是一个完整的环境</strong>（单独的虚拟机）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it name /addr// 进入该name组件的内部环境</span><br></pre></td></tr></table></figure><p>同时使用-v可以将容器内部文件目录和外部进行一个挂载。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v /mydata/mysql/conf:/etc/mysql</span><br></pre></td></tr></table></figure><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>在计算机网络中，端口是用于区分不同应用程序或服务的逻辑通信端点。每个网络通信使用协议（如TCP或UDP），并通过端口与其他计算机或设备进行通信。</p><p>端口号是一个16位的整数，范围从0到65535。其中，0到1023的端口号被称为”知名端口”，用于一些常见的网络服务，如HTTP（端口号80）、FTP（端口号21）和SSH（端口号22）等。1024到49151之间的端口号是”注册端口”，用于一些应用程序或服务。49152到65535之间的端口号是”动态或私有端口”，通常由操作系统分配给客户端应用程序临时使用。</p><p>通过将数据包的源端口和目标端口与目标IP地址相结合，计算机可以将网络通信路由到正确的应用程序或服务。<code>端口号的使用使得一台计算机可以同时支持多个应用程序或服务的并发通信</code>，从而实现了网络上的多任务处理。</p><p>需要注意的是，某些端口可能会受到操作系统或网络设备的<code>保留或限制</code>，因此在选择端口时需要避免使用已经被预留的端口号。</p><h2 id="二、SpringCloudAlibaba"><a href="#二、SpringCloudAlibaba" class="headerlink" title="二、SpringCloudAlibaba"></a>二、SpringCloudAlibaba</h2><h3 id="1-Nacos-注册中心"><a href="#1-Nacos-注册中心" class="headerlink" title="1.Nacos-注册中心"></a>1.Nacos-注册中心</h3><p>Nacos 是阿里巴巴开源的一个更易于构建云原生应用的动态服务发现，配置管理和服务管理平台，他是使用 java 编写的，需要依赖 java 环境</p><p>Nacos 文档地址： <a href="https://nacos.io/zh-cn/docs/quick-start.html">https://nacos.io/zh-cn/docs/quick-start.html</a></p><h3 id="2-openfeign-远程调用"><a href="#2-openfeign-远程调用" class="headerlink" title="2.openfeign-远程调用"></a>2.openfeign-远程调用</h3><p>例子：在member服务中远程调用coupon的请求（需要服务<code>已经注册到nacos</code>）</p><p>member服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;gulimall-coupon&quot;)</span><span class="comment">// 声明是一个远程调用掉用gulimall-coupon服务的/coupon/coupon/member/list请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CouponFeignService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/coupon/coupon/member/list&quot;)</span><span class="comment">// 全路径</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">membercoupons</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/coupons&quot;)</span><span class="comment">// 编写请求</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MemberEntity</span> <span class="variable">memberEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemberEntity</span>();</span><br><span class="line">    memberEntity.setNickname(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">R</span> <span class="variable">membercoupons</span> <span class="operator">=</span> couponFeignService.membercoupons();<span class="comment">// 调用远程调用函数，放入优惠券信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.ok().put(<span class="string">&quot;member&quot;</span>,memberEntity).put(<span class="string">&quot;coupons&quot;</span>,membercoupons.get(<span class="string">&quot;coupons&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.atguigu.gulimall.member.feign&quot;)</span></span><br><span class="line"><span class="comment">// 需要在member服务的主函数中标注开启feign扫描</span></span><br></pre></td></tr></table></figure><p>coupon服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;coupon/coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CouponController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/member/list&quot;)</span><span class="comment">// 编写请求</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">membercoupons</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CouponEntity</span> <span class="variable">couponEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CouponEntity</span>();</span><br><span class="line">        couponEntity.setCouponName(<span class="string">&quot;满100减10&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  R.ok().put(<span class="string">&quot;coupons&quot;</span>,Arrays.asList(couponEntity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-nacos作为配置中心"><a href="#3-nacos作为配置中心" class="headerlink" title="3.nacos作为配置中心"></a>3.nacos作为配置中心</h3><ul><li>引入nacos-config依赖</li><li>编写bootstrap.porperties配置文件(注明加载配置中心的哪些配置文件)，优先级高于application</li><li>使用配置中心可以动态的获取配置。（记得使用<code>@RefreshScope注解</code>、配置中心的该服务配置文件名为上线的服务名.properties）</li><li>优先使用配置中心。</li></ul><blockquote><p>核心概念</p></blockquote><p><strong>命名空间:</strong><br>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 <strong>Group</strong> 或 <strong>DatalD</strong> 的配置。<strong>Namespace</strong>  的常用场景之一是<code>不同环境的配置的区分隔离</code>，例如<code>开发测试环境和生产环境</code>的资源(如配置、服务)隔离等。</p><p><strong>配置集</strong></p><p><strong>一组相关或者不相关的配置项的集合称为配置集</strong>。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。</p><p><strong>配置集ID:</strong></p><p>Nacos 中的某个配置集的 ID，配置集 ID 是组织划分配置的维度之一，<strong>Data ID</strong> 通常用于组织划分系统的配置集，一个系统或者应用可以包含多个配置集，一个系统应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识，Dat a ID 通常采用类 Java 包 如 ( com.taobao.tc.refund.log.level ) 的命名规则保证全局唯一性，此命名规则非强制</p><p><strong>配置分组：</strong></p><p>Nacos 中的一组配置集，是组织配置的维度之一，通过一个有意义的字符串，(如 Buy 或 Trade ) 对配置集进行分组，从而区分 Data ID 相同的配置集，当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用，DEFAULT_GROUP 配置分组的常见场景，不同的应用或组件采用了相同的配置类型，如 database_url 配置和 MQ_topic 配置</p><h3 id="4-SpringCloudGateway"><a href="#4-SpringCloudGateway" class="headerlink" title="4.SpringCloudGateway"></a>4.SpringCloudGateway</h3><p>使用spring cloud的gateway作为网关。网关路由包含过滤和断言两个部分</p><h2 id="三、业务"><a href="#三、业务" class="headerlink" title="三、业务"></a>三、业务</h2><h3 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h3><p>关于函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title function_">listWithTree</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.查出所有分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.组装成父子的树形结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1).找到所有的一级分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; level1Menus = entities.stream().filter(categoryEntity -&gt;</span><br><span class="line">            categoryEntity.getParentCid() == <span class="number">0</span></span><br><span class="line">    ).map((menu) -&gt; &#123;</span><br><span class="line">        menu.setChildren(getChildrens(menu, entities));</span><br><span class="line">        <span class="keyword">return</span> menu;</span><br><span class="line">    &#125;).sorted((menu1, menu2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (menu1.getSort() == <span class="literal">null</span> ? <span class="number">0</span> : menu1.getSort()) - (menu2.getSort() == <span class="literal">null</span> ? <span class="number">0</span> : menu2.getSort());</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> level1Menus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的map()和sorted()就是函数式接口，传入的是一个函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a stream consisting of the results of applying the given</span></span><br><span class="line"><span class="comment"> * function to the elements of this stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate</span></span><br><span class="line"><span class="comment"> * operation&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; The element type of the new stream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *               &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *               function to apply to each element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><p>例如这里map()的传入参数是mapper，是一个函数，R就是函数传入参数的类型，{}里面return的内容就是函数实体。</p><h3 id="2-跨域"><a href="#2-跨域" class="headerlink" title="2.跨域"></a>2.跨域</h3><p>跨域：指的是浏览器<code>不能执行其他网站的脚本</code>。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。</p><p>同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230604225147720.png" alt="image-20230604225147720"></p><p>其实主要就是要求域名相同，这里是在负载均衡的时候遇到的跨域问题：</p><p>负载均衡例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri:lb:<span class="comment">//renren-fast</span></span><br></pre></td></tr></table></figure><p>这里的renren-fast就是进行负载均衡的地址，需要先行注册到注册中心。</p><p>解决办法：</p><p>1.配置请求头允许跨域。</p><p>2.使用nginx转化为同一个域。</p><h3 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3.文件上传"></a>3.文件上传</h3><p>使用oss服务器</p><blockquote><p>上传策略</p></blockquote><ol><li><p>文件传到服务器，再由服务器传到oss服务器</p><p>缺点是多经过了一层本地服务器，没有必要。浪费带宽。</p></li><li><p>文件由前端直接上传到服务器</p><p>缺点是前端没有安全性可言，会暴露账号与密码。</p></li><li><p>使用令牌签名机制</p></li></ol><h3 id="4-异常处理与数据校验"><a href="#4-异常处理与数据校验" class="headerlink" title="4.异常处理与数据校验"></a>4.异常处理与数据校验</h3><h4 id="1-JSR303"><a href="#1-JSR303" class="headerlink" title="1.JSR303"></a>1.JSR303</h4><p>一种规范</p><p>@Valid注解用于开启数据校验。</p><blockquote><p>分组校验</p></blockquote><p>对于校验指定不同的groups，因为不同情况下对于数据的校验可能不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Null(message=”新增不能指定id“,groups=&#123;AddGroup.class&#125;)</span></span><br><span class="line"><span class="meta">@Validated(&#123;AddGroups.class&#125;)</span></span><br></pre></td></tr></table></figure><p>这里的@Null就是一个注解，message是注解出现异常的提示信息，groups是分组选择，里面传入的是分组信息，其实是一个空的接口，用于进行标识。</p><p>下面的@Validated用于标记当前请求是哪个分组的</p><p><code>使用分组之后，没有进行划分分组的校验将会失效</code></p><h4 id="2-异常"><a href="#2-异常" class="headerlink" title="2.异常"></a>2.异常</h4><p>@ExceptionHandler(value&#x3D;Exception.class)</p><p>该注解作用是感知对应value的异常</p><blockquote><p>异常状态码</p></blockquote><p>也就是错误码和错误信息定义规范。根据具体业务确定。</p><h3 id="5-Feign和Dubbo区别"><a href="#5-Feign和Dubbo区别" class="headerlink" title="5.Feign和Dubbo区别"></a>5.Feign和Dubbo区别</h3><p>Feign是基于HTTP协议的轻量级的RESTful风格的框架，主要用于微服务架构中的服务间通信。Dubbo是一个基于RPC协议的高性能的分布式服务框架，主要用于构建传统的企业级分布式系统。</p><p>Feign适用于<code>轻量级</code>的微服务架构，更加简单和灵活；而Dubbo适用于<code>传统的</code>企业级分布式系统，具备<code>更丰富的功能和更高的性能</code>。</p><h2 id="四、Elasticsearch"><a href="#四、Elasticsearch" class="headerlink" title="四、Elasticsearch"></a>四、Elasticsearch</h2><p>一个分布式的开源搜索和分析引擎。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="1-index-索引"><a href="#1-index-索引" class="headerlink" title="1 index(索引)"></a>1 index(索引)</h5><p>动词，相当于 MySQL 中的 insert；</p><p>名词，相当于MySQL 中的 DataBase</p><h5 id="2-Type-类型"><a href="#2-Type-类型" class="headerlink" title="2 Type(类型)"></a>2 Type(类型)</h5><p>在 Index（索引）中，可以定义一个或多个类型</p><p>类似于 MySQL 中的 Table，每一种类型的数据放在一起</p><h5 id="3-Document-文档"><a href="#3-Document-文档" class="headerlink" title="3 Document(文档)"></a>3 Document(文档)</h5><p>保存在某个索引（index）下，某种类型（Type）的一个数据（Document）,文档是 JSON 格式的，Document 就像是 MySQL 中某个 Table 里面的内容</p><h5 id="4-倒排索引机制"><a href="#4-倒排索引机制" class="headerlink" title="4 倒排索引机制"></a>4 倒排索引机制</h5><p><img src="C:/Users/15958/Desktop/谷粒商城/谷粒商城项目笔记/分布式高级篇/image/image-20201026092738311.png" alt="image-20201026092738311"></p><h2 id="五、Nginx"><a href="#五、Nginx" class="headerlink" title="五、Nginx"></a>五、Nginx</h2><blockquote><p>正向代理与反向代理</p></blockquote><p>正向代理：例如科学上网，隐藏客户端信息。</p><p>反向代理：屏蔽内网服务器信息，负载均衡访问。</p><p>这里使用nginx搭载<code>域名访问环境</code>以及进行反向代理(取代网关的作用)。</p><blockquote><p>域名映射过程</p></blockquote><p>输入一个网址时，例如baidu.com，并不知道这个域名的ip地址，第一步是去本机host文件寻找映射，看看有没有对应的IP地址映射。如果没有，就去网络上的dns服务器寻找,进行解析.</p><p>使用nginx进行反向代理的时候,通过配置可以实现网关路由的功能,不过需要修改配置文件,如果是分布式的情况下,可能各个微服务都有自己的ip地址,每次都要修改nginx的配置文件,所以这里还是直接转发给网关进行路由.</p><p><code>这里的过程就是页面发给nginx,然后nginx转发给网关,网关再进行路由.</code>(可是nginx在代理给网关的时候,会丢失请求的host信息)</p><h2 id="六、压力测试与优化"><a href="#六、压力测试与优化" class="headerlink" title="六、压力测试与优化"></a>六、压力测试与优化</h2><p><code>postman</code>用来测试服务。</p><p><code>jmeter</code>用来做性能测试。</p><p><code>jconsole</code>堆内存的监控、CPU占用率等等。<code>jvisualvm</code>一样，可以下载插件，查看GC。</p><blockquote><p>优化主要是在jvm的堆区</p></blockquote><h3 id="1-数据库优化"><a href="#1-数据库优化" class="headerlink" title="1.数据库优化"></a>1.数据库优化</h3><h4 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h4><p>通过索引,可以快速定位到指定值所在的行或列(会占用额外的空间以及需要考虑增删改查的维护成本)</p><blockquote><p>关系性数据库与非关系性数据库</p></blockquote><p>关系型数据库是基于关系模型的数据库，数据<code>以表格的形式进行组织和存储</code>。关系模型由表（表格）组成，每个表由一组列和行组成，其中列代表属性（字段），行代表记录（数据）。关系型数据库使用结构化查询语言（SQL）进行数据管理和查询。</p><p>非关系型数据库是指不基于关系模型的数据库，它们使用<code>不同的数据模型和存储结构</code>。非关系型数据库适用于需要处理大量数据、需要高扩展性和高性能的场景。</p><p>关系型数据库适合需要保证数据一致性和复杂查询的应用，而非关系型数据库适用于大规模数据和高并发访问的场景，并且对数据的结构要求较为灵活。</p><h3 id="2-nginx动静分离"><a href="#2-nginx动静分离" class="headerlink" title="2.nginx动静分离"></a>2.nginx动静分离</h3><p>将项目需要的所有静态资源都由nginx直接返回.</p><p>将静态资源交给nginx可以将服务器的压力进行分担,节省带宽和减轻后端的负载,(nginx在处理静态资源的时候采用了sendfile机制,可以提高文件传输的效率)</p><h3 id="3-数据库查询逻辑变更"><a href="#3-数据库查询逻辑变更" class="headerlink" title="3.数据库查询逻辑变更"></a>3.数据库查询逻辑变更</h3><p>将查询数据库的次数减少,减少数据库读写频率</p><h5 id="关于MySql"><a href="#关于MySql" class="headerlink" title="关于MySql"></a>关于MySql</h5><blockquote><p>主从复制:主从复制是一种数据库复制技术，用于将一个数据库的数据复制到多个从数据库中，以实现<code>数据的备份</code>、<code>负载均衡</code>和高可用性。在主从复制中，有一个主数据库（Master）和多个从数据库（Slaves）。<code>主数据库</code>负责<code>接收和处理写</code>操作，而<code>从数据库</code>复制主数据库的数据，并处理<code>读</code>操作。</p><p>基本原理通过日志实现,所以这是一个异步的操作,主数据库的写操作需要被复制到从数据库才能生效，因此在主从复制中存在一定的延迟.</p></blockquote><h3 id="4-缓存与分布式锁（redis）"><a href="#4-缓存与分布式锁（redis）" class="headerlink" title="4.缓存与分布式锁（redis）"></a>4.缓存与分布式锁（redis）</h3><p>为了性能提升,引入缓存,数据库主要承担数据落盘工作(持久化).</p><blockquote><p>哪些数据适合放入缓存</p><p>即时性、数据一致性要求不高的；访问量大且更新频率不高的(读多、写少).</p></blockquote><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230606100048328.png" alt="image-20230606100048328" style="zoom:67%;" /><h4 id="缓存方式有哪些"><a href="#缓存方式有哪些" class="headerlink" title="缓存方式有哪些?"></a>缓存方式有哪些?</h4><h4 id="1-本地缓存-比如Map"><a href="#1-本地缓存-比如Map" class="headerlink" title="1.本地缓存(比如Map);"></a>1.本地缓存(比如Map);</h4><p>​存在的问题:</p><p>​在分布式的情况下,每个服务器都有着自己的内存或者说map,在负载均衡的时候,不一定会路由到有这个缓存数据的服务器(缓存不共享);</p><p>​在数据库修改的时候,第一个负载均衡的服务器会修改缓存,可是其他服务器并不会在缓存修改这个数据.(不一致问题)</p><h4 id="2-Redis"><a href="#2-Redis" class="headerlink" title="2.Redis"></a>2.Redis</h4><p>springboot2.0以后默认使用Lettuce作为操作redis的客户端，它使用netty进行网络通信。（也可以将Lettuce换为jedis，jedis吞吐量较低）</p><p>Lettuece和jedis都是操作redis的底层客户端，Spring将其再次封装成<code>redisTemplate</code>。</p><p>Netty是一个基于Java的异步事件驱动的网络应用程序框架(用于通信)</p><h5 id="缓存失效问题"><a href="#缓存失效问题" class="headerlink" title="缓存失效问题"></a>缓存失效问题</h5><p>高并发下缓存失效问题</p><h6 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h6><p>重点是浪费了数据库的资源去查一个知道肯定不存在的元素</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230606185559970.png" alt="image-20230606185559970"></p><blockquote><p>解决方法</p></blockquote><ol><li><p>布隆过滤器（Bloom Filter）：布隆过滤器是一种数据结构，用于<code>快速判断一个元素是否存在于一个集合中</code>。可以在查询缓存之前使用布隆过滤器进行快速判断，如果元素不存在于布隆过滤器中，则可以直接返回，<code>避免访问数据库</code>。布隆过滤器是通过一些位映射实现的.</p><p>布隆过滤器有时候会出现<code>误判</code>的情况,也就是将一个不存在的元素认为存在.设置白名单可以一定程度上解决这个问题,也就是先维护一个白名单,<code>只让不存在于白名单的元素通过布隆过滤器</code>.</p></li><li><p>**<code>缓存空对象</code>**：当查询数据库时，如果发现某个数据在数据库中不存在，可以将这个结果作为一个空对象缓存起来。下次再查询相同的数据时，可以直接<code>从缓存中返回空对象</code>，避免访问数据库。</p></li><li><p>延迟加载：当发现某个数据在缓存中不存在时，可以将该数据的查询操作放入一个<code>延迟加载队列</code>中，然后<code>再异步进行查询并更新缓存</code>。这样可以避免大量的并发请求同时访问数据库，减轻数据库的压力</p></li><li><p>限流和黑名单：通过限制请求频率、设置访问频次限制、使用验证码等手段来防止恶意攻击和非法请求，将合法的请求放行，而对于异常或非法请求进行拦截或限制。</p></li><li><p>数据预热：在系统启动时或低峰期，可以通过<code>批量加载热点数据到缓存中</code>，提前预热缓存，避免在高峰期因缓存失效而导致大量请求穿透到数据库。</p></li><li><p>使用互斥锁（Mutex Lock）：当缓存未命中时，可以使用<code>互斥锁</code>来<code>保证只有一个线程去访问数据库</code>，其他线程等待结果，避免多个线程同时访问数据库造成缓存穿透。</p></li></ol><h6 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h6><p>重点是缓存某一时刻集体失效</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230606191049557.png" alt="image-20230606191049557"></p><blockquote><p>解决方法</p></blockquote><ol><li>设置合理的**<code>缓存过期时间</code>**：避免所有缓存同时失效，可以给缓存设置<code>随机</code>的过期时间，分散缓存失效时间点，减少缓存同时过期的概率。</li><li>限流和熔断机制：通过<code>限制并发访问量</code>、设置请求的最大处理数量等方式，控制请求流量，避免缓存雪崩导致的大量请求涌入。</li><li>数据库<code>容灾</code>和高可用：保证数据库的高可用性，使用数据库主从复制、读写分离等技术，避免数据库单点故障导致的雪崩效应。</li><li>分布式锁：在缓存失效时，使用分布式锁机制，<code>只允许一个请求重新加载缓存</code>，避免缓存失效时大量请求同时访问数据库。</li></ol><blockquote><p>过期策略</p></blockquote><ol><li>时间过期策略（TTL）：为<code>每个缓存项</code>设置一个<code>固定的过期时间</code>，缓存项在达到过期时间后自动失效。</li><li><code>惰性</code>过期策略（Lazy Expiration）：只在<code>访问缓存项时检查其是否过期</code>，如果过期则进行失效操作。这种策略避免了定期扫描所有缓存项的开销，但会在访问过期缓存项时引入一定的延迟。</li><li><code>定期</code>过期策略（Fixed Interval Expiration）：定期<code>扫描所有缓存项</code>，判断其是否过期，并进行失效操作。可以通过设置固定的时间间隔来执行扫描操作。</li><li><code>最近最少使用</code>过期策略（Least Recently Used Expiration）：根据缓存项的<code>访问频率</code>来判断其是否过期。当缓存空间不足时，会优先淘汰最近最少被使用的缓存项。</li><li><code>容量限制</code>策略（Capacity Limitation）：当缓存<code>达到一定容量限制</code>时，会根据一定的规则淘汰部分缓存项。常见的规则包括最近最少使用、最早过期等。</li></ol><h6 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h6><p>重点是高访问的数据过期</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230606191640868.png" alt="image-20230606191640868"></p><blockquote><p>解决方法</p></blockquote><ol><li>**<code>加锁策略</code>**：在缓存失效的时候，通过加锁的方式，<code>只允许一个线程去访问数据库</code>，其他线程等待。当第一个线程从数据库中获取到数据后，更新缓存，并释放锁，其他线程再从缓存中获取数据。</li><li>设置热点数据永不过期：<code>针对一些热点数据</code>，可以设置其缓存永不过期，或者设置一个较长的过期时间。这样即使缓存失效，仍然可以继续使用旧数据，避免了缓存失效期间的数据库压力。</li></ol><h5 id="缓存倾斜问题"><a href="#缓存倾斜问题" class="headerlink" title="缓存倾斜问题"></a>缓存倾斜问题</h5><p>指在某些特定条件下，缓存中的部分数据受到极高的访问频率，而其他数据则很少或几乎不被访问的情况。</p><p>会造成空间浪费和命中率下降的问题.</p><blockquote><p>解决方法</p></blockquote><ol><li><code>分级</code>缓存：将缓存分成多个层级，不同层级的缓存用于存储不同访问频率的数据。可以将<code>热门数据放在高速缓存层</code>，将<code>冷门数据放在低速缓存层</code>，以充分利用缓存空间。</li><li><code>热点数据隔离</code>：将热门数据单独存储在一个缓存集群中，避免与其他数据混合存储，确保热门数据有足够的缓存空间，提高缓存命中率。</li><li>数据<code>预热</code>：在系统启动或低峰期，预先将一些热门数据加载到缓存中，避免系统高峰期出现缓存倾斜问题。</li><li>动态调整缓存策略：根据实时的数据访问情况，动态调整缓存策略，优化缓存的利用率和命中率。</li></ol><h5 id="缓存加锁策略"><a href="#缓存加锁策略" class="headerlink" title="缓存加锁策略"></a>缓存加锁策略</h5><h6 id="1-synchronized-this-本地锁"><a href="#1-synchronized-this-本地锁" class="headerlink" title="1.synchronized(this)(本地锁)"></a>1.synchronized(this)(本地锁)</h6><p>因为springboot中所有组件都是单例的,所以都是同一把锁,是能锁住的.</p><blockquote><p>注意:</p><p>1.进程得到锁以后,应该再去缓存中确定一次,如果没有才需要继续查询(<code>双检锁</code>),防止前一个进程已经读过数据库了,下一个进程还要去读.</p><p>2.<code>结果放入缓存</code>的步骤应该也放在<code>锁内</code>,防止锁不住的情况,也就是锁放开后,该线程准备将结果放入缓存时,其他线程进行判断,发现缓存中没有.</p></blockquote><h6 id="2-分布式下如何加锁"><a href="#2-分布式下如何加锁" class="headerlink" title="2.分布式下如何加锁"></a>2.分布式下如何加锁</h6><p>对于每一个微服务都有一个容器,比如product服务可能有很多个容器,那么便会有有很多个实例,这时<code>this只代表了当前容器的实例</code>,也就是每一个this都是不同的锁.(本地锁只能锁住当前进程,所以需要分布式锁)</p><p>分布式锁由redis提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>,<span class="string">&quot;111&quot;</span>);<span class="comment">// 加锁</span></span><br><span class="line">redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);<span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p>注意:加锁的时候有一个value,也就是”111”,解锁的时候是不需要这个值的,直接删掉整个锁</p><blockquote><p>占锁</p></blockquote><p>1.当前占用锁的进程闪断,锁无法释放.</p><p>需要设置过期时间,防止任务死锁</p><p>2.占锁后,设置过期时间前闪断</p><p>使用一条<code>原子命令</code>进行占锁和设置过期时间</p><blockquote><p>删锁</p></blockquote><p>3.业务超时,锁过期了</p><p>这里由两个问题</p><p>一是业务在执行之后解锁的时候,会把别人的锁解开(<code>解锁的命令都是一样的</code>);</p><p>这里的解决方案是,设置一个uuid(随机),在锁的名字上加上这个uuid,删锁的时候去<code>判断你删的这个锁是不是对应uuid的锁</code>,也就是这把锁是不是还是你的,可是在判断的时候,也是需要<code>时间</code>去获取这个值然后进行操作的,如果在获取值的时候,锁没有过期,在获取到值进行释放的时候,锁过期了,那么也会删掉别人的锁.</p><p>所以对比成功删除这一步也要是原子性的(Lua脚本)</p><p>二是对锁进行续期的问题</p><p>简单一些就是把锁的时间放长一点</p><blockquote><p>结论</p></blockquote><p><code>加锁删锁</code>都要保持原子性</p><p>在一个锁被占用的时候,其他进程采用自旋来等待锁解锁.</p><h4 id="3-redisson-分布式锁"><a href="#3-redisson-分布式锁" class="headerlink" title="3.redisson(分布式锁)"></a>3.redisson(分布式锁)</h4><p>和jedis等等一样,都是对于redis操作的客户端</p><p>使用RedissonClient操作 </p><p>ReentrantLock(可重入锁):A内部有B方法,A得到锁,B能直接用这把锁</p><blockquote><p>和redis锁的差异</p></blockquote><p>和之前的自旋方式不同,这里的是阻塞(挂起)方式;自动适应了上述各种分布式锁的细节操作.</p><p>1.锁的自动续期(看门狗)</p><p>如果业务超长,运行期间自动给锁续上30s.(更改超时时间之后不会自动续期,改了之后就是用redis了)</p><p>2.加锁的业务只要允许完成,就不会自动续期,即使不手动解锁,也会在默认30s后自动删除.</p><p>3.闭锁:等待所有锁释放才继续;通常是一个<code>计数器</code>，初始化一个数值，每当一个线程完成操作时，计数器减一，直到计数器为零时，所有等待的线程被释放</p><p>4.信号量:控制同时访问某个资源的线程数量</p><p>闭锁用于等待操作的完成，而信号量用于控制资源的访问数量</p><blockquote><p>一致性问题</p></blockquote><p>双写模式：改变后一起更改</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230606232815673.png" alt="image-20230606232815673"></p><p>失效模式：直接删除</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230606232852164.png" alt="image-20230606232852164"></p><h5 id="缓存数据一致性解决方案"><a href="#缓存数据一致性解决方案" class="headerlink" title="缓存数据一致性解决方案"></a>缓存数据一致性解决方案</h5><p>无论是双写模式还是失效模式，都会遇到缓存不一致的问题，即多个实例同时更新会出事，怎么办？</p><ul><li>1、如果是用户纯度数据（订单数据、用户数据），这<code>并发几率很小</code>，几乎不用考虑这个问题，缓存数据加上过期时间，每隔一段时间触发读的主动更新即可</li><li>2、如果是菜单，商品介绍等基础数据，也可以去使用 canal 订阅，binlog 的方式</li><li>3、缓存数据 + 过期时间也足够解决大部分业务对缓存的要求</li><li>4、通过<code>加锁</code>保证并发读写，写写的时候按照顺序排好队，读读无所谓，所以适合读写锁，（业务不关心脏数据，允许临时脏数据可忽略）</li></ul><p>总结:</p><ul><li>我们能放入缓存的数据本来就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间，保证每天拿到当前的最新值即可</li><li>我们不应该过度设计，增加系统的复杂性</li><li>遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点</li><li>或者使用<code>canal</code></li></ul><h4 id="4-SpringCache"><a href="#4-SpringCache" class="headerlink" title="4.SpringCache"></a>4.SpringCache</h4><p>spring集成框架，定义缓存组件的规则</p><p>使用CacheManager管理缓存，CacheManager可以有各种实现，比如redis，map等等。</p><p>springcache会对每个缓存的对象继续分区，但是这个分区只是springcache的标识，也就是在redis中是没有这个标识的，通过分区可以部分数据进行集中修改。</p><h5 id="问题以及解决"><a href="#问题以及解决" class="headerlink" title="问题以及解决"></a>问题以及解决</h5><h6 id="读模式"><a href="#读模式" class="headerlink" title="读模式"></a>读模式</h6><p>缓存穿透:查询一个null数据，解决 缓存空数据：ache-null-values&#x3D;true</p><p>缓存击穿:大量并发进来同时查询一个正好过期的数据，解决:加锁 ？ <code>默认是无加锁</code>,可以配置加锁（本地锁）</p><p>缓存雪崩:大量的key同时过期，解决：加上随机时间，Spring-cache-redis-time-to-live</p><h6 id="写模式：（缓存与数据库库不一致）"><a href="#写模式：（缓存与数据库库不一致）" class="headerlink" title="写模式：（缓存与数据库库不一致）"></a>写模式：（缓存与数据库库不一致）</h6><p>1、读写加锁</p><p>2、引入canal，感知到MySQL的更新去更新数据库</p><p>3、读多写多，直接去数据库查询就行</p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>常规数据（读多写少，即时性，一致性要求不高的数据）完全可以使用SpringCache 写模式（ 只要缓存数据有过期时间就足够了）</p><h2 id="七、线程、异步编排"><a href="#七、线程、异步编排" class="headerlink" title="七、线程、异步编排"></a>七、线程、异步编排</h2><h3 id="初始化线程的4种方式（线程池）"><a href="#初始化线程的4种方式（线程池）" class="headerlink" title="初始化线程的4种方式（线程池）"></a>初始化线程的4种方式（线程池）</h3><ul><li><p>继承Tread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Runable01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Callable接口 + FutureTask （可以拿到返回结果，可以处理异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Callable01</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">// 可以有返回值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><blockquote><p>线程池(建议保证每个系统只有有限个线程池，一两个)</p></blockquote><ul><li><p>创建</p><p>1.Executors</p><p>2.new ThreadPoolExecutor</p></li><li><p>执行</p></li><li><p>七大参数</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230608121015287.png" alt="image-20230608121015287"></p></li></ul></li></ul><blockquote><p>启动线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前两种</span></span><br><span class="line"><span class="type">Tread01</span> <span class="variable">tread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tread01</span>();</span><br><span class="line">trean.start();<span class="comment">// 启动线程</span></span><br><span class="line"><span class="comment">//Callable接口</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable01</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> futureTask.get();<span class="comment">//阻塞等待整个线程执行完成，获取返回结果</span></span><br></pre></td></tr></table></figure><p>在业务中，需要对线程数进行管理，不然容易资源耗尽，以后对于所有的多线程异步任务都给线程池处理（性能稳定）</p><h3 id="线程池运行流程"><a href="#线程池运行流程" class="headerlink" title="线程池运行流程"></a>线程池运行流程</h3><p>1、线程池创建，准备好 <code>core</code> 数量 的核心线程，准备接受任务</p><p>2、新的任务进来，用 <code>core</code> 准备好的空闲线程执行</p><ul><li><code>core</code> **<code>满了</code>**，就将再进来的任务放入阻塞队列中，空闲的 core 就会自己去阻塞队列获取任务执行</li><li><code>阻塞队列也满了</code>，就直接开<code>新线程</code>去执行，最大只能开到 <code>max</code> 指定的数量</li><li><code>max</code> 都执行好了，<code>Max-core</code> 数量空闲的线程会在 <code>keepAliveTime</code> 指定的时间后自动销毁，终保持到 <code>core</code> 大小</li><li>如果线程数开到了 <code>max</code> 数量，还有新的任务进来，就会使用 reject 指定的<code>拒绝策略</code>进行处理</li></ul><p>3、所有的线程创建都是由指定的 <code>factory</code> 创建的</p><h3 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h3><p>在Java中，常用的线程池类型有以下几种：</p><ol><li>FixedThreadPool（固定线程池）：<ul><li>核心线程数固定，<code>不会回收</code>线程。</li><li>当任务提交到线程池时，若有空闲线程则立即执行，若无空闲线程则任务会等待直到有可用线程。</li><li>当线程池中的线程都在执行任务且达到最大线程数时，新的任务会进入等待队列。</li></ul></li><li>CachedThreadPool（缓存线程池）：<ul><li>线程池不固定大小，可以根据需要<code>动态创建和回收线程</code>。</li><li>当任务提交到线程池时，若有空闲线程则立即执行，若无空闲线程则创建新线程执行任务。</li><li>当线程池中的线程<code>空闲时间</code>超过一定阈值（默认60秒），则会被回收销毁。</li></ul></li><li>ScheduledThreadPool（定时线程池）：<ul><li>线程池可用于执行定时任务和周期性任务。</li><li>核心线程数固定，<code>不会回收线程</code>。</li><li>若任务提交时间早于当前时间，则立即执行任务；若任务提交时间晚于当前时间，则等待至指定时间后执行。</li><li>定时线程池一般不进行线程回收，除非显式地关闭线程池。</li></ul></li><li>SingleThreadPool（单线程池）：<ul><li>只有一个核心线程的线程池。</li><li>保证所有任务按照指定顺序执行，先进先出。</li><li>当<code>线程因异常结束时，会重新创建一个新线程来替代</code>。</li></ul></li><li>WorkStealingPool（<code>工作窃取</code>线程池）：该线程池是Java 8新增的一种线程池类型，基于工作窃取算法，每个线程都有自己的任务队列，当线程完成自己的任务后，可以从其他线程的队列中<code>偷取任务</code>执行。适用于任务间存在较大差异，且具有任务窃取特性的场景。</li></ol><h3 id="异步编排"><a href="#异步编排" class="headerlink" title="异步编排"></a>异步编排</h3><p>其实就是对于各个任务进行异步的调用来节约时间，同时要注意任务间的逻辑调用。</p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>JAVA8引入的一个类，用于支持异步编程和处理异步任务的结果。<code>CompletableFuture</code>是<code>Future</code>的一个扩展，它提供了更强大的功能和灵活性。</p><h5 id="1-创建异步对象"><a href="#1-创建异步对象" class="headerlink" title="1.创建异步对象"></a>1.创建异步对象</h5><p>CompletableFuture 提供了四个静态方法来创建一个异步操作</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230608223512787.png" alt="image-20230608223512787"></p><p>1、<strong>runXxx 都是没有返回结果的，supplyXxxx都是可以获取返回结果的</strong></p><p>2、可以传入自定义的线程池，否则就是用默认的线程池</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;main....start.....&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;<span class="comment">// 新建一个异步对象，无返回</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<span class="comment">// 新建一个异步对象，有返回</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;, executor);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future.get();<span class="comment">// 获取返回的结果</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;main....stop.....&quot;</span> + integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-计算完成时的回调函数"><a href="#2-计算完成时的回调函数" class="headerlink" title="2.计算完成时的回调函数"></a>2.计算完成时的回调函数</h5><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230608224222239.png" alt="image-20230608224222239"></p><p>whenComplete 可以处理<code>正常和异常</code>的<code>计算结果</code>(只能感知，不能修改)，exceptionally 处理<code>异常</code>情况</p><p>whenComplete 和 whenCompleteAsync 的区别</p><p>​whenComplete ：是执行<code>当前任务的线程继续执行</code> whencomplete 的任务</p><p>​whenCompleteAsync： 是执行把 whenCompleteAsync 这个任务继续<code>提交给线程池来进行执行</code></p><blockquote><p>方法<code>不以 Async 结尾</code>，意味着 Action 使用<code>相同</code>的线程执行，而 Async 可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</p></blockquote><h5 id="3-handle方法"><a href="#3-handle方法" class="headerlink" title="3.handle方法"></a>3.handle方法</h5><p>和complete方法一样，可对结果做最后的处理，可<code>改变返回值</code></p><h5 id="4-线程串行化方法（任务逻辑组合）"><a href="#4-线程串行化方法（任务逻辑组合）" class="headerlink" title="4.线程串行化方法（任务逻辑组合）"></a>4.线程串行化方法（任务逻辑组合）</h5><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230608225156331.png" alt="image-20230608225156331"></p><p>thenApply方法：当一个线程<code>依赖</code>另一个线程时，获取上一个任务返回的结果，并返回当前任物的返回值</p><p>thenAccept方法：消费处理结果，接受任务处理结果，并消费处理，无返回结果</p><p>thenRun方法：只要上面任务执行完成，就开始执行 thenRun ,只是处理完任务后，执行thenRun的后续操作</p><p>thenCombine: <code>组合两个</code> future，获取两个 future的返回结果，并返回当前任务的返回值</p><p>thenAccpetBoth: 组合两个 future，获取两个 future 任务的返回结果，然后处理任务，没有返回值</p><p>runAfterBoth:组合两个 future，不需要获取 future 的结果，只需要两个 future处理完成任务后，处理该任务，</p><p>applyToEither;<code>两个任务有一个</code>执行完成，获取它的返回值，处理任务并有新的返回值</p><p>acceptEither: 两个任务有一个执行完成，获取它的返回值，处理任务，没有新的返回值</p><p>runAfterEither:两个任务有一个执行完成，不需要获取 future 的结果，处理任务，也没有返回值</p><p>allOf：等待<code>所有任务</code>完成</p><p>anyOf:<code>只要有一个任务完成</code></p><h2 id="八、认证（登录服务）Session"><a href="#八、认证（登录服务）Session" class="headerlink" title="八、认证（登录服务）Session"></a>八、认证（登录服务）Session</h2><h3 id="1-验证码防刷校验"><a href="#1-验证码防刷校验" class="headerlink" title="1.验证码防刷校验"></a>1.验证码防刷校验</h3><p>验证码（uuid生成）存在redis中。</p><p>防刷校验的目的是防止60s内同一个手机号再次发送验证码。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>1.携带时间信息（放在验证码后）</p><h3 id="2-重定向和转发的区别"><a href="#2-重定向和转发的区别" class="headerlink" title="2.重定向和转发的区别"></a>2.重定向和转发的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/target&quot;</span>; <span class="comment">// 重定向到指定URL</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/target&quot;</span>; <span class="comment">// 转发到指定URL</span></span><br></pre></td></tr></table></figure><p>重定向（Redirect）和转发（Forward）是两种不同的HTTP请求处理方式，它们有以下区别：</p><ol><li>目标位置：<code>重定向</code>将请求发送到<code>不同的URL</code>，而转发将请求发送到<code>同一个服务器上的不同资源</code>。</li><li>客户端行为：<code>重定向是客户端行为</code>，客户端会发送新的请求到重定向的URL。<code>转发是服务器行为</code>，客户端不知道转发的过程，它仅发送一次请求到服务器。</li><li>请求和响应：<code>重定向</code>会生成<code>两次请求和响应</code>，首先是初始请求和响应，然后是重定向请求和响应。<code>转发</code>只涉及<code>一次请求和响应</code>。</li><li>URL变化：重定向会<code>改变浏览器的URL</code>，因为它会使用新的URL进行请求。转发不会改变浏览器的URL，因为它仅是服务器内部的资源跳转。</li><li>上下文信息：<code>重定向会丢失上下文信息</code>，例如请求参数、Session信息等，因为它是发送一个<code>全新的请求</code>。<code>转发可以保留上下文信息</code>，因为它是在服务器内部进行资源跳转。</li><li>地址栏显示：重定向会显示重定向目标的URL地址，因为浏览器会重新加载页面。转发不会改变地址栏的URL，因为浏览器仍然显示初始请求的URL。</li></ol><p>总的来说，重定向用于将请求发送到不同的URL，并在客户端进行新的请求和响应。转发用于将请求发送到同一个服务器上的不同资源，不涉及地址栏的URL变化和额外的请求和响应。选择使用重定向还是转发取决于具体的需求和场景。</p><h3 id="3-注册流程注意事项"><a href="#3-注册流程注意事项" class="headerlink" title="3.注册流程注意事项"></a>3.注册流程注意事项</h3><p>前后端都需要校验，前端校验不可靠，而且可以绕过前端校验，目的只是为了用户体验更好  </p><p>使用验证码证明是否是这个用户，验证码存在redis中，调用远程服务进行注册，在验证成功后就<code>删除</code>掉这个验证码，防止下次还能通过这个验证码进行登录。(<code>令牌机制</code>)</p><h4 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h4><ul><li><p>秒传原理(上传文件时先进行一个MD5计算,如果库中存在一样的,就不进行上传了)</p></li><li><p>MD5&amp;MD5盐值加密</p><ul><li>MD5是一种哈希算法,具有以下特性(可能被彩虹表破解)<ul><li>不可逆</li><li>输入相同,输出相同</li><li>哈希冲突概率较小</li></ul></li><li>盐值加密,就是对于每个加密的过程加入一个随机值<ul><li>需要在数据库维护一个盐值字段</li></ul></li></ul></li></ul><h3 id="4-Session"><a href="#4-Session" class="headerlink" title="4.Session"></a>4.Session</h3><h4 id="session是什么"><a href="#session是什么" class="headerlink" title="session是什么?"></a>session是什么?</h4><p>Session 是指在客户端和服务器之间建立的一种<code>状态保持机制</code>。当用户第一次访问服务器时，服务器会为该用户创建一个唯一的<code>会话标识符</code>（Session ID），并将该标识符存储在<code>服务器端</code>。同时，服务器会将 Session ID 返回给客户端，通常通过 Cookie 或 URL 参数的方式。通过 Session，服务器可以将用户的相关数据存储在服务器端，并在需要时进行读取和更新。用户在同一个会话期间发出的多次请求可以共享同一个会话数据，从而实现用户状态的保持。Session 是服务器端的概念，服务器会根据 Session ID 来管理和维护 Session 数据。客户端（通常是浏览器）通过发送 Session ID 来标识自己的会话，并与服务器进行交互。</p><h4 id="1-重定向携带数据的问题"><a href="#1-重定向携带数据的问题" class="headerlink" title="1.重定向携带数据的问题"></a>1.重定向携带数据的问题</h4><p>利用session，将数据防在session，只要跳转到下一个页面取出这个数据以后，session中的数据就会删掉。</p><h4 id="2-分布式下的session问题"><a href="#2-分布式下的session问题" class="headerlink" title="2.分布式下的session问题"></a>2.分布式下的session问题</h4><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230612192058330.png" alt="image-20230612192058330"></p><p>使用session存在的一些问题:</p><h6 id="1-session不能跨域名共享-每个cookie中的sessionid都是有作用域的"><a href="#1-session不能跨域名共享-每个cookie中的sessionid都是有作用域的" class="headerlink" title="1.session不能跨域名共享,每个cookie中的sessionid都是有作用域的."></a>1.session不能跨域名共享,每个cookie中的sessionid都是有作用域的.</h6><blockquote><p>域名放大-使用springSession</p></blockquote><p>​使得即使是子域的卡,父域也能使用.也就是在发卡的时候,指定域名为父域名(卡是发给浏览器的,浏览器在访问服务的时候会带着这个卡,cookie)</p><h6 id="2-不同的服务之间session不能共享"><a href="#2-不同的服务之间session不能共享" class="headerlink" title="2.不同的服务之间session不能共享"></a>2.不同的服务之间session不能共享</h6><blockquote><p>域名放大</p></blockquote><h6 id="3-同一个服务-复制多份-session不同步问题-因为session内容存储在服务器-每个服务器存储的不一样"><a href="#3-同一个服务-复制多份-session不同步问题-因为session内容存储在服务器-每个服务器存储的不一样" class="headerlink" title="3.同一个服务,复制多份,session不同步问题(因为session内容存储在服务器,每个服务器存储的不一样)"></a>3.同一个服务,复制多份,session不同步问题(因为session内容存储在服务器,每个服务器存储的不一样)</h6><blockquote><p>session复制</p></blockquote><p>​优点:Tomcat原生支持,只需要修改配置文件.</p><p>​缺点:占用带宽,受到内存限制(需要多份拷贝)</p><blockquote><p>客户端存储</p></blockquote><p>​优点:服务器不存储session,用户保存自己的session到cookie,节省服务器资源.</p><p>​缺点:不安全\传输时浪费带宽(很多数据要传)\cookie长度限制4K,不能存储大量信息</p><blockquote><p>hash一致性(基于负载均衡,对于每个访问的ip进行hash,是的每次访问都在该服务器)</p></blockquote><p>​优点:只需要更改nginx配置\负载均衡,只要访问是均匀的,负载就是均衡的\可以支持水平扩展</p><p>​缺点:服务器重启可能导致部分session丢失</p><blockquote><p>统一存储(后端统一存储session内容)-SpringSession</p></blockquote><p>​优点:没有安全隐患\可以水平扩展\服务器重启或扩容都不会有session丢失</p><p>​缺点:增加了一次网络调用,需要修改业务代码\如果使用redis,从redis获取要比从内存获取慢</p><h4 id="3-SpringSession"><a href="#3-SpringSession" class="headerlink" title="3.SpringSession"></a>3.SpringSession</h4><p>原理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* 核心原理</span><br><span class="line">* <span class="number">1</span>、<span class="meta">@EnableRedisHttpSession</span>导入RedisHttpSessionConfiguration配置</span><br><span class="line">*      <span class="number">1</span>、给容器中添加了一个组件</span><br><span class="line">*         sessionRepository &gt;&gt;&gt;【RedisOperationsSessionRepository】 redis 操作 session session的增删改查封装类</span><br><span class="line">*      <span class="number">2</span>、SessionRepositoryFilter &gt;&gt;&gt; session存储过滤器，每个请求过来必须经过Filter</span><br><span class="line">*          <span class="number">1</span>、创建的时候，就自动从容器中获取到了SessionRepostiory</span><br><span class="line">*          <span class="number">2</span>、原始的request,response都被包装了 SessionRepositoryRequestWrapper、SessionRepositoryResponseWrapper</span><br><span class="line">*          <span class="number">3</span>、以后获取session.request.getSession()</span><br><span class="line">*              SessionRepositoryResponseWrapper</span><br><span class="line">*          <span class="number">4</span>、wrappedRequest.getSession() ==&gt;SessionRepository</span><br><span class="line">*</span><br><span class="line">*          装饰者模式</span><br><span class="line">*          spring-redis的相关功能:</span><br><span class="line">*                 执行session相关操作后，redis里面存储的时间也会刷新</span><br></pre></td></tr></table></figure><p>核心源码是：</p><ul><li><code>SessionRepositoryFilter</code> 类下面的 <code>doFilterInternal</code> 方法,Fliter就是进行了一次包装<ul><li>将 <code>request</code>、<code>response</code> 包装成 <code>SessionRepositoryRequestWrapper</code>,<strong>以后调用request.getSession()都是调用的WrappedRequest</strong></li></ul></li></ul><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230612212125725.png" alt="image-20230612212125725"> </p><p>request.setAttribute()是用于在同一个请求间传输数据的</p><h3 id="5-社交登录"><a href="#5-社交登录" class="headerlink" title="5.社交登录"></a>5.社交登录</h3><p>社交登录就是通过微博这种平台来进行用户注册和登录</p><h4 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h4><p><strong>OAuth2.0：</strong>对于用户相关的 OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等），为了保存用户数据的安全和隐私，第三方网站访问用户数据前都需要显示向用户授权.</p><p>流程:</p><p><img src="file://C:/Users/15958/Desktop/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7%E7%AF%87/image/oAuth2_01.gif?lastModify=1685951031" alt="img"></p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230609144207914.png" alt="image-20230609144207914"></p><p>回调地址和失败回调地址:就是成功和失败后跳转的页面</p><h5 id="微博测试实例"><a href="#微博测试实例" class="headerlink" title="微博测试实例"></a>微博测试实例</h5><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230609154714932.png" alt="image-20230609154714932"></p><h3 id="6-单点登录"><a href="#6-单点登录" class="headerlink" title="6.单点登录"></a>6.单点登录</h3><p>用于多系统的情况:比如yaoguaimall是一个系统,其他可能yaoguai出行也是一个系统,这样子如何实现mall登录了,出行也能登录.</p><p>其实就是多加了一个登录服务器。这里使用<a href="https://gitee.com/xuxueli0323/xxl-sso%E7%9A%84%E6%A1%86%E6%9E%B6%E3%80%82">https://gitee.com/xuxueli0323/xxl-sso的框架。</a></p><p>本质是使用了cookie和一个中转服务器。</p><p>流程： 请求1进来之后先去登录服务器登录，完成后重定向到之前的请求，并且在<code>登录服务器的域名</code>下留下一个token在cookie里（cookie是存在自己电脑里的，相当于自己浏览器记录了这个登录），请求2进来，先判断有没有登录，然后去登录服务器看<code>参数是否有token</code>，有就放在（该域名的）session中，认为是登录了的，然后根据这个token将信息存在<code>自己</code>的session中（通过远程调用从登录服务器获取），如果没有，就跳转到登录页面。</p><p>注意：这里的远程调用不一定使用feign，以为登录服务器不一定使用的java，可以使用RestTemplate.</p><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><h5 id="在Web开发中，主要有以下几种类型的Cookie："><a href="#在Web开发中，主要有以下几种类型的Cookie：" class="headerlink" title="在Web开发中，主要有以下几种类型的Cookie："></a>在Web开发中，主要有以下几种类型的Cookie：</h5><ol><li><strong>会话Cookie（Session Cookie）：会话Cookie是存储在浏览器内存中的Cookie，它在用户<code>关闭浏览器时</code>被删除。会话Cookie通常用于临时存储会话信息，比如用户登录状态等。</strong></li><li><strong>持久化Cookie（Persistent Cookie）：持久化Cookie是设置了<code>过期时间</code>的Cookie，它会被<code>保存在用户的浏览器</code>中，并在过期时间之前一直有效。持久化Cookie通常用于长期存储一些用户偏好设置、记住登录状态等。</strong></li><li>安全Cookie（Secure Cookie）：安全Cookie只能通过HTTPS协议进行传输，不能通过非加密的HTTP连接发送。它们用于确保Cookie中包含的敏感信息在传输过程中不被窃听或篡改。</li><li>HttpOnly Cookie：HttpOnly Cookie是一种特殊的Cookie标记，它限制了在客户端JavaScript中访问Cookie的能力。这样可以有效防止跨站脚本攻击（XSS）。</li><li>第三方Cookie（Third-party Cookie）：第三方Cookie是由不同域名下的网站共享的Cookie。当一个网页向其他域名下的资源发送请求时，该域名下的服务器可以设置一个Cookie，然后其他域名下的网站也可以访问该Cookie。</li></ol><h2 id="九、购物车"><a href="#九、购物车" class="headerlink" title="九、购物车"></a>九、购物车</h2><p>需要注意：会有临时用户和临时购物车的需求</p><h4 id="关于添加成功页面刷新会重复添加的问题"><a href="#关于添加成功页面刷新会重复添加的问题" class="headerlink" title="关于添加成功页面刷新会重复添加的问题"></a>关于添加成功页面刷新会重复添加的问题</h4><p>解决：设置一次重定向，展示的只是展示页面。</p><h2 id="十、消息队列"><a href="#十、消息队列" class="headerlink" title="十、消息队列"></a>十、消息队列</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>用处：异步通信、削峰填谷、数据传输和持久化、应用解耦(比如部分系统升级无需改代码)</p><p>消息代理与目的地：当消息发送者发送消息之后，将由消息代理接管，消息代理保证消息传递到指定目的地</p><p>目的地种类：</p><p>​1.队列：点对点(point-to-point)消息通信 消息有唯一的发送者和接收者，但不是说只能有一个接受者</p><p>​2.主题：发布(publish)&#x2F;订阅(subscribe)消息通信发布者发送消息到主题，多个接收者监听这个主题</p><p>JMS(Java Message Service):基于JVM的消息代理规范，比如ActiveMQ</p><p>AMQP：高级消息队列协议，兼容JMS，比如RabbitMQ</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p><strong>Message</strong></p><p>消息，消息是不具名的，它是由<code>消息头</code>和<code>消息体</code>组成，消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 <strong>routing-key （路由键）</strong>，<strong>priority（相对于其他消息的优先权）</strong>，<strong>delivery-mode（指出该消息可能需要持久性存储）</strong>等</p><p><strong>Publisher</strong></p><p>消息的生产者，也是一个像交换器发布消息的客户端应用程序</p><p><strong>Exchange</strong></p><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p><p>Exchange有4种类型：<strong>direct(默认)<strong>、</strong>fanout</strong>、<strong>topic</strong>，和<strong>heades</strong>，不同类型的 <strong>Exchange</strong> 转发消息的策略有所区别</p><p><strong>Queue</strong></p><p>消息队列，用来保存消息直到发送给<strong>消费者</strong>，<strong>他是消息的容器</strong>，也是消息的重点，一个消息可以投入一个或多个队列，消息一直在队列里面，等待消费者连接到这个队列将其取走</p><p><strong>Binding</strong></p><p>绑定，<strong>用于<code>消息队列和交换器</code>之间的关联</strong>，一个绑定就是<code>基于路由键将交换器和消息队列连接起来的规则</code>，所有可以将交换器理解成一个由绑定构成的路由表</p><p><strong>Connection</strong></p><p>网路连接，比如一个TCP连接 ,长连接，一个客户端只会建立一条连接</p><p><strong>Channel</strong></p><p>信道，<code>多路复用连接</code>中的一个独立的双向数据流通道，信道是建立在真实的TCP连接的内的虚拟连接，AMQP 命令都是通过信息到发送出去的，不管是发布消息，订阅队列还是接收消息，这些动作都是通过队列完成，因为对应操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以<code>复用一条TCP连接</code></p><p><strong>Consumer</strong></p><p>消息的消费者，表示一个消息队列中取得消息的客户端应用程序</p><p><strong>Virtual Host</strong></p><p>虚拟主机，表示<code>交换器、消息队列和相关对象</code>。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个Virtual host本质上就是一个<code> mini 版的RabbitMQ 服务器</code>,拥有自己的队列、交换器、绑定和权限机制。Virtual host 是 AMQP 概念的基础，必须在连接时指定,RabbitMQ<code>默认的vhost是/</code>。</p><p><strong>Broker</strong></p><p>表示消息队列<code>服务器实体</code> </p><p>![7620095963f4401fec991cdbd5d6891](C:\Users\15958\AppData\Local\Temp\WeChat Files\7620095963f4401fec991cdbd5d6891.png)</p><p>注：使用Erlang编写</p><h4 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h4><p>Exchange 分发消息时根据类型的不同分发策略有区别，目前共四种类型：<code>direct、tanout、topic、headers</code> </p><p>header匹配AMQP消息的 header 而不是路由键，headers 交换器和 direct 交换器完全一致，但性能差能多，目前几乎用不到了，所以直接看另外三种类型</p><p>交换机自动删除就是在没有绑定的时候要不要删除交换机，持久化指的是服务器重启后是否保留交换机.</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230614143233332.png" alt="image-20230614143233332"></p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230614143239382.png" alt="image-20230614143239382"></p><p>Topic交换机其实就是部分广播模式，可以如果通配符进行区分</p><blockquote><p>交换机有交换机的名字，队列有队列的名字和路由键，交换机根据路由键的名字给对应的队列发消息（交换机其实就是一张表）</p></blockquote><h4 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h4><p>目的：保证可靠抵达</p><ul><li><strong>publisher</strong> confirmCallback 确认模式</li><li><strong>publisher</strong> returnCallback 未投递到 queue 退回</li><li><strong>consumer</strong> ack 机制</li></ul><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230614151242002.png" alt="image-20230614151242002"></p><h5 id="可靠抵达-ConfirmCallback发送端"><a href="#可靠抵达-ConfirmCallback发送端" class="headerlink" title="可靠抵达 - ConfirmCallback发送端"></a>可靠抵达 - ConfirmCallback发送端</h5><p>spring.rabbitmq.publisher-confirms&#x3D;true</p><p>在创建 connectionFactory 的时候设置 PublisherConfirms(true) 选项，开启 confirmcallback。</p><p>CorrelationData 用来表示当前消息唯一性</p><p><strong>消息只要被 broker 接收到就会执行</strong> confirmCallback,如果 cluster 模式，需要所有 broker 接收到才会调用 confirmCallback</p><p>被 broker 接收到只能表示 message <code>已经到达服务器</code>，并不能保证消息一定会被投递到目标 queue 里，所以需要用到接下来的 returnCallback</p><h5 id="可靠抵达-ReturnCallback发送端"><a href="#可靠抵达-ReturnCallback发送端" class="headerlink" title="可靠抵达 - ReturnCallback发送端"></a>可靠抵达 - ReturnCallback发送端</h5><p>spring.rabbitmq.publisher-retuns&#x3D;true</p><p>spring.rabbitmq.template.mandatory&#x3D;true</p><p>confirm 模式只能保证消息到达 broker，不能保证消息准确投递到目标 queue 里。在有些模式业务场景下，我们需要保证<code>消息一定要投递到目标 queue 里</code>，此时就需要用到 return 退回模式</p><p>这样如果<code>未能投递到目标 queue 里将调用 returnCallback</code>，可以记录下详细到投递数据，定期的巡检或者自动纠错都需要这些数据</p><h5 id="可靠抵达-Ack-消息确认机制接收端"><a href="#可靠抵达-Ack-消息确认机制接收端" class="headerlink" title="可靠抵达 - Ack 消息确认机制接收端"></a>可靠抵达 - Ack 消息确认机制接收端</h5><p>确保每个消息被正确消费</p><ul><li>消费者获取到消息，成功处理，可以回复Ack给Broker<ul><li>basic.ack 用于<code>肯定</code>确认：broker 将移除此消息</li><li>basic.nack 用于<code>否定</code>确认：可以<code>指定 beoker 是否丢弃此消息</code>，可以批量</li><li>basic.reject用于否定确认，同上，但不能批量</li></ul></li><li>默认，消息被消费者<code>收到</code>，<code>就会</code>从broker的queue中<code>移除</code></li><li>消费者收到消息，默认<code>自动ack</code>，但是如果无法确定此消息是否被处理完成，或者成功处理，我们可以开启<code>手动ack</code>模式<ul><li>消息处理成功，ack()，接受下一条消息，此消息broker就会移除</li><li>消息处理失败，nack()&#x2F;reject() <code>重新发送给其他人进行处理</code>，或者<code>容错处理后ack</code>(可以选择是否重新入队)</li><li>消息一直没有调用ack&#x2F;nack方法，brocker认为此消息正在被处理，不会投递给别人，此时<code>客户端断开</code>，消息<code>不会被broker移除</code>，会<code>投递给别人</code></li></ul></li></ul><h2 id="十一、订单分布式事务"><a href="#十一、订单分布式事务" class="headerlink" title="十一、订单分布式事务"></a>十一、订单分布式事务</h2><h3 id="登录拦截器"><a href="#登录拦截器" class="headerlink" title="登录拦截器"></a>登录拦截器</h3><p>用于拦截和处理HTTP请求和响应的组件，可以在请求到达控制器之前或响应返回给客户端之前对请求和响应进行预处理或后处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 目标方法执行之前</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">      <span class="comment">// 指定的请求不拦截</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">match1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>().match(<span class="string">&quot;/order/order/status/**&quot;</span>, requestURI);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">match2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>().match(<span class="string">&quot;/payed/notify&quot;</span>, requestURI);</span><br><span class="line">      <span class="keyword">if</span> (match1 || match2) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      MemberRespVo memberRespVo= (MemberRespVo) request.getSession().getAttribute(AuthServerConstant.LOGIN_USER);</span><br><span class="line">      <span class="keyword">if</span> (memberRespVo != <span class="literal">null</span>) &#123; <span class="comment">// 用户登陆了</span></span><br><span class="line">          loginUser.set(memberRespVo); <span class="comment">// 放到共享数据中</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 用户没登录</span></span><br><span class="line">          <span class="comment">// 给前端显示提示信息</span></span><br><span class="line">          request.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;请先进行登录&quot;</span>);</span><br><span class="line">          <span class="comment">// 重定向到登录页面</span></span><br><span class="line">          response.sendRedirect(<span class="string">&quot;http://auth.gulimall.com/login.html&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Feign远程调用丢失请求头"><a href="#Feign远程调用丢失请求头" class="headerlink" title="Feign远程调用丢失请求头"></a>Feign远程调用丢失请求头</h3><p>feign在远程调用前要构造请求，并且调用很多的拦截器对请求进行增强。</p><p>![1686752866665](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1686752866665.png)</p><p>解决方法：加上<code>自己的拦截器</code></p><p>注意，这些调用都是在一个<code>线程</code>内的，所以能够在调用的函数内得到上下文信息那么如果使用了线程池呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;requestInterceptor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">requestInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RequestInterceptor</span> <span class="variable">requestInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">//1、使用RequestContextHolder拿到刚进来的请求数据，也就是上下文信息</span></span><br><span class="line">            <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">            <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//老请求</span></span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestAttributes.getRequest();</span><br><span class="line">                <span class="keyword">if</span> (request != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//2、同步请求头的数据（主要是cookie）</span></span><br><span class="line">                    <span class="comment">//把老请求的cookie值放到新请求上来，进行一个同步</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">cookie</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">                    template.header(<span class="string">&quot;Cookie&quot;</span>, cookie);<span class="comment">// 把cookie放入请求头</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> requestInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程上下文信息存储在ThreadLocal类的threadContext中</p></blockquote><h3 id="异步编排带来的Feign拦截器上下文丢失问题"><a href="#异步编排带来的Feign拦截器上下文丢失问题" class="headerlink" title="异步编排带来的Feign拦截器上下文丢失问题"></a>异步编排带来的Feign拦截器上下文丢失问题</h3><p>在远程调用的时候，采用异步编排来提高效率。可是这样就会多了几个线程，就不是在一个线程内完成的任务，自然也无法获取主线程的上下文。</p><p>解决方法：将主线程的内容共享给其他线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主线程内:</span><br><span class="line"><span class="type">RequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();<span class="comment">//获取主线程的请求</span></span><br><span class="line">副线程内：</span><br><span class="line">RequestContextHolder.setRequestAttributes(requestAttributes);<span class="comment">//共享请求数据</span></span><br></pre></td></tr></table></figure><h3 id="接口幂等性"><a href="#接口幂等性" class="headerlink" title="接口幂等性"></a>接口幂等性</h3><p><strong>接口幂等性就是用户对同一操作发起的一次请求和多次请求结果是一致的</strong>，不会因为多次点击而产生了副作用，比如支付场景，用户购买了商品，支付扣款成功，但是返回结果的时候出现了网络异常，此时钱已经扣了，用户再次点击按钮，此时就会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。。。这就没有保证接口幂等性</p><p>也就是防止表单重复提交</p><h4 id="哪些情况需要防止"><a href="#哪些情况需要防止" class="headerlink" title="哪些情况需要防止"></a>哪些情况需要防止</h4><ul><li><p>用户多次点击按钮</p></li><li><p>用户页面回退再次提交</p></li><li><p>微服务互相调用，由于网络问题，导致请求失败，feign触发重试机制</p></li><li><p>其他业务情况</p></li></ul><h4 id="幂等解决方案"><a href="#幂等解决方案" class="headerlink" title="幂等解决方案"></a>幂等解决方案</h4><h5 id="1、token-机制"><a href="#1、token-机制" class="headerlink" title="1、token 机制"></a>1、token 机制</h5><p>1、服务端提供了发送 <code>token</code> 的接口，我们在分析业务的时候，哪些业务是存在幂等性问题的，就必须在执行业务前，先获取 <code>token</code>，服务器会把 <code>token</code> 保存到 redis 中</p><p>2、然后调用业务接口请求时， 把 <code>token</code> 携带过去，一般放在请求头部</p><p>3、服务器判断 <code>token</code> 是否存在 <code>redis</code>，存在表示第一次请求，然后**<code>删除</code> <code>token</code>**，继续执行业务</p><p>4、如果判断 <code>token</code> 不存在 <code>redis</code> 中，就表示重复操作，直接返回重复标记给 <code>client</code>，这样就保证了业务代码，不被重复执行</p><blockquote><p>危险性：</p></blockquote><h6 id="1、先删除-token-还是后删除-token："><a href="#1、先删除-token-还是后删除-token：" class="headerlink" title="1、先删除 token 还是后删除 token："></a><strong>1、先删除 token 还是后删除 token：</strong></h6><ol><li>先删除可能导致，业务确实<code>没有执行</code>，重试还得带上之前的 token, 由于防重设计导致，请求还是不能执行</li><li>后删除可能导致，业务处理成功，但是服务闪断，出现<code>超时</code>，<code>没有删除</code>掉token，别人继续重试，导致业务被<code>执行两次</code></li><li>我们最后设计为<code>先删除 </code>token，如果业务调用失败，就重新获取 token 再次请求</li></ol><h6 id="2、Token-获取，比较-和删除-必须是原子性"><a href="#2、Token-获取，比较-和删除-必须是原子性" class="headerlink" title="2、Token 获取，比较 和删除 必须是原子性"></a><strong>2、Token 获取，比较 和删除 必须是原子性</strong></h6><ol><li>redis.get（token），token.equals、redis.del（token）,如果说这两个操作都不是原子，可能导致，在高并发下，都 get 同样的数据，判断都成功，继续业务并发执行</li><li>可以在 redis 使用 lua 脚本完成这个操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2、各种锁机制"><a href="#2、各种锁机制" class="headerlink" title="2、各种锁机制"></a>2、各种锁机制</h5><h6 id="1、数据库悲观锁"><a href="#1、数据库悲观锁" class="headerlink" title="1、数据库悲观锁"></a>1、数据库悲观锁</h6><p>select * from xxx where id &#x3D; 1 for update;for update 查询的时候锁定这条记录 别人需要等待悲观锁使用的时候一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用，另外需要注意的是，id字段一定是主键或唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦</p><h6 id="2、数据库的乐观锁"><a href="#2、数据库的乐观锁" class="headerlink" title="2、数据库的乐观锁"></a>2、数据库的乐观锁</h6><p>这种方法适合在更新的场景中update t_goods set count &#x3D; count - 1,version &#x3D; version + 1 where good_id &#x3D; 2 and version &#x3D; 1</p><p>根据 version 版本，也就是在操作数据库存前先获取当前商品的 version 版本号，然后操作的时候带上 version 版本号，我们梳理下，我们第一次操作库存时，得到 version 为 1，调用库存服务 version &#x3D; 2，但返回给订单服务出现了问题，订单服务又一次调用了库存服务，当订单服务传的 version 还是 1，再执行上面的 sql 语句 就不会执行，因为 version 已经变成 2 了，where 条件不成立，这样就保证了不管调用几次，只会真正处理一次，乐观锁主要使用于处理读多写少的问题</p><h6 id="3、业务层分布锁"><a href="#3、业务层分布锁" class="headerlink" title="3、业务层分布锁"></a>3、业务层分布锁</h6><p>如果多个机器可能在同一时间处理相同的数据，比如多台机器定时任务拿到了相同的数据，我们就可以加分布式锁，锁定此数据，处理完成后后释放锁，获取锁必须先判断这个数据是否被处理过</p><h5 id="3、各种唯一约束"><a href="#3、各种唯一约束" class="headerlink" title="3、各种唯一约束"></a>3、各种唯一约束</h5><h6 id="1、数据库唯一约束"><a href="#1、数据库唯一约束" class="headerlink" title="1、数据库唯一约束"></a>1、数据库唯一约束</h6><p>插入数据，应该按照<code>唯一索引</code>进行插入，比如订单号，相同订单就不可能有两条订单插入，我们在数据库层面防止重复这个机制利用了数据库的主键唯一约束的特性，解决了 insert场 景时幂等问题，但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键.</p><p>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关</p><h6 id="2、redis-set-防重"><a href="#2、redis-set-防重" class="headerlink" title="2、redis set 防重"></a>2、redis set 防重</h6><p>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入 redis 的set,每次处理数据，先看这个 MD5 是否已经存在，存在就不处理(<code>秒传</code>)</p><h5 id="4、防重表"><a href="#4、防重表" class="headerlink" title="4、防重表"></a>4、防重表</h5><p>使用订单表 <code>orderNo</code> 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中，这样就保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等性等问题，去重表和业务表应该在同一个库中，这样就保证了在同一个事务，即使业务操作失败，也会把去重表的数据回滚，这个很好的保证了数据的一致性，redis防重也算</p><h5 id="5、全局请求唯一id"><a href="#5、全局请求唯一id" class="headerlink" title="5、全局请求唯一id"></a>5、全局请求唯一id</h5><p>调用接口时，生成一个唯一的id，redis 将数据保存到集合中（去重），存在即处理过，可以使用 nginx 设置<code>每一个请求一个唯一id</code></p><p>proxy_set_header X-Request-Id $Request_id</p><h5 id="最终选择"><a href="#最终选择" class="headerlink" title="最终选择"></a>最终选择</h5><p>使用令牌实现提交订单的幂等性。</p><p>在购物车提交订单后，会有保存到redis的token（uuid+userid），这个是存到服务器的，然后页面也保存了一份，放在vo里面，然后放在ThreadLocal中（服务器内存），在提交订单后，redis中的token会被删除，同时token的<code>判断相等以及删除需要保证原子性</code>。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><blockquote><p>关于远程调用事务回滚的问题：</p></blockquote><p><strong>起因：</strong></p><ol><li>因为事务回滚是在一个连接内的，远程调用的请求是在别的连接内连上了别的数据库，所以目前请求出现问题回滚的时候，并不会使得远程连接的事务回滚。</li><li>feign调用超时会认为是失败了</li></ol><p><strong>导致：</strong></p><ol><li>远程服务假失败：远程服务其实成功了，由于网络故障等没有返回，从而导致订单回滚，库存却扣减了。</li><li>远程服务执行完成，下面的其他方法出现问题：导致已执行的远程请求不能回滚。</li></ol><p><code>引出--&gt;分布式事务</code>原因：网络问题+分布式机器</p><h4 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h4><h5 id="数据库事务的几个特性"><a href="#数据库事务的几个特性" class="headerlink" title="数据库事务的几个特性"></a>数据库事务的几个特性</h5><p>原子性（Atomiccity）、一致性（Consistetcy）、隔离性或独立性（Isolation）和持久性（Durabilily），简称ACID</p><ul><li><p><strong>原子性：</strong>一系列操作整体不可拆分，要么同时成功要么同时失败</p></li><li><p><strong>一致性</strong>：数据在业务的前后，业务整体一致</p><ul><li>转账 A:1000 B:1000  转200  事务成功 A：800 B：1200</li></ul></li><li><p><strong>隔离性：</strong>事物之间需要相互隔离</p></li><li><p><strong>持久性：</strong>一旦事务成功，数据一定会落盘在数据库</p></li></ul><h5 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h5><p>也就是多个<code>并发</code>事务之间的相互影响程度和可见性的程度。未提交的事务是指在数据库中已经开始但尚未完成的事务。这种事务在执行过程中可能对数据库进行了修改，但尚未被永久保存到数据库中.</p><ul><li><strong>READ UNCOMMITEED(读未提交)</strong><code>也就是可以读取正在执行的事务的数据</code><ul><li>该隔离级别的事务会读到<code>其他未提交事务</code>的数据，此现象也称为<code>脏读</code></li></ul><p></p></li><li><strong>READ COMMITTED（读提交）</strong>      <code>也就是可以读到已经提交的事务的数据，但是这个数据可能一直在变，所以不能保证重复读到的都是一样的</code><ul><li>一个事物可以读取<code>另一个已提交的事务</code>，多次读取会造成不一样的结果，此现象称为<code>不可重复读</code>，复读问题，Oracle 和SQL Server 的默认隔离级别</li></ul></li><li><strong>REPEATABLE READ（<code>可重复读</code>）</strong>   <code>也就是其他事务在该事务提交前不能修改被该事务读取的数据</code><ul><li>该隔离级别是 <code>MySQL</code> 默认的隔离级别，在同一个事物中，SELECT 的<strong>结果是事务开始时时间点的状态</strong>，因此，同样的 SELECT 操作读到的结果会是一致</li><li>但是会有幻读一致,MySQL的 InnoDB 引擎可以通过 next-key locks 机制 来避免幻读</li><li>幻读：在<code>同一个事务中</code>，多次执行<code>同样的查询</code>，但结果集却发生了变化，产生了<code>额外的数据行</code>。幻读问题的根本原因在于可重复读隔离级别下的读取操作仅仅保证了已有数据行的一致性，但<code>对于新插入的数据行则没有加以限制</code>。当一个事务执行查询操作时，如果另一个事务在该查询的范围内插入了新的数据行，那么在同一个事务中的后续查询操作就会发现新增了一些数据行，从而出现了幻读的现象。</li></ul></li><li><strong>SERIALIZABLE（序列化）</strong>         <code>串行执行</code><ul><li>在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐士加一把读共享锁，从而避免了脏读、不可重复读、幻读等问题，<code>失去了并发能力</code></li></ul></li></ul><p>越大的隔离级别，<code>并发能力</code>越低</p><h5 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h5><p>事务传播行为（Transaction Propagation）是指在<code>多个事务之</code>间进行交互和传递的规则。当一个<code>方法被调用</code>时，如果该方法已经<code>处于一个事务中</code>，事务传播行为定义了新事务的<code>创建</code>、<code>加入</code>或与现有事务<code>共享</code>的方式。</p><ul><li><strong>PROPAGATION_REQUIRED：</strong>如果当前没事事务，就创建一个新事务，如果当前存在事务，就<code>加入该事务</code>，该设置时最常使用的配置</li><li><strong>PROPAGATION_SUPPORTS：</strong>支持当前事务。如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行</li><li><strong>PROPAGATION_MANDATORY：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在该事务，就抛出异常</li><li><strong>PROPAGATION_REQUIRES_NEW：</strong>创建<code>新事务</code>，无论当前存不存在事务，都创建新事务</li><li><strong>PROPAGATION_NOT_SUPPORTED：</strong>以非事务的方式执行操作，如果当前存在事务，就把当前事务挂起</li><li><strong>PROPAGATION_NEVER：</strong>以非事务方式运行，如果当前存在事务，则抛出异常 </li><li><strong>PROPAGATION_NESTED：</strong>如果当前存在事务，就嵌套在该事务内执行，如果当前没有事务，则执行PROPAGATION_REQUIRED相关操作</li></ul><h6 id="本地事务失效问题"><a href="#本地事务失效问题" class="headerlink" title="本地事务失效问题"></a>本地事务失效问题</h6><p>同一个对象内多个事务方法互调失效，原因是绕过了代理对象（相当于直接将那部分代码片段复制粘贴过来）</p><p>可能会有自己注入自己的想法，这样是不行的，会出现循环依赖的问题</p><p>解决方法：使用代理对象来调用事务方法</p><p>开启aspectj动态代理功能，然后对外暴露代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0)、导入spring-boot-starter-aop，引入aspectj</span></span><br><span class="line"><span class="comment">//1)、@EnableTransactionManagement(proxyTargetClass= true)对外暴露代理对象</span></span><br><span class="line"><span class="comment">//2)、@EnableAspectJAutoProxy(lexposeProxy-true)开启aspectj动态代理功能</span></span><br><span class="line"><span class="comment">//3)、AopContext.currentProxy() 调用方法</span></span><br><span class="line"><span class="meta">@Transcational</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">OrderServiceImpl</span> <span class="variable">orderService</span> <span class="operator">=</span> (OrderServiceImpl)AopContext.currentProxy();</span><br><span class="line">    orderService.b();</span><br><span class="line">    orderService.c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transcational</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Transcational</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="事务实现机制"><a href="#事务实现机制" class="headerlink" title="事务实现机制"></a>事务实现机制</h4><p>在 Spring 框架中，事务管理的功能是通过动态代理机制来实现的。在 Spring 中，当一个类或对象被标记为 <code>@Transactional</code> 注解时，Spring 会在<code>运行</code>时生成该类或对象的<code>代理对象</code>，并通过代理对象来管理事务。代理对象会<code>拦截</code>被标记的方法的调用，并在方法<code>执行前后进行事务管理的操作</code>。</p><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>一种在运行时创建代理对象的机制，它允许在不修改原始类的情况下，通过代理对象来增强或改变原始类的行为。</p><p>在动态代理中，代理对象在运行时通过<code>反射机制</code>动态创建，而不是在编译时确定。动态代理可以在不改变原始类的情况下，为原始类的方法提供额外的功能，例如添加日志、实现事务管理、权限控制等。</p><p>Java 中提供了两种动态代理的机制：<code>JDK</code> 动态代理和 <code>CGLIB</code> 动态代理。</p><ol><li>JDK 动态代理：JDK 动态代理是基于<code>接口</code>的代理，通过 <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口实现。JDK 动态代理要求<code>目标类实现接口</code>，并且代理对象生成的过程是通过创建代理类的实例来实现的。</li><li>CGLIB 动态代理：CGLIB（Code Generation Library）动态代理是基于<code>继承</code>的代理，通过生成<code>目标类的子类</code>来实现代理。CGLIB 动态代理不要求目标类实现接口，它通过<code>继承目标类并重写其方法</code>来生成代理对象.</li></ol><blockquote><p>也就是事务是基于动态代理实现的，动态代理根据类的不同，又有JDK和CGLIB两种方法实现</p></blockquote><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><h5 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h5><p>CAP 原则又称 CAP 定理指的是在一个分布式系统中</p><ul><li><strong>一致性（Consistency）</strong><ul><li>在分布式系统中<code>所有数据</code>备份，在<code>同一时刻</code>是否是同样的值，（等同于所有节点访问同一份最新数据的副本）</li></ul></li><li><strong>可用性（Avaliability）</strong><ul><li>在集群中一<code>部分节点故障</code>后，集群整体是否还能响应客户端的读写请求，（对数据更新具备高可用性）</li></ul></li><li><strong>分区容错性（Partition tolerance）</strong>    分布式多服务下肯定会遇到（都在本地不会）<ul><li>大多数分布式系统都分布在多个子网络，每个子网络叫做一个区（partition）。分区容错性的意思是，<code>区间通信可能失败</code>，比如，一台服务器放在中国另一台服务器放在美国，这就是两个区，它们之间可能无法通信</li></ul></li></ul><p>CAP 的原则是，这三个要素最多只能满足两个点，<strong>不可能三者兼顾</strong></p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230615155119274.png" alt="image-20230615155119274"></p><p>实现CP的一致性算法-raft</p><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p>最终目的，实现<code>AP</code>，也就是高可用性</p><h5 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h5><p>是对CAP的延申，思想即是无法做到强一致性（CAP的一致性就是强一致性），但可以采用适当的弱一致性，即**<code>最终一致性</code>**</p><p>BASE 是指</p><ul><li><strong>基本可用（Basically Avaliable）</strong><ul><li>基本可用是指分布式系统中在出现故障的时候，允许<code>损失部分可用性</code>（列入响应时间，功能上的可用性）允许损失部分可用性。需要注意的是基本可用不等价于系统不可用</li><li>响应<code>时间上的损失</code>，正常情况下搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房断电断网故障），查询的结果响应时间增加到了1~2秒</li><li>功能上的损失，购物网站双十一购物高峰，为了保证系统的稳定性，部分消费者会被引入到一个<code>降级</code>页面</li></ul></li><li><strong>软状态（Soft State）</strong><ul><li>软状态是指允许 系统<code>存在中间状态</code>，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有 多个副本，允许<code>不同副本同步的延时</code>就是软状态的体现。mysglreplication的异步复制也是一种体现。</li></ul></li><li><strong>最终一致性( Eventual Consistency)</strong><ul><li>最终致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul></li></ul><h5 id="分布式事务的几种方案"><a href="#分布式事务的几种方案" class="headerlink" title="分布式事务的几种方案"></a>分布式事务的几种方案</h5><h6 id="1-2PC模式"><a href="#1-2PC模式" class="headerlink" title="1.2PC模式"></a>1.2PC模式</h6><p>数据库支持的 2PC[2 phase commit 二阶提交]</p><p>第一阶段：事务协调器要求每个涉及到事务的数据库<code>预提交</code>（precommit）此操作，并<code>反应是否可以提交</code></p><p>第二阶段：事务协调器<code>要求每个数据库提交数据</code>,其中，如果有任何一个数据库否认这次提交，那么<code>所有</code>数据库都会要求<code>回滚</code>他们在此事务中的那部分信息</p><p>实现简单，成本小，效果不理想</p><p>也有3PC,引入了<code>超时机制</code>(无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理)</p><h6 id="2-柔性事务-TCC-事务补偿"><a href="#2-柔性事务-TCC-事务补偿" class="headerlink" title="2.柔性事务 - TCC 事务补偿"></a>2.柔性事务 - TCC 事务补偿</h6><p>刚性事务:遵循ACID原则，强一致性。<br>柔性事务:遵循BASE理论，最终一致性;<br>与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。</p><p>一阶段 prepare 行为:调用自定义的 prepare 逻辑。<br>二阶段 commit 行为:调用自定义的 commit 逻辑。<br>二阶段 rollback行为:调用自定义的 rollback 逻辑。<br>所谓TCC模式，是指支持把自定义的分支事务纳入到全局事务的管理中。</p><p>其实就是通过业务实现补偿方案，事务失败需要回滚了再调用补偿方法</p><h6 id="3-柔性事务-最大努力通知型方案"><a href="#3-柔性事务-最大努力通知型方案" class="headerlink" title="3.柔性事务 - 最大努力通知型方案"></a>3.柔性事务 - 最大努力通知型方案</h6><p>按规律进行通知，<strong>不保证数据定能通知成功， 但会提供可查询操作接口进行核对</strong>。这种方案主要用在与第三方系统通讯时，比如:调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ进行实现，例如:通过MQ发送http请求，设置最大通知次数。达到通知次数后即不再通知。</p><p>也就是通过<code>消息队列</code>对各个需要回滚的服务发送失败的通知。最大努力通知，不需要响应</p><h6 id="4-柔性事务-可靠信息-最终一致性方案（异步通知型）"><a href="#4-柔性事务-可靠信息-最终一致性方案（异步通知型）" class="headerlink" title="4.柔性事务 - 可靠信息 + 最终一致性方案（异步通知型）"></a>4.柔性事务 - 可靠信息 + 最终一致性方案（异步通知型）</h6><p>实现:业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</p><p>需要响应</p><h4 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h4><p>开源的分布式事务解决方案</p><p>实现主要包括以下几个关键组件</p><ol><li>TC（Transaction Coordinator）：事务协调器，<code>负责协调和管理全局事务</code>。它接收事务发起方的事务请求，并<code>将全局事务分解为多个分支事务</code>，并将每个分支事务的执行结果进行汇总和判断，最终决定全局事务的提交或回滚。</li><li>TM（Transaction Manager）：事务管理器，用于管理和协调<code>全局事务</code>。它<code>与TC进行通信</code>，控制全局事务的提交、回滚和状态同步。</li><li>RM（Resource Manager）：资源管理器，负责管理<code>本地事务资源</code>。每个参与全局事务的数据库或其他资源都有对应的RM，它负责控制和管理本地事务的提交、回滚和状态反馈。</li></ol><p>TM是事务的管理者，负责<code>发起</code>和管理分布式事务，而TC是事务的协调者，负责<code>协调</code>和控制分布式事务的执行。<code>TC</code>与TM进行通信，与各个参与者进行通信，收集和汇总分支事务的状态，<code>最终决定全局事务的最终状态</code>，并通知各个参与者执行相应操作。</p><p>模式</p><ol><li><p>AT（Auto-Commit）模式：在AT模式下，Seata通过在业务代码中嵌入事务参与注解，将<code>事务</code>操作<code>划分为一系列的本地事务</code>，并通过对本地事务的执行<code>结果进行补偿</code>来保证全局事务的一致性。（基于二阶提交）会加很多锁，不适合高并发场景</p><ol><li><p>在每个微服务数据库中都存有一张undo_log表，用来记录日志信息</p></li><li><p>下载seata服务器，也就是TC   （通过配置文件可以选择记录在哪里，文件或者db）</p></li><li><p>所有想要用到分布式事务的微服务都使用seata代理数据源（包装）</p></li><li><p>大事务标注@GlobalTransactional，小事务标注@Transactional就行</p></li></ol></li><li><p>TCC（Try-Confirm-Cancel）模式：在TCC模式下，Seata通过定义Try、Confirm和Cancel三个阶段的操作接口，将事务操作分为三个阶段，并通过执行对应的阶段操作来确保全局事务的一致性。</p></li><li><p>SAGA模式：SAGA模式是一种基于补偿事务的模式，它通过定义一系列的补偿操作来实现全局事务的一致性，即在出现异常或失败情况下执行相应的补偿操作来回滚已执行的操作。</p></li></ol><h3 id="延迟队列-实现定时任务"><a href="#延迟队列-实现定时任务" class="headerlink" title="延迟队列(实现定时任务)"></a>延迟队列(实现定时任务)</h3><p>优点：减少资源占用</p><blockquote><p>rabbitmq的消息ttl(存活时间)和死信Exchange结合</p></blockquote><h5 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h5><p>也就是消息的存活时间</p><p>rabbitmq可以对队列和消息分别设置ttl。</p><ul><li>对队列设置就是没有消费者连着的保留时间，也可以<code>对每一个单独的消息做单独的设置，超过了这个时间，我们认为这个消息就死了，称之为死信</code>。如果队列和消息都有存活时间，那么就取小的，所以一个消息被路由到不同的队列中，死亡时间可能不一样。</li></ul><h5 id="DLX（死信路由）"><a href="#DLX（死信路由）" class="headerlink" title="DLX（死信路由）"></a>DLX（死信路由）</h5><p>一个消息在满足如下条件，会进入死信路由(一个路由可以对应很多个队列)</p><ul><li>消息被Consumer<code>拒收</code>了，并且reject方法的参数里<code>requeue是false</code>，也就是说不会再次放在队列里被其他消费者使用了</li><li>消息的<code>ttl到了</code>，消息到期了</li><li>队列<code>长度限制</code>满了。排在<code>前面的</code>消息会被丢弃或者扔到死信路由上</li></ul><p>死信路由也就是一个普通路由。</p><p><strong>也就是控制消息在一段时间后变成死信，又可以控制死信的消息被路由到某一个指定的交换机，结合二者，实现一个延时队列。</strong></p><h6 id="MQ采用惰性检查机制"><a href="#MQ采用惰性检查机制" class="headerlink" title="MQ采用惰性检查机制"></a>MQ采用惰性检查机制</h6><p>也就是队列里依次放入两个消息，一个五分钟过期，一个一分钟过期，在五分钟过期的消息出去前，一分钟过期的消息无法被消费。所以这里的过期时间设置为队列的过期时间。</p><h3 id="可靠消息"><a href="#可靠消息" class="headerlink" title="可靠消息"></a>可靠消息</h3><p>如何保证消息的可靠性？</p><h4 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失*"></a>消息丢失*</h4><ol><li><p>由于网络问题，发出去的消息没有抵达服务器</p><p>容错方案、日志记录、定期重发</p></li><li><p>消息抵达Broker，Broker要将消息写入磁盘(持久化)才算成功，如果此时Broker尚未持久化完成，宕机。</p><p>publisher(消息发送者)也必须加入确认回调机制，确认成功的消息,修改数据库消息状态(也就是<code>确保消息能够送达</code>)</p></li><li><p>自动ack的状态下，消费者收到消息，没来得及消费就宕机了</p><p>开启手动ack，消费成功才移除，失败或者没来得及处理就noAck并重新入队</p></li></ol><h4 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h4><ul><li>消息消费成功，事务已经提交(业务处理完了)，<code>ack时，宕机</code>，导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者</li></ul><p>​使得该业务具有幂等性\防重表\消息有redelivered字段可以获取是否是重新投递过来的</p><h4 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h4><ul><li><p>消费者宕机积压、消费能力不足积压、发送者发送流量太大</p><p>上线更多的消费者、上线专门的队列消费服务，先将消息取出来记录数据库，离线慢慢处理</p></li></ul><h2 id="十二、支付"><a href="#十二、支付" class="headerlink" title="十二、支付"></a>十二、支付</h2><p>使用支付宝的SDK进行支付</p><h3 id="公钥、私钥、签名、验签"><a href="#公钥、私钥、签名、验签" class="headerlink" title="公钥、私钥、签名、验签"></a>公钥、私钥、签名、验签</h3><p>是一种相对的概念，公钥是可以暴露给外部的</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密解密用同一把钥匙</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>加密解密使用不同的钥匙，自己使用私钥加密之后要告诉接受方使用哪一把公钥解密</p><h3 id="支付宝加密传输流程"><a href="#支付宝加密传输流程" class="headerlink" title="支付宝加密传输流程"></a>支付宝加密传输流程</h3><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230616224848625.png" alt="image-20230616224848625"></p><h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>其实就是服务商进行一个代理，分给一个临时域名</p><h2 id="十三、秒杀"><a href="#十三、秒杀" class="headerlink" title="十三、秒杀"></a>十三、秒杀</h2><p>特点：瞬间高并发</p><p>针对方法：限流+异步+缓存（页面静态化）+独立部署 </p><h3 id="定时任务进行上架"><a href="#定时任务进行上架" class="headerlink" title="定时任务进行上架"></a>定时任务进行上架</h3><p>用于商品定时上架，可以在半夜上架最近三天需要秒杀的商品，上架也就是将商品信息从数据库存到redis中</p><p>使用quartz以及corn表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Compenent</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>开启定时任务</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloSchedule</span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled(corn = &quot;******&quot;)</span><span class="comment">// spring由6位组成，不包括年 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="定时任务的使用"><a href="#定时任务的使用" class="headerlink" title="定时任务的使用"></a>定时任务的使用</h4><p>![1687182008052](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1687182008052.png)</p><ul><li>定时任务默认是阻塞的，也就是前一个结束了，后一个才执行，所以需要使用异步编排</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(()-&gt;&#123;<span class="comment">// 以异步方式自己提交到线程池</span></span><br><span class="line">    xxxService.hello();</span><br><span class="line">&#125;,executor);</span><br></pre></td></tr></table></figure><ul><li>定时任务阻塞的原因是他的线程池里面只有一个线程，通过调整这个数量也可以实现非阻塞</li><li>开启异步任务功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span><span class="comment">// 大类上 开启异步任务功能</span></span><br><span class="line"><span class="meta">@Async</span><span class="comment">//方法上</span></span><br></pre></td></tr></table></figure><h4 id="上架的一些细节"><a href="#上架的一些细节" class="headerlink" title="上架的一些细节"></a>上架的一些细节</h4><ol><li>信号量（Semaphore）：信号量是一种用于控制并发访问资源的机制。在秒杀服务中，信号量可以用来限制同时访问某个资源（如库存）的线程数量，以<code>防止超卖和保证库存的安全性</code>。秒杀活动中的库存数量通常是有限的，通过设置适当的信号量，可以控制并发请求的数量，避免超过库存限制导致商品被抢购完毕。</li><li>随机码（Random Code）：随机码用于<code>增加商品秒杀的唯一性和安全性</code>。每个商品在上架时生成一个随机码，并与用户的秒杀请求进行匹配。这样可以防止恶意用户通过脚本或工具自动化发起大量的请求，保证秒杀的公平性和防止刷单行为。同时，随机码的生成和校验可以采用加密算法或哈希函数，增加系统的安全性和难以破解性。</li><li>信号量用于<code>控制并发请求</code>的数量，保证秒杀活动在有限的资源（如库存）下的公平性和安全性。</li><li>随机码用于增加商品秒杀的唯一性和安全性，防止恶意用户的刷单行为和提高系统的安全性。随机码就是时间到了才可以参与秒杀，请求需要带着这个随机码。</li></ol><h3 id="上架操作的幂等性处理"><a href="#上架操作的幂等性处理" class="headerlink" title="上架操作的幂等性处理"></a>上架操作的幂等性处理</h3><p>![1687181175070](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1687181175070.png)</p><p>加入分布式锁：在<code>锁内判断</code>redis是不是已经有了这个数据，没有再添加。</p><h3 id="高并发的一些问题"><a href="#高并发的一些问题" class="headerlink" title="高并发的一些问题"></a>高并发的一些问题</h3><p>![1687182389914](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1687182389914.png)</p><p>  ![1687182623697](D:\WeChatFile\WeChat Files\wxid_cii3gqlpyfgm22\FileStorage\Temp\1687182623697.png)</p><ul><li>使用信号量确保不会有过多的请求进来,这里注意</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tryAcquire:尝试获取信号量，如果可用，返回<span class="literal">true</span>，不可用则立即返回<span class="literal">false</span>，不会等待(可以设置时间)</span><br><span class="line">acquire:尝试获取信号量，可用立马返回，不可用则阻塞等待</span><br></pre></td></tr></table></figure><ul><li>使用消息队列进行削峰</li></ul><p>​放到队列慢慢消费</p><h4 id="SpringCloud-Alibaba-Sentinel"><a href="#SpringCloud-Alibaba-Sentinel" class="headerlink" title="SpringCloud Alibaba - Sentinel"></a>SpringCloud Alibaba - Sentinel</h4><h5 id="熔断限流降级"><a href="#熔断限流降级" class="headerlink" title="熔断限流降级"></a>熔断限流降级</h5><p>熔断：A-&gt;B,由于b服务卡机或者网络问题，导致功能时间过长，如果这样的次数太多，就可以直接将b断路了（A不在请求B），调用b的直接返回降级数据，不去等待执行，这样b的问题不回级联影响a</p><p>降级：比如此功能不可用，将某个业务降级，调用直接返回降级数据</p><ul><li>熔断：熔断是一种保护机制，用于在服务出现故障或异常时，快速切断对该服务的访问，以避免对整个系统的连锁故障影响。</li><li>降级：降级是一种优化策略，用于在系统资源紧张或异常情况下，临时屏蔽或替换某些功能或服务，以确保核心功能的可用性和性能。</li><li>限流：对于打入服务的请求流量进行控制，是服务能够承担不超过自己能力的流量压力</li></ul><p>总的来说，熔断和降级都是为了保护系统的<code>稳定性</code>和<code>可用性</code>，但熔断更注重快速失败和对故障的快速响应，而降级更注重资源的合理利用和保证核心功能的正常运行。也就是熔断是被调用方故障，触发的<code>系统主动</code>规则，降级是基于<code>全局考虑</code>，停止一些正常服务，释放资源(可能手动)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis相关</title>
      <link href="/2023/05/31/Redis%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/05/31/Redis%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h2><h3 id="为什么要用Redis"><a href="#为什么要用Redis" class="headerlink" title="为什么要用Redis"></a><strong>为什么要用Redis</strong></h3><ol><li><p>高性能：假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p></li><li><p>高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p></li></ol><h3 id="使用Redis有哪些好处"><a href="#使用Redis有哪些好处" class="headerlink" title="使用Redis有哪些好处"></a>使用Redis有哪些好处</h3><ol><li><code>速度快</code>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>支持<code>丰富数据类型</code>，支持string，list，set，sorted set，hash</li><li>支持事务，操作都是<code>原子性</code>，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ol><h3 id="为什么要用Redis而不用map-x2F-guava做缓存"><a href="#为什么要用Redis而不用map-x2F-guava做缓存" class="headerlink" title="为什么要用Redis而不用map&#x2F;guava做缓存"></a>为什么要用Redis而不用map&#x2F;guava做缓存</h3><p>缓存分为<code>本地缓存</code>和<code>分布式缓存</code>。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，<code>每个实例都需要各自保存一份缓存</code>，<code>缓存不具有一致性</code>。</p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，<code>缓存具有一致性</code>。缺点是需要保持 redis 或 memcached服务的高可用，整个程序<code>架构上较为复杂</code>。</p><h3 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h3><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做<code>单线程的模型</code>。它采用 <code>IO 多路复用机制</code>同时监听多个 <code>socket</code>，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 socket 可能会<code>并发</code>产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会<code>监听多个 socket</code>，会将 socket 产生的事件放入<code>队列</code>中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF（Append-Only File）备份是Redis的一种持久化方式，用于将Redis的操作日志以追加的方式写入到<code>磁盘文件</code>中，从而实现数据的持久化存储。</p><p>AOF备份具有以下特点：</p><p>持久化：AOF备份方式可以将Redis的操作日志<code>持久化到磁盘</code>，以保证数据在<code>服务器重启后的恢复</code>。</p><p>追加写入：AOF文件以<code>追加写入</code>的方式记录命令操作，避免了频繁的磁盘写入操作，<code>提高了写入性能</code>。指写入的时候写入到AOF文件尾部，形成一个不断增长的操作日志，相对应的是覆盖写入。</p><p><code>可读性</code>：AOF文件是以文本格式保存的，可以方便地进行查看和分析。</p><p>容错性：AOF文件中的操作日志是<code>顺序追加的</code>，可以通过重新执行AOF文件中的命令来恢复数据。</p><h3 id="Redis常见性能问题和解决方案"><a href="#Redis常见性能问题和解决方案" class="headerlink" title="Redis常见性能问题和解决方案"></a>Redis常见性能问题和解决方案</h3><ol><li><p>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</p></li><li><p>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p></li><li><p>为了主从复制的速度和连接的稳定性，最好在同一个局域网内</p></li></ol><h3 id="Redis设置过期时间"><a href="#Redis设置过期时间" class="headerlink" title="Redis设置过期时间"></a>Redis设置过期时间</h3><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库， 这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统 的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p><p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的 时间。</p><h4 id="定期删除-惰性删除"><a href="#定期删除-惰性删除" class="headerlink" title="定期删除+惰性删除"></a>定期删除+惰性删除</h4><ul><li>定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删 除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所 有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li><li>惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这 就是所谓的惰性删除，也是够懒的哈！</li></ul><p>如果定期删除漏掉了很多过期 key，然后你也没及时去查， 也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题 呢？</p><p><strong>redis 内存淘汰机制。</strong></p><h3 id="如何保证redis中的数据都是热点数据"><a href="#如何保证redis中的数据都是热点数据" class="headerlink" title="如何保证redis中的数据都是热点数据"></a>如何保证redis中的数据都是热点数据</h3><p>Mysql有2000万数据，redis只存20万，如何保证redis中的数据都是热点数据</p><p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：</p><ul><li>voltile-lru：从<strong>已设置过期时间的数据集</strong>（server.db[i].expires）中挑选<code>最近最少使用</code>的数据淘汰</li><li>volatile-ttl：从<strong>已设置过期时间的数据集</strong>（server.db[i].expires）中挑选<code>将要过期</code>的数据淘汰</li><li>volatile-random：从<strong>已设置过期时间的数据集</strong>（server.db[i].expires）中<code>任意选择</code>数据淘汰</li><li>allkeys-lru：从<strong>数据集</strong>（server.db[i].dict）中挑选<code>最近最少使用</code>的数据淘汰</li><li>allkeys-random：从<strong>数据集</strong>（server.db[i].dict）中<code>任意</code>选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些基础知识</title>
      <link href="/2023/05/08/%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/08/%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h2><p>jar包就是 Java Archive File。其实就是一个项目的打包,或者说是一些能够直接拿来用的业务模块。</p><p>jar 与 zip 唯一的区别就是在 jar 文件的内容中，包含了一个 META-INF&#x2F;MANIFEST.MF 文件，该文件是在生成 jar 文件的时候自动创建的，作为jar里面的”详情单”，包含了该Jar包的版本、创建人和类搜索路径Class-Path等信息，当然如果是可执行Jar包，会包含<code>Main-Class</code>属性，表明<code>Main方法入口</code>，尤其是较为重要的Class-Path和Main-Class。</p><p>有的jar包是可以直接通过 <code>java -jar</code> 指令来执行的。</p><p>当我们开发了一个程序以后，程序中有很多的类，如果需要提供给别人使用,发给对方一大堆源文件是非常不好的，因此通常需要把这些类以及相关的资源文件打包成一个 jar 包,把这个 jar 包提供给别人使用,同时提供给使用者清晰的文档。这样他人在拿到我们提供的jar之后，就能方便地进行调用。而且安全。能够对JAR文件进行数字签名，只让能够识别数字签名的用户使用里面的东西。</p><p>由于jvm实际解析的是.class字节码文件而非.java文件，且jar中最好不要包含代码源文件，将.class文件打个jar包，在src根目录下执行如下指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf welcome.jar com/imooc/jardemo1/Welcome.<span class="keyword">class</span> <span class="title class_">com</span>/imooc/jardemo1/impl/Teacher.class</span><br></pre></td></tr></table></figure><p>c表示要创建一个新的jar包，v表示创建的过程中在控制台输出创建过程的一些信息，f表示给生成的jar包命名</p><p>打jar的时候，会生成一个META-INF的目录，里面有&#96;&#96;这个清单列表。要使得jar包能直接运行，需要在清单加上<code>Main-Class</code>，后接main函数所在类的全路径名（注意冒号之后一定要跟英文的空格，整个文件最后有一行空行）。</p><p>在包含调用关系时，需要在<code>MANIFEST.MF</code>中配置<code>Class-Path</code>（如果是多个jar，则用英文空格隔开）。CLASSPATH是<code>指定程序中所使用的类文件所在的位置</code>。</p><h2 id="关于String"><a href="#关于String" class="headerlink" title="关于String"></a>关于String</h2><p>1.如何实现string的equals()方法</p><h2 id="hsahcode"><a href="#hsahcode" class="headerlink" title="hsahcode"></a>hsahcode</h2><p>每个 Java 对象都有一个默认的 hashCode() 实现，该实现<code>一般基于对象的内存地址</code>计算哈希码。通常情况下，每个对象的哈希码是不同的，因为每个对象在内存中都有其自己的地址。但是，如果两个对象的内存地址相同，它们的哈希码也相同。</p><p>HashCode是根据对象的<code>内容</code>生成的一个整数值(重写了hashcode方法)，用于快速地判断对象在哈希表等数据结构中的位置。值得注意的是，根据对象的内容生成哈希码时，应该保证<code>相等的对象具有相同的哈希码</code>，但<code>不要求不相等的对象具有不同的哈希码</code>。这是因为哈希码是一个有限的整数范围，而对象的内容可能是无限的，因此<code>不同对象的内容可能会产生相同的哈希码</code>（这就是哈希冲突）。</p><p>哈希冲突是不能避免的,只能进行优化,比如散列函数优化\开放地址\链表法\再哈希.</p><h2 id="B站倍速"><a href="#B站倍速" class="headerlink" title="B站倍速"></a>B站倍速</h2><p>控制台：document.querySelector(‘video’).playbackRate&#x3D;2.5</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/05/07/Spring/"/>
      <url>/2023/05/07/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Ioc和Aop"><a href="#Ioc和Aop" class="headerlink" title="Ioc和Aop"></a>Ioc和Aop</h2><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>IoC（<code>Inverse of Control</code>:控制反转）是一种<code>设计思想</code>，就是将原本在程序中手动<code>创建对象</code>的控制权，交由Spring框架来管理。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个<code>Map（key，value）</code>,<code>Map 中存放的是各种对象</code>。IOC底层就是个对象工厂。</p><p>将<code>对象之间的相互依赖关系</code>交给 IoC 容器来管理，并由 IoC 容器完成<code>对象的注入</code>。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要<code>配置好配置文件/注解</code>即可，完全<code>不用考虑对象是如何被创建出来的</code>。默认无参构造。</p><p>####Ioc实现方式（两个接口）</p><p>1.BeanFactory</p><p>Spring内部接口。（功能：加载配置文件、创建对象）</p><p>在加载配置文件的时候不会创建对象、获取时才创建。</p><p>2.ApplicationContext</p><p>BeanFactory子接口，功能更多更强。(启动时实现、启动更慢、运行效率更高)</p><p>加载配置文件的时候就会创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载spring配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取配置创建的对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">uesr</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>,User.class);<span class="comment">// &quot;user&quot;为对象标识，&lt;bean id = &quot;user&quot; class =&quot;com.User&quot;&gt;&lt;/bean&gt;</span></span><br></pre></td></tr></table></figure><p>####Bean管理</p><p>Bean管理就是两个操作：（1）Spring创建对象；（2）Spring注入属性（DI）</p><p>两种方式：1.基于xml配置文件（bean标签）。2.基于注解</p><h4 id="基于注解的方式创建对象"><a href="#基于注解的方式创建对象" class="headerlink" title="基于注解的方式创建对象"></a>基于注解的方式创建对象</h4><p>1.引入依赖</p><p>2.开启组件扫描</p><h4 id="IoC初始化流程"><a href="#IoC初始化流程" class="headerlink" title="IoC初始化流程"></a>IoC初始化流程</h4><p>由refresh()方法启动</p><ul><li><p><code>Resource资源定位</code>：这个Resouce指的是<code>BeanDefinition的资源定位</code>。这个过程就是<code>容器找数据</code>的过程，就像水桶装水需要先找到水一样。</p></li><li><p><code>BeanDefinition的载入和解析</code>：这个载入过程是<code>把用户定义好的Bean表示成Ioc容器内部的数据结构</code>，而这个容器内部的数据结构就是BeanDefition，也就是将定义好的Bean载入成BeanDefinition。一般会使用xml注解，现在也可以使用注解。</p></li><li><p><code>BeanDefinition注册</code>–BeanDefinition向IOC容器的注册过程</p></li><li><p>prepareRefresh()：预备一下， 标记启动时间，上下文环境，我要的材料（beanDefinition）准备好了嘛？</p></li><li><p>obtainFreshBeanFactory()：</p><ul><li>如果已经有了BeanFactory就<code>销毁</code>它里面的<code>单例Bean</code>并关闭这个BeanFactory。</li><li>创建一个新的BeanFactory。</li><li>对这个BeanFactory进行<code>定制</code>（customize),如allowBeanDefinitionOverriding等参数</li><li>转载BeanDefinitions(读取<code>配置文件</code>，将xml转换成对应得BeanDefinition)</li><li>检查是否同时启动了两个BeanFactory。</li></ul></li><li><p>prepareBeanFactory(beanFactory)：<code>设置</code>beanFactory的<code>类加载器</code>，材料（BeanDefinition）<code>解析器</code>等</p></li><li><p>postProcessBeanFactory(beanFactory)：</p><ul><li><code>设置</code>beanFactory的<code>后置处理器</code></li><li>具体的子类可以在这步的时候添加一些特殊的BeanFactoryPostProcessor的实现类或做点什么事</li></ul></li><li><p>invokeBeanFactoryPostProcessors(beanFactory)：</p><ul><li><code>调用</code>beanFactory的<code>后置处理器</code>（BeanDefinitionRegisterPostProcessor和BeanFactoryPostProcessor）</li><li>调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</li></ul></li><li><p>registerBeanPostProcessors(beanFactory)：</p><ul><li>注册 BeanPostProcessor 的实现类（bean的后置处理器）</li><li>此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</li></ul></li><li><p>initMessageSource()：对上下文中的消息源进行初始化</p></li><li><p>initApplicationEventMulticaster()：初始化上下文的事件广播器</p></li><li><p>onRefresh()：- 模版方法，具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</p></li><li><p>registerListeners()：注册事件监听器</p></li><li><p>finishBeanFactoryInitialization(beanFactory)：初始化所有的 singleton beans</p></li><li><p>finishRefresh()：最后，广播事件，ApplicationContext 初始化完成</p></li></ul><h4 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h4><p>1.通过构造器创建bean实例（无参构造）</p><p>2.为bean 的属性设置值和对其他bean的引用（内部、外部）（调用set方法）</p><p>3.调用bean 的初始化方法（需要进行配置）（init-method）</p><p>4.获取到对象</p><p>5.容器关闭的时候，调用bean 的销毁方法（需要进行配置销毁的方法）(destory-method)</p><h4 id="Bean自动注入"><a href="#Bean自动注入" class="headerlink" title="Bean自动注入"></a>Bean自动注入</h4><p>1.按名称</p><p>2.按类型</p><h3 id="getBean"><a href="#getBean" class="headerlink" title="getBean()"></a>getBean()</h3><p>可以使用接口<code>ApplicationContext</code>中的getBean()方法来获取Spring容器中<code>已初始化的bean</code></p><p>有四种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getBean(String name)</span><br><span class="line">getBean(Class&lt;T&gt; type)</span><br><span class="line">getBean(String name,Class&lt;T&gt; type)</span><br><span class="line">getBean(String name,Object[] args)</span><br></pre></td></tr></table></figure><p>###Spring注解</p><p>1、spring作用在类上的注解有<code>@Component</code>、<code>@Responsity</code>、<code>@Service</code>以及<code>@Controller</code>；而<code>@Autowired</code>和<code>@Resource</code>是用来修饰<code>字段</code>、<code>构造函数</code>或者<code>设置方法</code>，并做注入的。</p><p>2、当注解作用在类上时，表明这些类是交给spring容器进行管理的，而当使用@Autowired和@Resource时，表明我需要某个属性、方法或字段，但是并不需要我自己去new一个，只需要使用注解，spring容器会自动的将我需要的属性、方法或对象创造出来。这就是通常所说的依赖注入和控制反转。</p><p>####@Component注解</p><p>在<code>持久层</code>、<code>业务层</code>和<code>控制层</code>中，分别采用<code>@Repository（实现dao访问）</code>、<code>@Service 服务（注入dao)</code>和<code>@Controller控制器（注入服务）</code>对分层中的类进行注入，而用<code>@Component</code>对那些比较<code>中立的类</code>进行实例化注入。</p><p>这个注解的意思就是将这个类交给spring管理。</p><p>####@Autowired</p><p>根据属性类型进行自动装配</p><p>1.把service和dao对象创建，在service和dao类添加创建对象注解</p><p>2.在service注入dao对象，在service类添加dao类型属性，在属性上使用注解</p><p>####@Qualifier</p><p>根据属性名称进行注入</p><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>可以根据类型也可以根据名称</p><p>####@Value</p><p>注入普通属性类型</p><h3 id="Spring中bean的销毁"><a href="#Spring中bean的销毁" class="headerlink" title="Spring中bean的销毁"></a>Spring中bean的销毁</h3><p>####doCreateBean()</p><p>doCreateBean(beanName, mbd, args) 的主要方法<code>流程</code>：（重点）</p><ul><li><code>createBeanInstance</code>(beanName, mbd, args)：实例化 bean</li><li><code>addSingletonFactory</code>(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))：将已完成实例化，但是<code>未完成属性赋值和相关的初始化</code>的一个<code>不完整的 bean</code> 添加到三级缓存 singletonFactories 中</li><li><code>populateBean</code>(beanName, mbd, instanceWrapper)：对 bean 进行<code>属性填充注入</code></li><li><code>initializeBean</code>(beanName, exposedObject, mbd)：完成 bean 的属性填充注入后，<code>进一步初始化 </code>bean，在此过程中<code>产生代理对象</code>。此时 bean 的创建工作正式完成，已经可以在项目中使用了</li><li><code>registerDisposableBeanIfNecessary</code>(beanName, bean, mbd)：如果符合 bean 的销毁条件，则执行单例bean 的销毁工作</li></ul><p>####给bean设置销毁方法的方式</p><ul><li>通过 <code>xml</code> 文件配置 <code>destroy-method</code> 标签属性指定的 <code>destroy</code> 方法</li><li>通过注解 <code>@Bean</code> 可以使用属性指定销毁的方</li><li>实现 <code>DisposableBean</code> 接口</li><li>销毁方法名为接口情况下，有 <code>close</code> 或者 <code>shutdown</code> 方法</li></ul><h4 id="什么样的bean能被销毁"><a href="#什么样的bean能被销毁" class="headerlink" title="什么样的bean能被销毁"></a>什么样的bean能被销毁</h4><ul><li><code>bean</code> 的作用域是单例时</li><li>给 <code>bean</code> 设置了销毁方法或有 <code>DestructionAwareBeanPostProcessor</code> 实现类时</li></ul><p>详细：<a href="https://blog.csdn.net/weixin_38192427/article/details/116546600">Spring源码之bean的销毁registerDisposableBeanIfNecessary方法解读_桐花思雨的博客-CSDN博客</a></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所<code>共同调用的逻辑或责任</code>（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><ul><li>Spring AOP就是<code>基于动态代理</code>的</li><li>如果要代理的对象，<code>实现了某个接口</code>，那么Spring AOP会使用<code>JDK Proxy</code>，</li><li>而对于<code>没有实现接口的对象</code>，这时候Spring AOP会使用 <code>Cglib </code>生成一个被代理对象的<code>子类</code>来作为代理。</li></ul><p>register<code>AspectJ</code>AnnotationAutoProxyCreatorIfNecessary</p><ul><li>第一句，<code>注册</code>一个AnnotationAwareAspectJAutoProxyCreator（称它为自动代理器），这个Creator是AOP的操作核心，也是扫描Bean，代理Bean的操作所在。</li><li>第二句，<code>解析配置元素</code>，决定代理的模式。其中有JDK动态代理，还有CGLIB代理，这部分后续会再细讲。</li><li>第三句，<code>作为系统组件</code>，把Creator这个Bean，放到Spring容器中。让Spring实例化，启动这个Creator。</li></ul><p>总结：</p><ul><li>Spring加载自动代理器<code>AnnotationAwareAspectJAutoProxyCreator</code>，当作一个系统组件。</li><li>当一个bean加载到Spring中时，会<code>触发自动代理器中的bean后置处理</code>，然后会先扫描bean中所有的Advisor</li><li>然后<code>用这些Adviosr和其他参数构建ProxyFactory</code></li><li>ProxyFactory会根据配置和目标对象的类型寻找代理的方式（JDK动态代理或CGLIG代理）</li><li>然后<code>代理出来的对象放回context中</code>，完成Spring AOP代理</li></ul><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>SpringBoot是整合Spring技术栈的一站式框架</p><p>SpringBoot是简化Spring技术栈的快速开发脚手架</p><p><a href="https://www.yuque.com/atguigu/springboot/na3pfd">01、Spring与SpringBoot (yuque.com)</a></p><h3 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h3><p>apache下的一个项目管理软件，可以实现编译、打包等功能，也可以管理项目与项目之间的关系（依赖、继承、聚合）。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>1.（POM）项目对象模型：maven工程的基本工作单元，是一个XML文件，包含了项目的基本信息，通过一段描述信息来进行管理构建。</p><p>2.坐标：maven寻找构件的依据，每个存在于maven中的依赖都具有唯一的坐标。通过<code>groupId</code>、<code>artifactId</code>、<code>version</code>、<code>packaging</code>、<code>classifier</code>几个标签来进行定义。</p><ul><li><p>groupId：往往定义项目的名称，通常格式为：org.组织名称.项目名称；</p></li><li><p>artifactId：项目模块名称，即我们通常说的project工程名称，是具体的应用名称；</p></li><li><p>version:当前项目所处的版本；</p></li><li><p>packaging: 项目的打包方式;非必填，默认为jar方式；</p></li><li><p>classifier：定义附属构建；项目除了可以生成主构件XXX.jar外，还可以通过一些插件生成XXX-sources.jar,XXX-doc.jar等附属构件，分别以源码的形式打包和文档的形式打包来做项目呈现；</p></li></ul><p>3.仓库</p><p>本地仓库</p><p>远程仓库：中央仓库、局域网私服仓库</p><p>4.父子工程和聚合工程</p><p>一个父模块下面多个子模块，<code>子模块与父模块</code>为继承关系，众多<code>子模块互相之间</code>为聚合关系。</p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><h5 id="1-依赖的传递性："><a href="#1-依赖的传递性：" class="headerlink" title="1.依赖的传递性："></a>1.依赖的传递性：</h5><p>简易描述：项目一依赖了某个jar包；项目二依赖了项目一，那么项目二也自动依赖项目一的jar包。</p><h5 id="2-解决依赖冲突的两个默认原则"><a href="#2-解决依赖冲突的两个默认原则" class="headerlink" title="2.解决依赖冲突的两个默认原则"></a>2.解决依赖冲突的两个默认原则</h5><p>依赖冲突：项目中有存在多处对同一依赖的不同版本的引用，即坐标相同，版本号不同；</p><p>两个原则：</p><p>1.最短路径原则</p><p>比如A–B–C–D(2.0)和A–E–D(1.0),那么会使用1.0的D，因为路径更短。</p><p>2.最先声明原则</p><p>在pom中依赖声明的<code>顺序靠前</code>的依赖将被使用；</p><p>​    当<code>第一原则不适用</code>（冲突依赖的最短路径一致）的情况下，适用第二原则。第二原则是maven2.0.9定义的，目的是为了尽可能的避免构建的不确定性，在此版本之前第一原则不适用的场景下的依赖是不确定的。</p><h5 id="3-依赖的有效范围"><a href="#3-依赖的有效范围" class="headerlink" title="3.依赖的有效范围"></a>3.依赖的有效范围</h5><ul><li><p>compile（默认使用该依赖范围）：对于<code>编译 测试 运行</code>三种的classpath都有效</p></li><li><p>provided：于<code>编译和测试</code>classpath有效，但在<code>运行时无效</code>。典型的例子是servlet-api，<code>编译和测试项目的时候需要该依赖</code>，但在运行的时候，由于容器已经提供，就不需要maven重复地引入一遍。打包的时候可以不用包进去，别的设施会提供。</p></li><li><p>runtime：<code>运行时依赖范围</code>。使用此依赖范围的maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是<code>JDBC驱动</code>实现，项目主代码的<code>编译只需要</code>jdk提供的<code>jdbc的接口</code>，只有在执行测试或者运行测试的时候才需要<code>实现上述接口的jdbc的驱动</code>。</p></li></ul><p>  System：</p><ul><li><p>test：只对于测试的classpath有效；</p></li><li><p>import:导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。只有在dependencyManagement下才有效果。父子工程中，<code>父工程专门用作版本管理时，如果指定了scope=import,则子工程不可以再自行定义依赖的版本</code>，必须使用父工程指定的版本号；<code>dependencyManagement标签表示只是声明依赖，并不实际引入</code>，需要子项目显式的声明依赖。</p></li></ul><h4 id="项目打包类型"><a href="#项目打包类型" class="headerlink" title="项目打包类型"></a>项目打包类型</h4><p>如：<packaging>jar&lt;&#x2F; packaging&gt;</p><p>pom ———&gt; 父类型都为pom类型</p><p>jar ———&gt; 内部调用或者是作服务使用(默认为jar)</p><p>war ———&gt; 需要部署的项目(网络服务)</p><h4 id="MAVEN命令"><a href="#MAVEN命令" class="headerlink" title="MAVEN命令"></a>MAVEN命令</h4><p>clean:清除编译文件和打包文件</p><p>compile：生成编译文件，相当于javac命令</p><p>package：生成编译文件并生成打包文件，相当于java命令</p><p>install：生成编译文件和打包文件，相当于java命令；</p><p>deploy:如果想把打包文件放到私服仓库，需要执行deploy命令，用到的不多；</p><p>install和package的区别就是install会把打好的包部署到本地maven仓库。</p><h3 id="Spring生命周期监听"><a href="#Spring生命周期监听" class="headerlink" title="Spring生命周期监听"></a>Spring生命周期监听</h3><p>SpringApplicationRunListener:感知全阶段的生命周期（扩展了ApplicationListener接口）</p><p>1.引导：</p><p>​利用BootstrapContext引导整个项目启动</p><p>​starting：应用开始，SpringApplication的run方法一调用，只要有BootstrapContext就执行</p><p>​environmentPrepared：环境准备好（吧启动参数等绑定倒环境变量中），但是ioc还没有创建。（调一次）</p><p>2.启动</p><p>​contextPrepared：ioc容器创建并准备好，但是sources（主配置类）没加载，并关闭引导上下文；组件都没创建（调一次）</p><p>​contextLoaded：ioc容器加载，主配置类加载好了，但是ioc容器还没有刷新（bean没创建）</p><p>​&#x3D;&#x3D;截止之前，ioc容器还没产出bean&#x3D;&#x3D;</p><p>​started：ioc容器刷新了（所有bean造好了），但是runner没调用</p><p>​ready：ioc容器刷新了，所有runner调完了</p><p>3.运行</p><p>​之前步骤都正确执行，代表容器running</p><p>在starting之后的步骤中，只要出现错误，就会调用监听器的failed启动失败方法。</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230531151125184.png" alt="image-20230531151125184"></p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>如果项目启动前做事：BootstrapRegistyrInitializer和ApplicationContextInitializer</p><p>如果想要在项目启动完成后做事：ApplicatinoRunner和 CommandLineRunner</p><p>如果要干涉生命周期做事：SpringApplicationRunListener</p><p>如果要用事件机制：ApplicationListener</p><p><img src="C:\Users\15958\AppData\Roaming\Typora\typora-user-images\image-20230531155445969.png" alt="image-20230531155445969"></p><h3 id="Spring处理请求时发生了什么"><a href="#Spring处理请求时发生了什么" class="headerlink" title="Spring处理请求时发生了什么"></a>Spring处理请求时发生了什么</h3><p>在Spring Web应用程序中，当接收到一个HTTP请求时，通常会经过以下处理步骤：</p><ol><li>Web服务器接收到HTTP请求，并将请求转发给Spring的<code>DispatcherServlet</code>。</li><li>DispatcherServlet作为前端控制器，接收到请求后会进行初步的处理和解析，包括解析请求URL、请求参数、请求头等信息。</li><li>DispatcherServlet根据请求的URL路径找到对应的处理器（<code>Handler</code>），即Controller类或方法。</li><li>执行Controller中对应的方法，处理请求，并返回一个包含模型数据的<code>ModelAndView</code>对象（或其他类型的返回值）。</li><li>如果Controller方法需要进行数据绑定、校验等操作，会在此阶段进行。</li><li>根据返回的ModelAndView对象（或其他类型的返回值），DispatcherServlet选择合适的视图（View）进行<code>渲染</code>，通常是根据视图解析器（ViewResolver）来决定使用哪个视图。</li><li>视图进行渲染(<code>Thymeleaf</code>模板引擎)，并将渲染结果返回给DispatcherServlet。</li><li>DispatcherServlet将视图结果返回给Web服务器，Web服务器将其作为HTTP响应发送回客户端。</li></ol><p>在这个处理过程中，还可能涉及到拦截器（Interceptor）的调用、异常处理器（Exception Handler）的触发等其他处理环节，以提供更丰富的功能和灵活性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2023/05/06/JVM/"/>
      <url>/2023/05/06/JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="类文件"><a href="#类文件" class="headerlink" title="类文件"></a>类文件</h2><p>JVM可以理解的代码叫做<code>字节码</code>（扩展名为.class），不面向任何特定的处理器，只面向虚拟机。（跨平台的实现原理，不同的操作系统）。</p><p>结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志确定这个文件是否为一个能被虚拟机接收的 Class 文件</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号javap -v可以查看类文件的版号信息 ，向上兼容</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池主要存放两大常量：字面量和符号引用</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###静态常量池</p><ul><li>字面量</li><li>符号引用<ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li>好处：常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了<code>对象的共享</code>。</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>当<code>Class文件被加载</code>完成后，java虚拟机会将静态常量池里的内容<code>转移</code>到运行时常量池里，在静态常量池的符号引用有一部分是会被转变为<code>直接引用</code>的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法<code>不能被重写</code>其他版本，所以能在加载的时候就可以<code>将符号引用转变为直接引用</code>，而其他的一些方法是在这个方法被<code>第一次调用</code>的时候才会将符号引用转变为直接引用的。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>字符串常量池的存在使JVM提高了性能和减少了内存开销。</p><ul><li>每当我们使用<code>字面量</code>（String s&#x3D;“1”;）创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就将<code>此字符串对象的地址赋值给引用s</code>（引用s在Java栈。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，并将此<code>字符串对象的地址赋值</code>给引用s（引用s在Java栈中）。</li><li>每当我们使用关键字new（String s&#x3D;new String(”1”);）创建字符串常量时，JVM会首先检查字符串常量池，<code>如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，而直接堆中创建该对象的副本</code>，然后将堆中对象的地址赋值给引用s，如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后在堆中创建该对象的副本，然后将<code>堆中对象的地址赋值</code>给引用s。</li><li>如果需要将<code>new</code>创建的字符串对象放入字符串常量池中，可以使用<code>intern()</code>方法，它会检查字符串在常量池中是否存在，如果存在则返回常量池中的引用，如果不存在则将字符串添加到常量池中并返回引用。</li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="https://img-blog.csdnimg.cn/24506a0020724d209362cde9feea9103.png" alt="在这里插入图片描述"></p><p><strong>加载-验证-准备-解析-初始化</strong></p><p>jre是java运行环境，Java Runtime Environment</p><p>###加载</p><p>类加载过程的第一步，主要完成下面3件事情：</p><ul><li>通过<strong>全类名</strong>获取定义此类的<strong>二进制字节流</strong></li><li>将字节流所代表的<code>静态存储结构</code>转换为<code>方法区</code>的<code>运行时数据结构</code></li><li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li></ul><p>####方法区、堆、栈</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a1938e1761cfb2a65e508eea54d9f487.png" alt="image-20200708094747667"></p><ol><li>Person.class 通过类加载子系统加载到JVM中</li><li>Person的类信息保存在方法区中</li><li>new Person() 实际的<code>对象数据保存在堆</code>中</li><li>Person p &#x3D; new Person(); p变量保存在java虚拟栈中占一个slot 指向了堆空间中实际的实例数据</li><li>堆空间中的实例数据中也保存了方法区中对象类型信息</li></ol><p>JDK8之后，方法区独立使用物理内存。</p><p>也就是说，方法区主要存放class，堆中主要存放实例化后的对象。</p><ul><li><p>方法区Method Area 和Heap一样,属于<code>多个线程共享的内存区域</code></p></li><li><p>方法区在<code>JVM启动的时候被创建</code>,物理内存空间也可以是不连续的,逻辑上连续</p></li><li><p>方法区的大小跟堆一样可以固定大小也可以动态扩展</p></li><li><p>方法区的大小决定系统了可以保存了多少类,如果<code>定义了太多类,会导致方法区溢出</code>,JVM也会报出OOM异常java.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace</p></li><li><p>出现OOM 方法区溢出主要以下几种情况</p><ul><li><p>加载了大量第三方jar包</p></li><li><p>Tomcat部署过多工程 30-50(Tomcat是一个免费的web服务器)</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d68612e080556634a602b192dc81c6dd.png" alt="img"></p></li><li><p>大量动态生成的反射类（反射就是加载类，解剖出类的各个组成部分）</p></li></ul></li><li><p>关闭JVM就会释放方法区的内存.方法区的生命周期与JVM相同</p></li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul><li>文件格式验证：主要验证Class文件<strong>是否规范</strong>等。</li><li>元数据验证：对字节码描述的信息<strong>语义分析</strong>等。</li><li>字节码验证：确保语义是ok的。</li><li>符号引用验证：确保解析动作能执行。</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ul><li>这时候进行内存分配的仅包括<strong>类变量</strong>（static），而不包括实例变量，<code>实例变量会在对象实例化时随着对象一块分配</code>在 Java 堆中,目前只是类加载的过程。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的<strong>零值</strong>（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在<code>准备阶段的初始值就是0</code> 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 <strong>fianl 关键字</strong><code>public static final int value=111</code> ，那么准备阶段 value 的值就被复制为 111。</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的<code>符号引用替换为直接引用</code>的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><p>符号引用就只是名字，但是能够根据这个字符串定位到指定的数据，比如java&#x2F;lang&#x2F;StringBuilder，直接引用是一个内存指针。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载的最后一步，也是真正执行类中定义的 <strong>Java 程序代码</strong>(字节码)，初始化阶段是执行<strong>类构造器</strong> <code>&lt;clinit&gt; ()</code>方法的过程。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>默认提供三种类加载器,负责不同目录下的.class文件：</p><ul><li>BootstrapClassLoader(<code>启动类</code>加载器)：最顶层的加载类，由<code>C++</code>实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li>ExtensionClassLoader(<code>扩展类</code>加载器)：父加载器是<code>Bootstrap启动类加载器</code>(不是继承),主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li><li>AppClassLoader(<code>应用程序类</code>加载器)：父加载器是<code>ExtClassLoader扩展类加载器</code>（注: 不是继承关系），对应加载的应用程序<code>classpath</code>目录下的所有jar和class等</li></ul><p>AppClassLoader和ExtClassLoader都实现了抽象类ClassLoader。 抽象类ClassLoader有一个<code>字段parent</code>, AppClassLoader和ExtClassLoader通过设置该字段引用,指定父加载器。（是组合关系）</p><p>AppClassLoader 的parent指向 ExtClassLoader,ExtClassLoader 的parent指向 null,(null的原因是因为Bootstrap是C++实现的,通过代码中<code>逻辑判断</code>来转向Bootstrap)</p><p>自定义类加载器是为了加载在jvm三个加载器负责的目录范围之外的类</p><p>AppClassLoader和ExtClassLoader是Launcher的静态内部类，在程序启动时JVM会创建Launcher对象，Launcher构造器会同时会创建扩展类加载器和应用类加载器。</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用双亲委派模型。即在类加载的时候，系统会<code>首先判断当前类是否被加载过</code>。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给<code>父类加载器</code>的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器BootstrapClassLoader中。<code>当父类加载器无法处理时，才由自己来处理</code>。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader作为父类加载器。如果当前类加载器和所有父类加载器都无法加载该类时，则会抛出ClassNotFoundException异常。</p><p><img src="https://camo.githubusercontent.com/e1bcf49e6a732e8f66e1cce576661402f213b8f94471bba6ce41b34d24569964/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545372542312542422545352538412541302545382542442542442545352539392541382d5a31576446742e706e67" alt="类加载器"></p><p>双亲委派模型保证了Java程序的稳定运行，可以<code>避免类的重复加载</code>，也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p><h3 id="什么时候需要类加载步骤中的加载"><a href="#什么时候需要类加载步骤中的加载" class="headerlink" title="什么时候需要类加载步骤中的加载"></a>什么时候需要类加载步骤中的加载</h3><p>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：</p><ol><li>使用new关键字<code>实例化</code>对象的时候、读取或设置一个类的<code>静态字段</code>（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的<code>静态方法</code>的时候。</li><li>使用java.lang.reflect包的方法对类进行<code>反射调用</code>的时候，如果<code>类没有进行过初始化</code>，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其<code>父类还没有进行过初始化</code>，则需要先触发其父类的初始化。</li><li>当<code>虚拟机启动</code>时，用户需要指定一个要<code>执行的主类</code>（包含main（）方法的那个类），虚拟机会先初始化这个主类。</li></ol><p>###打破双亲委派模型</p><p>重写ClassLoader类的loadClass()方法</p><p>##JVM内存区域</p><center class="half">    <img src="https://camo.githubusercontent.com/153b69e2d97ae1082e80014c90b907c6d7fbdda99a888c6e1cb0a56d55ee4f87/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f4a564d2545352538362538352545352541442539382545362541382541312545352539452538422d312e382545342542392538422545352538392538442d454b766847422e706e67" alt="JVM内存模型-1.8之前" style="zoom:50%;" width=1100 />    <img src="https://camo.githubusercontent.com/916309426f20ab1c0ed42dd6f345ac99b4b5f64f70a98b9e4665394e35cb57b3/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f4a564d2545352538362538352545352541442539382545362541382541312545352539452538422d312e382d7939584e6c542e706e67" alt="JVM内存模型-1.8" style="zoom:50%;" width=1100 /></center><p>总体来说，粗略的分为<strong>堆和栈</strong>，那么<code>栈是线程私有的</code>，而<code>堆是线程共享的</code>。那么<strong>栈</strong>又分为<code>程序计数器</code>，<code>虚拟机栈</code>，<code>本地方法栈</code>。</p><p>堆稍后再说，当然还有<strong>方法区</strong>，稍后单独说.</p><p>###程序计数器</p><ul><li>字节码解释器通过改变程序计数器来<code>依次读取指令</code>，从而实现代码的<code>流程控制</code>，如：顺序执行、选择、循环、异常处理。</li><li>在<code>多线程</code>的情况下，程序计数器用于<code>记录当前线程执行的位置</code>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li><li><strong>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域</strong>，它的<code>生命周期随着线程</code>的创建而创建，随着线程的结束而死亡</li></ul><p>###虚拟机栈</p><p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。</p><p>每个方法执行，伴随着进栈;方法执行结束后，伴随着出栈。</p><p>可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><ul><li>说白了，通俗的讲，主要是对象中的方法产生的各种”材料”。</li><li>因此，虚拟机栈存放的是<code>局部变量表、操作数栈、动态链接、方法出口</code>。</li><li>局部变量表存8大基本数据类型以及引用类型。</li><li>当然，栈也会非常error：<ul><li><strong>StackOverFlowError</strong>： 若 J<strong>ava 虚拟机栈的内存大小不允许动态扩展</strong>，<strong>那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候</strong>，就抛出 StackOverFlowError 异常。</li><li><strong>OutOfMemoryError</strong>：若 <strong>Java 虚拟机栈的内存大小允许动态扩展</strong>，<strong>且当线程请求栈时内存用完了</strong>，<strong>无法再动态扩展了</strong>，此时抛出 OutOfMemoryError 异常。</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/20210810103055167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0MDA1,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" /><p>###本地方法栈</p><p>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <code>Native</code> 方法服务。</p><p>###方法区</p><p><strong>方法区与 Java 堆一样，是各个线程<code>共享</code>的内存区域</strong>，它用于存储已被虚拟机加载的<code>类信息</code>、<code>常量</code>、<code>静态变量</code>、即时编译器编译后的代码等数据。不过随着版本的变化，会发生变化。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存</strong>并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现（如<strong>DirectByteBuffer</strong>）。本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到<code>本机总内存大小以及处理器寻址空间</code>的限制。</p><p>###堆</p><p>此内存区域的唯一目的就是<code>存放对象实例</code>，几乎所有的对象实例以及数组都在这里分配内存。</p><ul><li>分为四区，分别为<code>eden区、s0(&quot;From)区、s1(&quot;To&quot;)和tentired</code></li><li>在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。</li><li>当<code>Eden区满</code>了的时候，<code>minor GC</code>触发</li><li>经过扫描与标记，存活的对象被复制到<code>S0</code>，不存活的对象被回收</li><li>在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到survivor区。然而在survivor区，<code>S0的所有的数据都被复制到S1</code>，需要注意的是，在上次minor GC过程中移动到S0中的相同存活的对象在复制到S1后其<code>年龄要加1</code>。此时Eden区S0区被清空，所有存活的数据都复制到了S1区，并且<code>S1区存在着年龄不一样的对象</code>（重点）</li><li>再下一次MinorGC则重复这个过程，这一次survivor的<code>两个区对换</code>，存活的对象被复制到S0，<code>存活的对象年龄加1</code>，Eden区和另一个survivor区被清空。</li></ul><p>##GC-JAVA垃圾回收机制</p><p>###1.GC是什么</p><p>JVM垃圾收集(Java Garbage Collection )，程序运行时，内存空间是有限的，那么如何及时的把不再使用的对象清除将内存释放出来，这就是GC要做的事。</p><p>GC采用分代收集算法：</p><ul><li><p>次数上频繁收集Young区（新生代：Eden、From、To）</p></li><li><p>次数上较少收集Old区（老年代）</p></li><li><p>基本不动Perm区</p></li></ul><p>####1.GC的区域</p><p>jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭（线程私有区），栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java <strong>堆</strong>和<strong>方法区</strong>中（线程共享区），在程序运行期间，这部分内存的分配和使用都是动态的。</p><h4 id="2-GC的对象"><a href="#2-GC的对象" class="headerlink" title="2.GC的对象"></a>2.GC的对象</h4><p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。</p><p>1）、<code>引用计数</code>：每个对象有一个<code>引用计数属性</code>，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，<code>无法解决</code>对象<code>相互循环引用</code>的问题。</p><p>2）、<code>可达性分析</code>（Reachability Analysis）：从<code>GC Roots</code>开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots<code>没有任何引用链相连</code>时，则证明此对象是<code>不可用</code>的。不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程 ，两次标记后仍然是可回收对象，则将面临回收。</p><p>在Java语言中，GC Roots包括：</p><p><code>虚拟机栈中引用的对象</code>；方法区中<code>类静态属性实体引用的对象</code>；方法区中<code>常量引用的对象</code>；本地方法栈中<code>JNI（JAVA本地接口）引用的对象</code>。</p><h5 id="如何枚举根节点"><a href="#如何枚举根节点" class="headerlink" title="如何枚举根节点"></a>如何枚举根节点</h5><p>在HotSpot的实现中，是使用一组称为<code>OopMap</code>的数据结构来达到这个目的的，在<code>类加载完成的时候</code>，HotSpot就把对象内什么偏移量是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得到信息了。<code>但是</code>，可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那么会需要大量的额外空间，这样GC<code>成本很高</code>，<code>安全点</code>由此而来。</p><p>在JIT<code>编译</code>过程中，在<code>特定的位置</code>记录下栈和寄存器<code>哪些位置是引用</code>，实际上这些位置就是安全点，意思就是说，程序执行时并非在所有地方都能停顿下来开始GC，<code>只有在达到安全点时才能暂停</code>。</p><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint，但如果线程处于<code>Sleep或者Blocked</code>状态，这时候<code>线程无法响应</code>JVM的中断请求，JVM也显然不太可能等待线程重新被分配CPU时间，这种情况就需要<code>安全域</code>来解决。安全域是指在<code>一段代码片段中，引用关系不会发生变化</code>。在这个区域中的<code>任意地方开始GC都是安全的</code>。这时候安全点就被扩展到了Safe Region。</p><p>####3.什么时候GC</p><p>1）、程序调用System.gc时可以触发</p><p>2）、系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）</p><p>GC又分为 minor GC 和 Full GC (也称为 Major GC )：</p><p><strong>Minor GC触发条件：</strong>当Eden区满时，触发Minor GC。</p><p><strong>Full GC触发条件：</strong></p><p> a.调用System.gc时，系统建议执行Full GC，但是不必然执行</p><p> b.老年代空间不足</p><p> c.方法区空间不足</p><p> d.通过Minor GC后进入老年代的平均大小大于老年代的可用内存（老年代满了）</p><p> e.由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p><h4 id="4-GC做了什么、垃圾收集器"><a href="#4-GC做了什么、垃圾收集器" class="headerlink" title="4.GC做了什么、垃圾收集器"></a>4.GC做了什么、垃圾收集器</h4><p> 主要做了清理对象，整理内存的工作。Java堆分为新生代和老年代，采用了不同的回收方式。</p><img src="https://camo.githubusercontent.com/761860e520e603bad124ae1473bae185b1615a5c7c1d40d7178b83c63003675a/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545352539452538332545352539432542452545352539422539452545362539342542362545352539392541382d44535652414f2e706e67" alt="垃圾回收器-DSVRAO" style="zoom:50%;" /><h5 id="串行垃圾收集器："><a href="#串行垃圾收集器：" class="headerlink" title="串行垃圾收集器："></a>串行垃圾收集器：</h5><p>使用单线程进行垃圾回收，垃圾回收时，只有一个线程在工作，并且java应用中的<code>所有线程都要暂停</code>，等待垃圾回收的完成。这种现象称之为<code>STW（Stop-The-World）</code>。</p><h5 id="并行垃圾收集器："><a href="#并行垃圾收集器：" class="headerlink" title="并行垃圾收集器："></a>并行垃圾收集器：</h5><p>将单线程改为了多线程进行垃圾回收，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是一样的，只是并行执行，<code>速度更快些</code>，<code>暂停的时间更短一些</code>。</p><h5 id="CMS-Concurrent-Mark-Sweep-垃圾收集器："><a href="#CMS-Concurrent-Mark-Sweep-垃圾收集器：" class="headerlink" title="CMS(Concurrent Mark Sweep)垃圾收集器："></a>CMS(Concurrent Mark Sweep)垃圾收集器：</h5><p>一种以获取<code>最短回收停顿时间</code>为目标的收集器。它非常符合在注重用户体验的应用上使用。是 HotSpot 虚拟机(一款JAVA虚拟机)第一款真正意义上的<code>并发收集器</code>，它第一次实现了让<code>垃圾收集线程与用户线程（基本上）同时工作</code>。</p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 “<code>标记-清除</code>”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li>初始标记：<code>暂停所有的其他线程</code>，并<code>记录</code>下直接与 root 相连的对象，速度很快 ；</li><li>并发标记：<code>同时开启 GC 和用户线程</code>，用一个闭包结构去<code>记录可达对象</code>。但在这个阶段结束，这个闭包结构并<code>不能保证包含当前所有</code>的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程<code>无法保证可达性分析的实时性</code>。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记：重新标记阶段就是为了<code>修正</code>并发标记期间因为<code>用户程序继续运行</code>而<code>导致标记产生变动</code>的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li>并发清除：<code>开启用户</code>线程，同时 GC 线程开始对为<code>标记的区域做清扫</code>。</li></ul><p>优点：<code>并发收集、低停顿</code></p><p>缺点：</p><ul><li>对 CPU 资源敏感；</li><li>无法处理浮动垃圾；</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量<code>空间碎片</code>产生。</li></ul><h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><p>争对CMS缺点提出</p><ul><li>将整个Java堆划分为多个<code>大小相等</code>的独立区域（Region），虽然还保留新生代和老年代的概念，但<code>新生代和老年代不再是物理隔离</code>的了，而都是一部分Region（不需要连续）的<code>集合</code></li><li>并行与并发： G1 能充分利用 CPU、多核环境下的硬件优势，使用<code>多个 CPU</code>来<code>缩短 Stop-The-World 停顿时间</code>。</li><li><code>分代</code>收集：虽然 G1 可以不需要其他收集器配合就能<code>独立管理</code>整个 GC 堆，但是还是保留了分代的概念。</li><li>空间整合：G1 从<code>整体</code>来看是基于“<code>标记整理</code>”算法实现的收集器；从<code>局部</code>上来看是基于“<code>复制</code>”算法实现的。</li><li><code>可预测停顿</code>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型。G1跟踪各个Region里面的<code>垃圾堆积的价值大小</code>（回收所获得的空间大小以及回收所需要时间的经验值），在后台<code>维护一个优先列表</code>，每次根据允许的收集时间，<code>优先回收价值最大的Region</code>。</li></ul><h6 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h6><p>在G1收集器中，Region之间的<code>对象引用</code>以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用<code>Remembered Set</code>（RS）来<code>避免全堆扫描</code>的。G1中<code>每个Region都有一个与之对应的RS</code>，虚拟机发现程序对<code>Reference</code>类型的数据进行<code>写操作</code>时，会产生一个<code>Write Barrier</code>暂时中断操作，<code>检查</code>Reference<code>引用的对象</code>是否处于<code>不同的Region之间</code>（在分代的例子中就是检查是否老年代中的对象引用了新生代中方的对象）如果是，便通过<code>CardTable</code>（每个Region块又细分了2000多个卡表，记录一波我引用了哪个对象）把<code>相关引用信息记录</code>到<code>被引用对象</code>所属的Region的RS之中。当进行内存回收时，在GC根节点的枚举范围中加入RS即可保证不对全堆扫描，也不会又遗漏。</p><h6 id="四个过程"><a href="#四个过程" class="headerlink" title="四个过程"></a>四个过程</h6><ul><li>初始标记：仅仅只是<code>标记</code>一下GC Roots 能<code>直接关联</code>到的对象，并且修改<code>TAMS（Nest Top Mark Start）</code>的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。</li><li>并发标记：从GC Root 开始对堆中对象进行<code>可达性分析</code>，找到存活对象，此阶段耗时较长，但<code>可与用户程序并发执行</code>。</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在<code>线程</code>的<code>Remembered Set Logs</code>里面，最终标记阶段需要把Remembered Set Logs的<code>数据合并</code>到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个Region中的<code>回收价值和成本进行排序</code>，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且<code>停顿</code>用户线程将<code>大幅度提高收集效率</code>。</li></ul><h5 id="G1与CMS的比较"><a href="#G1与CMS的比较" class="headerlink" title="G1与CMS的比较"></a>G1与CMS的比较</h5><ol><li>CMS收集器是获取最短回收停顿时间为目标的收集器，因为CMS工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的（只有初始标记和重新标记会STW）。但是<code>CMS</code>收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会<code>占用CPU资源而导致引用程序变慢</code>，总吞吐量下降。</li><li><code>CMS仅作用于老年代</code>，是基于标记清除算法，所以清理的过程中会有大量的<code>空间碎片</code>。</li><li>CMS收集器无法处理<code>浮动垃圾</code>，由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自然会有<code>新的垃圾不断产生</code>，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好<code>留在下一次GC</code>时将其清理掉。</li><li><code>G1</code>是一款<code>面向服务端</code>应用的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。G1能充分利用CPU、<code>多核</code>环境下的硬件优势，使用多个CPU或核心来缩短STW的停顿时间，它满足短时间停顿的同时达到一个高的吞吐量。</li><li>从<code>JDK 9</code>开始，<code>G1成为默认的垃圾回收器</code>。当应用有以下任何一种特性时非常适合用G1：<code>Full GC持续时间太长或者太频繁</code>；<code>对象的创建速率和存活率变动很大</code>；<code>应用不希望停顿时间长(长于0.5s甚至1s)</code>。</li><li>G1将空间划分成很多块（Region），然后他们各自进行回收。堆比较大的时候可以采用，采用复制算法，碎片化问题不严重。<code>整体上看属于标记整理算法,局部(region之间)属于复制算法</code>。</li><li>G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要<code>占用大量的内存</code>，可能达到整个堆内存容量的 20% 甚至更多。而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。所以 <code>CMS 在小内存应用上的表现要优于 G1</code>，而<code>大内存应用上 G1 更有优势，大小内存的界限是6GB到8GB</code></li></ol><p>###2.GC算法</p><p><code>标记-清除算法</code>：</p><p>为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。</p><p>优缺点：只需要找到一个引用即可，缺点是<code>效率比较低</code>，每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍。可能出现很多<code>碎片空间</code>无法利用的情况。</p><p><code>标记-压缩算法</code>（标记-整理）：</p><p>是标记-清除法的一个改进版。在第二个阶段，该算法并<code>没有直接</code>对死亡的对象进行<code>清理</code>，而是将所有<code>存活的对象整理</code>一下，放到另一处空间，然后把剩下的所有对象全部清除。</p><p>优缺点：不会产生大量的碎片空间。效率较低。</p><p><code>复制算法</code>：</p><p>将内存平均分成两部分，然后每次只使用其中的一部分，当这部分<code>内存满的时候</code>，将内存中所有<code>存活的对象</code>复制到<code>另一个内存</code>中，然后将<code>之前的内存清空</code>，只使用这部分内存，循环下去。</p><p>优缺点：没有内存碎片；可用内存空间只有一半。适用于对象死亡快的场景。</p><p>目前主流的是<code>分代收集算法</code>：</p><p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p><p>当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。 这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区。再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。 老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（<em>Full GC</em>），也就是全量回收。如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作。</p><h3 id="3-Minor-GC和Full-GC"><a href="#3-Minor-GC和Full-GC" class="headerlink" title="3.Minor GC和Full GC"></a>3.Minor GC和Full GC</h3><ul><li>Minor GC触发条件：当<code>Eden区满</code>时，触发Minor GC。</li><li>Full GC触发条件：<ol><li>调用<code>System.gc</code>时，系统建议执行Full GC，但是<code>不必然执行</code></li><li><code>老年代</code>空间不足</li><li><code>方法区</code>空间不足</li><li>通过<code>Minor GC后</code>进入<code>老年代的平均大小</code>大于老年代的可用内存</li><li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该<code>对象转存到老年代</code>，且老年代的<code>可用内存小</code>于该对象大小</li></ol></li></ul><h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p><img src="https://camo.githubusercontent.com/a905ad4498d3d0837e9dcc1c23341d8137d77336dc2bf2b32abd69a70a14f49b/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f4a6176612545352538382539422545352542422542412545352541462542392545382542312541312545372539412538342545382542462538372545372541382538422d6643307752622e706e67" alt="img"></p><p>类加载–分配内存–初始化零值–设置对象头–执行init方法</p><p>###创建</p><p>####类加载检查</p><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的<code>符号引用</code>，并且检查这个符号引用代表的类是否已被<code>加载过、解析和初始化过</code>。如果没有，那必须先执行相应的类加载过程。</p><p>####分配内存</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于<code>把一块确定大小的内存从 Java 堆中划分出来</code>。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否<code>规整</code>决定，而 Java 堆是否规整又由所采用的<code>垃圾收集器</code>是否带有<code>压缩整理功能</code>决定。</p><ul><li><p>指针碰撞</p><p>如果Java堆中内存是<code>绝对规整</code>的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个<code>指针</code>作为<code>分界点的指示器</code>，所分配内存仅仅是把那个<code>指针</code>向空闲空间方向<code>挪动一段与对象大小相等的实例</code>，这种分配方式就是指针碰撞</p><ul><li>堆规整（没有内存碎片）</li><li>复制算法</li><li>GC：Serial、ParNew</li></ul></li><li><p>空闲列表</p><p>如果Java堆内存中的内存并不是规整的，已被使用的内存和空闲的内存<code>相互交错</code>在一起，不可以进行指针碰撞啦，虚拟机必须<code>维护一个列表</code>，记录哪些内存是可用的，在分配的时候从列表<code>找到一块大的空间</code>分配给对象实例，并<code>更新列表</code>上的记录，这种分配方式就是空闲列表</p><p>可能存在<code>线性安全</code>问题。如果一个线程正在给A对象分配内存，指针还没有来的及修改，同时另一个为B对象分配内存的线程，仍引用这之前的指针指向，这就出问题了。</p><ul><li>堆内存不规整的情况下</li><li>虚拟机会维护一个列表，该列表会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块来划分给对象实例，最后更新列表记录</li><li>GC：CMS</li></ul></li><li><p>并发问题</p><ul><li>CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是<code>假设没有冲突</code>而去完成某项操作，如果因为冲突<code>失败就重试</code>，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证<code>更新操作的原子性</code>。</li><li>TLAB： 为每一个线程<code>预先</code>在 Eden 区<code>分配一块儿内存</code>，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的<code>内存已用尽</code>时，再采用上述的<code>CAS</code>进行内存分配</li></ul></li></ul><p>####初始化零值</p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以<code>不赋初始值就直接使用</code>，程序能访问到这些字段的数据类型所对应的零值。</p><p>####设置对象头</p><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p>####指向init方法</p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照<code>程序员</code>的意愿进行<code>初始化</code>，这样一个真正可用的对象才算完全产生出来。</p><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的稳定高效运行。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0PGgLpviaZ3JSMwUWoVZoYKBPy0wwA5HlI9q8UJoYBQf747KkKMtrIkZpeVlhfC6zYutBUUrJHQvrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>内存布局分别为对象头，实例数据，对其填充</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的自身<code>运行时数据</code>（哈希码、GC 分代年龄、锁状态标志等等），另一部分是<code>类型指针</code>，即对象指向它的类元数据的指针，虚拟机通过这个指针来<code>确定这个对象是哪个类的实例</code>。</p><p>####实例数据</p><p>实例数据部分是对象真正存储的<code>有效信息</code>，也是在程序中所定义的<code>各种类型的字段内容</code>。</p><p>####对其填充</p><p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起<code>占位作用</code>。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><p>####对象访问方式</p><p>#####1.句柄</p><p><img src="https://camo.githubusercontent.com/3501cb34812d6129ac468b95bf34579a76dcf5cb0fac5c22810bef4e96320c40/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545342542442542462545372539342541382545352538462541352545362539462538342d6634437739782e706e67" alt="使用句柄-f4Cw9x"></p><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为<code>句柄池</code>，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；也就是多了一步。</p><p>#####2.直接指针</p><p><img src="https://camo.githubusercontent.com/d584f6dda010a7bae95b34af5d39b00b4baf6b86dadfd21bc59cd80638f3263c/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545372539422542342545362538452541352545362538432538372545392539322538382d386d3348487a2e706e67" alt="直接指针-8m3HHz">如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是<code>对象的地址</code>。</p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是<code>稳定的句柄地址</code>，在对象被移动时只会改变<code>句柄中的实例数据指针</code>，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是<code>速度快</code>，它节省了一次指针定位的时间开销。</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析的基本行为就是<code>分析对象动态作用域</code>：当一个<code>对象</code>在方法中被定义后，它可能<code>被外部方法引用</code>，例如作为调用参数传递到其他方法中，称为<code>方法逃逸</code>。甚至还有可能被<code>外部线程访问</code>到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<code>线程逃逸</code>。如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化：</p><h3 id="1-栈上分配"><a href="#1-栈上分配" class="headerlink" title="1.栈上分配"></a>1.栈上分配</h3><p>Java虚拟机中，如果<code>确定</code>一个对象<code>不会逃逸出方法</code>之外，那让这个对象在<code>栈上分配内</code>存将会是一个很不错的主意，<code>对象所占用的内存空间就可以随栈帧出栈而销毁</code>。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，<code>垃圾收集系统的压力将会小很多</code>。</p><h3 id="2-同步消除"><a href="#2-同步消除" class="headerlink" title="2.同步消除"></a>2.同步消除</h3><p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个<code>变量不会逃逸出线程</code>，无法被其他线程访问，那这个变量的<code>读写肯定就不会有竞争</code>，对这个变量实施的<code>同步措施也就可以消除</code>。</p><h3 id="3-标量替换"><a href="#3-标量替换" class="headerlink" title="3.标量替换"></a>3.标量替换</h3><p>标量是指一个<code>数据已经无法再分解成更小的数据</code>来表示了，Java虚拟机的原始数据类型都不能再进一步分解，它们就可以称为标量。如果逃逸分析证明一个对象<code>不会被外部访问</code>，并且这个对象<code>可以被拆散</code>的话，那程序真正执行的时候将可能<code>不创建这个对象</code>，而改为<code>直接创建它的若干个被这个方法使用的成员变量</code>来代替。除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配到物理机器高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于引用</title>
      <link href="/2023/05/04/%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2023/05/04/%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>JAVA在1.2之后有着四种引用类型：<code>强引用</code>（Strong Reference）、<code>软引用</code>（Soft Reference）、<code>弱引用</code>（Weak Reference）、<code>虚引用</code>（Phantom Reference）, 4 种引用的强度依次减弱。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>Java中默认声明的就是强引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//只要obj还指向Object对象，Object对象就不会被回收</span></span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">//手动置null</span></span><br></pre></td></tr></table></figure><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>java.lang.ref.SoftReference</p><p>软引用是用来描述一些非必需但仍有用的对象。在<code>内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象</code>，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p><p>如果一个对象唯一剩下的引用是软引用，那么该对象是<code>软可及</code>的（softly reachable）。垃圾收集器并不像其收集弱可及的对象一样尽量地收集软可及的对象，相反，它只在真正 “需要” 内存时才收集软可及的对象。</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>java.lang.ref.WeakReference</p><p>弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM <code>开始进行垃圾回收，那些被弱引用关联的对象都会被回收</code>。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>PhantomReference</p><p>通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns this reference object&#x27;s referent.  Because the referent of a</span></span><br><span class="line"><span class="comment">     * phantom reference is always inaccessible, this method always returns</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h4><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之<code>关联的引用队列</code>中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p><p>ReferenceQueue是使用wati()和notifyAll()实现生产者和消费者模式的一个具体场景。</p><h3 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h3><p>引用实例的几个状态：</p><ul><li>Active：当处于Active状态，gc会特殊处理引用实例，一旦gc检测到其可达性发生变化，gc就会更改其状态。此时分两种情况，如果该引用实例创建时有注册引用队列，则会进入pending状态，否则会进入inactive状态。新创建的引用实例为Active。</li><li>Pending：当前为pending-Reference列表中的一个元素，等待被ReferenceHandler线程消费并加入其注册的引用队列。如果该引用实例未注册引用队列，则永远不会处理这个状态。</li><li>Enqueued：该引用实例创建时有注册引用队列并且当前处于入队列状态，属于该引用队列中的一个元素。当该引用实例从其注册引用队列中移除后其状态变为Inactive。如果该引用实例未注册引用队列，则永远不会处理这个状态。</li><li>Inactive：当处于Inactive状态，无需任何处理，一旦变成Inactive状态则其状态永远不会再发生改变。</li></ul><p><img src="https://img2020.cnblogs.com/blog/2443180/202108/2443180-20210815122647528-1748134729.png" alt="img"></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><p>对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。</p><p>所以内存泄漏需要满足两个点：</p><p>​对象可达，对象无用。(JAVA从语言上保证所有对象都是可达的，所有不可达对象都由GC管理)</p><p>​比如对于一个对象内的对象进行回收，对于整个对象不进行回收（置null），那么这个对象里面是空的，可是GC不会去回收这个对象。</p><p><img src="https://img-blog.csdnimg.cn/ac9c2b68edcd459783ad8f6c77a152a7.png" alt="内存泄漏存在的原因"></p><p>这里的有引用对象和无用对象的交集就是内存泄漏。</p><p>####JAVA中的内存泄漏</p><p>Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收。</p><p>在Java语言中，判断一个内存空间是否符合垃圾收集的标准有两个：一个是给对象赋予了空值null，并且以下再没有调用过；另一个是给对象赋予了新值，这样重新分配了内存空间。</p><p>Java内存泄漏的<code>根本原因</code>是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管<code>短生命周期对象已经不再需要</code>，但是因为<code>长生命周期持有它的引用</code>而导致不能被回收，这就是Java中内存泄漏的发生场景。严重时会报Out of memory。</p><p>检查内存泄露的工具： Optimizeit Profiler、JProbe Profiler、JinSight、Rational 公司的 Purify 等。</p><h3 id="JAVA内存分配"><a href="#JAVA内存分配" class="headerlink" title="JAVA内存分配"></a>JAVA内存分配</h3><p>Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。</p><p><code>静态存储区</code>（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</p><p><code>栈区</code> ：当方法被执行时，方法体内的<code>局部变量</code>（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，<code>效率很高</code>，但是分配的<code>内存容量有限</code>。</p><p><code>堆区</code> ：又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是<code>对象的实例</code>。这部分内存在不使用时将会由 Java <code>垃圾回收器来负责回收</code>。</p><h4 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h4><p>方法体内定义的（<strong>局部变量</strong>）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该<code>内存空间可以被重新使用</code>。</p><p>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。<code>在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量</code>。我们可以通过这个引用变量来访问堆中的对象或者数组。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>jvm中引用有好几种类型的实现，gc针对这几种不同类型的引用有着不同的<code>回收机制</code>，同时它们也有着各自的应用场景, 比如SoftReference可以用来做高速缓存, WeakReference也可以用来做一些普通缓存(WeakHashMap), 而PhantomReference则用在一些特殊场景，比如Cleaner就是一个很好的应用场景，它可以用来回收堆外内存。与此同时，SoftReference, WeakReference, PhantomReference这几种弱类型引用还可以与引用队列结合使用，使得可以在关联引用回收之后可以做一些额外处理，甚至于Finalizer(收尾机制)都可以在对象回收过程中改变对象的生命周期。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>同步的一些内容</title>
      <link href="/2023/05/04/%E5%90%8C%E6%AD%A5%E3%80%81%E9%94%81%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/05/04/%E5%90%8C%E6%AD%A5%E3%80%81%E9%94%81%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>###AbstractQueuedSynchronizer</p><p>AQS是一个基于先进先出等待队列来实现阻塞锁和相关同步器的框架。</p><p>AQS作为基础类，主要解决了在<u>锁不能获取的情况下的等待，以及锁释放后的唤起</u>。锁状态的定义，如何获取锁以及如何释放锁，都是需要相应的同步机制自己实现的。</p><p>什么情况下会用到：在日常的编程中我们经常会碰到并发的情况。有并发，就有资源共享；有资源共享就需要处理资源同步访问。处理同步的时候，就要处理<u><strong>竞争发生时候的等待问题</strong></u>以及<u><strong>竞争解除后的唤起的问题</strong></u>。AQS就是一个便于我们实现这种同步机制的框架。我们日常中使用到的ReentrantLock、ReentrantReadWriteLock以及ArrayBlockingQueue等都是基于AQS实现的。</p><p>主要实现方法：</p><ul><li>tryAcquire()，获取排他锁</li><li>tryRelease()，释放排他锁</li><li>tryAcquireShared()，获取共享锁</li><li>tryReleaseShared()，释放共享锁</li><li>isHeldExclusively()，是不是持有排他锁</li></ul><p>使用state来标识锁的状态，state &#x3D; 0表示锁没有被获取，当state &gt; 0表示锁已经被获取了。</p><p>AQS流程：<code>AQS</code>为加锁和解锁过程提供了统一的模板函数，加锁与解锁的模板流程是，获取锁失败的线程，会进入<code>CLH</code>队列阻塞，其他线程解锁会唤醒<code>CLH</code>队列线程，如下图所示（简化流程）</p><p><img src="https://pics7.baidu.com/feed/42a98226cffc1e17c1dd2eb13ee85d0b728de955.png@f_auto?token=119485b520bd32fb495070b2b10de00a" alt="img"></p><p>上图中，线程释放锁时，会唤醒<code>CLH</code>队列阻塞的线程，重新竞争锁，要注意，此时可能还有非<code>CLH</code>队列的线程参与竞争，所以非公平就体现在这里，非<code>CLH</code>队列线程与<code>CLH</code>队列线程竞争，各凭本事，不会因为你是<code>CLH</code>队列的线程，排了很久的队，就把锁让给你。</p><p>###ReentrantLock</p><p><a href="https://baijiahao.baidu.com/s?id=1702822534980452383&wfr=spider&for=pc">通俗易懂的ReentrantLock (baidu.com)</a></p><p><code>ReentrantLock</code>是可重入的互斥锁，虽然具有与<code>synchronized</code>相同功能，但是会比<code>synchronized</code>更加灵活（<strong>具有更多的方法</strong>）。</p><p><code>ReentrantLock</code>底层基于<code>AbstractQueuedSynchronizer</code>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span>;</span><br><span class="line"><span class="comment">//Sync继承AbstractQueuedSynchronizer提供释放资源的实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>在<code>ReentrantLock</code>中，它对<code>AbstractQueuedSynchronizer</code>的<code>state</code>状态值定义为线程获取该锁的重入次数，<code>state</code>状态值为<code>0</code>表示当前没有被任何线程持有，<code>state</code>状态值为<code>1</code>表示被其他线程持有，因为支持可重入，如果是持有锁的线程，再次获取同一把锁，直接成功，并且<code>state</code>状态值<code>+1</code>，线程释放锁<code>state</code>状态值<code>-1</code>，同理重入多次锁的线程，需要释放相应的次数。</p><p>非公平锁：</p><p><img src="https://pics6.baidu.com/feed/a686c9177f3e6709581b64d256bf3435f8dc5500.png@f_auto?token=1d12d8cf05396c6754a46ea388cb64d8" alt="img"></p><p>公平锁：</p><p><img src="https://pics2.baidu.com/feed/2fdda3cc7cd98d10f8dd53e64d4713067aec9059.png@f_auto?token=5888e9e64916dbe648c26b01794cd812" alt="img"></p><p>使用<code>独占方式</code>获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源，就会标记是这个线程获取到了，其他线程再尝试操作state获取资源时会发现当前该资源不是自己持有的，就会在获取失败后被阻塞。</p><p>对应的<code>共享方式</code>的资源与具体线程是不相关的，当多个线程去请求资源时通过CAS方式竞争获取资源，当一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源还能满足它的资源，则当前线程只需要使用CAS方式进行获取即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryAcquire 具体的子类去实现，并维护state的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 如果失败标记状态，入队</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryRelease 具体的子类是实现，并设置state的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 调用unpark唤醒队列的线程，并调用tryAcquire尝试，看是否需要，如果不需要，继续挂起</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于ReentrantLock可重入性的实现"><a href="#关于ReentrantLock可重入性的实现" class="headerlink" title="关于ReentrantLock可重入性的实现"></a>关于ReentrantLock可重入性的实现</h4><p>ReentrantLock具备可重入的能力，即同一个线程多次获取锁，不引起阻塞。</p><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁。</p><p><strong>设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</strong></p><p>###乐观锁与悲观锁</p><p>####互斥锁</p><p>多个线程访问一个对象的时候，会想到使用互斥锁进行协调，互斥锁是一个<strong>悲观</strong>锁，也就是操作系统会认为，<strong>如果不严格的同步线程调用，那么一定会产生异常</strong>，所以这里进行锁定，是的对象只供一个线程调用。</p><p>缺陷：1.可能大部分请求都是读操作，不需要上锁。</p><p>​2.可能同步代码块执行的耗时远远小于线程切换的耗时。</p><p>####CAS</p><p>需要实现原子性，各个架构都提供了CAS原子性的实现方法，可以直接让CPU实现，不用锁来实现线程同步。</p><p>所谓CSA 就是线程调用的时候先判断old值是不是符合期望，如果符合就修改，这时另外的线程来访问就需要进行自旋(次数可配置，默认10,<strong>自旋不需要加载上下文</strong>)，等到这个线程结束。这里就是所谓的<strong>乐观锁</strong>，其实乐观锁不是一种锁，是靠原子性实现的一种<strong>无锁同步机制</strong>，只是名字相对于悲观锁被沿用了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0894ed62c588d7ad6dbd4640d407e356.png" alt="img"></p><p>####偏向锁</p><p><strong>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价</strong>（偏向于这个线程）</p><p>适用场景：始终只有一个线程在执行代码块，在它没有执行完释放锁之前，没有其它线程去执行同步快，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁, 导致stop the word操作，有锁竞争时会降低效率，应当禁用。</p><p>####轻量级锁</p><p><strong>轻量级锁是指当锁是偏向锁的时候，被另一个线程锁访问，偏向锁就会升级为轻量级锁，其他线程会通过自选的形式尝试获取锁，不会阻塞，提高性能。</strong></p><p>####重量级锁</p><p><strong>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</strong></p><p>###公平锁与非公平锁</p><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p><p>优点：所有的线程都能得到资源，不会饿死在队列中。<br>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</p><p>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><p>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。<br>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</p><h3 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h3><ul><li><strong>共享锁：</strong>对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后。</li><li><strong>排他锁：</strong>对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作。</li></ul><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><strong>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</strong></p><p><strong>如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适用使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cpu的线程又不能获取到cpu，造成cpu的浪费。</strong></p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>简单点说就是确保读的时候读到的是最新值，保证线程可见性。</p><p>两个特性：<code>内存可见性</code>、<code>禁止重排序</code></p><p>禁止重排序：<strong>不管是编译器还是JVM还是CPU，都会对一些指令进行重排序，目的是为了提高程序运行的速度，提高程序的性能，毫无疑问，在单线程下没毛病，多线程就似乎生病了。</strong></p><p>volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层是基于<code>内存屏障</code>实现的。</p><ul><li>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</li><li>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步，所以就不会有可见性问题。<ul><li>对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；</li><li>对 volatile 变量进行读操作时，会在写操作后加一条 load 屏障指令，从主内存中读取共享变量；</li></ul></li></ul><p>很难做出准确、全面的评价，例如 “X 总是比 Y 快”，尤其是对 JVM 内在的操作而言。（例如，某些情况下 JVM 也许能够完全删除锁机制，这使得我们难以抽象地比较 <code>volatile</code> 和 <code>synchronized</code> 的开销。）就是说，在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。</p><p>关于禁止重排序的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来一波双重校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Test</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;<span class="comment">// 多了一层判断，不让每次进来都阻塞，提高了性能</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// instance类变量前面修饰的volatile？是吧？</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    <span class="comment">//1. 分配对象的内存空间 </span></span><br><span class="line">ctorInstance(memory);  <span class="comment">//2. 初始化对象 </span></span><br><span class="line">instance = memory;     <span class="comment">//3. 设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure><p>上面三个指令中，步骤2依赖步骤1，但是步骤3不依赖步骤2，所以JVM可能针对他们进行指令重拍序优化，重排后的指令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    <span class="comment">//1. 分配对象的内存空间 </span></span><br><span class="line">instance = memory;     <span class="comment">//3. 设置instance指向刚分配的内存地址</span></span><br><span class="line">ctorInstance(memory);  <span class="comment">//2. 初始化对象 </span></span><br></pre></td></tr></table></figure><p>这样优化之后，内存的初始化被放到了instance分配内存地址的后面，这样的话当线程1执行步骤3这段赋值指令后，刚好有另外一个线程2进入getInstance方法判断instance不为null，这个时候线程2拿到的instance对应的内存其实还未初始化，这个时候拿去使用就会导致出错。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>假如想实现<u><strong>每一个线程都有自己的专属本地变量</strong></u>该如何解决呢？ JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。</p><p>ThreadLocal叫做<em><strong>线程变量</strong></em>，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是<strong>隔离</strong>的，也就是说该变量是当前线程独有的变量，<code>不存在多线程间共享的问题</code>。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p><p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即<code>变量在线程间隔离而在方法或类间共享的场景</code>。</p><p>一句话理解ThreadLocal，threadlocl是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry<code>（threadlocl,value）</code>，虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在<strong>同一个线程中这个value变量地址是一样</strong>的。</p><p>使用时可以使用<code>get（）</code>和<code>set（）</code>方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><p>####关于ThreadLocal的内存泄漏</p><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的<code>弱</code>引用,而 value 是<code>强</code>引用。如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。</p><p>ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用<code>remove()</code>方法。</p><p>###Synchonized</p><p>synchronized的用处是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p><p>synchronized的作用主要有三个：</p><ol><li>原子性：确保线程<code>互斥地访问</code>同步代码；</li><li>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要<code>重新从主内存</code>中load操作或assign操作初始化变量值” 来保证的；</li><li>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；</li></ol><p>synchronized的3种使用方式：</p><ul><li>修饰实例方法：作用于当前实例加锁</li><li>修饰静态方法：作用于当前类对象加锁</li><li>修饰代码块：指定加锁对象，对给定对象加锁</li></ul><p>synchronized关键字不能继承，当然子类调用父类同步方法也是同步的。</p><p>synchronized在JVM里的实现都是基于进入和退出<code>Monitor对象</code>来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p><p><code>MonitorEnter</code>指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；</p><p><code>MonitorExit</code>指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；</p><p>什么是Monitor？可以把它理解为 一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</p><p>###ThreadLocal与Synchronized的区别</p><p>ThreadLocal和Synchonized都用于解决多线程并发访问。</p><p>但是ThreadLocal与synchronized有本质的区别：</p><p>1、Synchronized用于线程间的数据<code>共享</code>，而ThreadLocal则用于线程间的数据<code>隔离</code>。</p><p>2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的<code>副本</code>，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享,而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据<code>共享</code>。</p><p>###ReentrantReadWriteLock</p><p>ReentrantReadWriteLock称为读写锁，它提供一个<code>读锁</code>，支持<code>多个线程共享同一把锁</code>。它也提供了一把<code>写锁</code>，是<code>独占锁</code>，和其他读锁或者写锁互斥，表明只有一个线程能持有锁资源。通过两把锁的协同工作，能够最大化的提高读写的性能，特别是读多写少的场景，而往往大部分的场景都是读多写少的。</p><h4 id="可重入性的实现"><a href="#可重入性的实现" class="headerlink" title="可重入性的实现"></a>可重入性的实现</h4><p>这个问题需要引入两个概念，<code>锁升级</code>，<code>锁降级</code>。</p><ul><li>锁升级：从读锁变成写锁。</li><li>锁降级：从写锁变成读锁。</li></ul><p>重入时锁升级不支持：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</p><p>重入时锁降级支持：持有写锁的情况下去获取读锁，造成只有当前线程会持有读锁，因为写锁会互斥其他的锁</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>缓存：缓存更新时，是先清缓存还是先更新数据库？</p><p>先清缓存：可能造成<code>刚清理缓存还没有更新数据库</code>，高并发下，<code>其他线程</code>直接<code>查询了数据库过期数据到缓存中</code>，这种情况非常严重，直接导致<code>后续所有的请求缓存和数据库不一致</code>。<br>先更新据库：可能造成<code>刚更新数据库，还没清空缓存就有线程从缓存拿到了旧数据</code>，这种情况概率比较小，影响范围有限，只对这一次的查询结果有问题。</p><p>显而易见，通常情况下，<code>先更新数据库，然后清空缓存</code>。</p><p>###线程</p><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p>结论：t.join()方法会使所有线程都暂停并等待t的执行完毕后再执行</p><p>实现: join之所以可以实现线程等待是因为调用wait方法。而wait方法会让<strong>当前线程</strong>陷入等待。注意，是<strong>当前线程</strong>！在执行tA.join()这句代码的时候，当前线程是main主线程。在tA.join()当中的wait(0)方法是让<code>main线程陷入了无尽的等待</code>中。正是因为如此，在tA.join()之前的代码都会正常从上往下执行，而在tA.join()之后的代码都随着main线程陷入等待而无法继续执行。这样便达到了网上说的 “t.join()方法会使所有线程都暂停并等待t的执行完毕后再执行”。同时<code>线程在die的时候会自动调用自身的notifyAll方法，来释放所有因为该锁陷入等待的资源和锁</code>。</p><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>场景</p><p>在主线程中开启多个线程去<code>并行</code>任务，并且<code>主线程</code>需要<code>等待所有子线程执行完毕</code>后再进行汇总的场景.</p><p>原理</p><p>首先状态变量state：state用来表示计数器当前的值，当线程调用CountDownLatch对象的await方法后，当前线程会被阻塞，直到下面的情况之一发生才返回：</p><p>当所有线程都调用了CountDownLatch对象的countDown(减去计数器的值)方法后，也就是计数器的值为0时：其他线程调用了当前线程的interrupt()方法中断了当前线程，当前线程就会抛出InterruptedException异常。</p><h4 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h4><p>一种在物理处理器上实现多线程执行的技术。也就是让每一个处理器核心模拟多个处理器,使得一个处理器可以同时执行多个线程.</p><h4 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h4><p>虚拟线程是一种编程模型或操作系统的概念，用于实现并发执行和任务调度</p><h3 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h3><p><strong>Java锁机制可归为Sychornized锁和Lock锁两类。Synchronized是基于JVM来保证数据同步的，而Lock则是硬件层面，依赖特殊的CPU指令来实现数据同步的。</strong></p><ul><li>Synchronized是一个非公平、悲观、独享、互斥、可重入的重量级锁。</li><li>ReentrantLock是一个默认非公平但可实现公平的、悲观、独享、互斥、可重入、重量级锁。</li><li>ReentrantReadWriteLock是一个默认非公平但可实现公平的、悲观、写独享、读共享、读写、可重入、重量级锁。</li></ul><h3 id="线程池（高频）"><a href="#线程池（高频）" class="headerlink" title="线程池（高频）"></a>线程池（高频）</h3><p>为什么使用线程池？</p><ul><li><strong>降低资源消耗</strong>。通过<code>重复利用</code>已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以<code>不需要等到线程创建</code>就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是<code>稀缺资源</code>，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><p>有哪些线程池？</p><p><strong>newFixedThreadPool</strong>（固定线程池）、<strong>newSingleThreadExecutor</strong>（单个线程的线程池）、<strong>newCachedThreadPool</strong>（缓存线程的线程池）、<strong>newScheduledThreadPool</strong>（带定时器的线程池）</p><p>####线程池参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><ul><li>corePoolSize：核心线程数线程数定义了<code>最小可以同时运行</code>的线程数量</li><li>maximumPoolSize：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为<code>最大线程数</code></li><li>keepAliveTime：当线程数大于<code>核心线程数</code>时，多余的<code>空闲线程存活的最长时间</code></li><li>TimeUnit：时间单位</li><li>BlockingQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li><li>ThreadFactory：线程工厂，用来创建线程，一般默认即可</li><li>RejectedExecutionHandler：拒绝策略</li></ul><p><img src="https://camo.githubusercontent.com/8224f690269cfcd9af6899b48f681e098b42c4adfda3a5c6527990f97ee4631f/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545372542412542462545372541382538422545362542312541302545352538462538322545362539352542302545352538352542332545372542332542422d4a676a6c57552e706e67" alt="线程池参数关系"></p><h4 id="核心线程和普通线程的区别"><a href="#核心线程和普通线程的区别" class="headerlink" title="核心线程和普通线程的区别"></a>核心线程和普通线程的区别</h4><ul><li><strong>创建和销毁</strong>：核心线程在线程池<code>初始化时就会创建</code>，并且不会被销毁；普通线程在需要处理任务时动态创建，并在任务执行完毕后根据空闲时间和线程池配置决定是否<code>销毁</code>。</li><li><strong>空闲处理</strong>：核心线程处于空闲状态时不会被销毁，保持线程池的基本线程数量；普通线程在空闲一定时间后，根据线程池配置和策略决定是否销毁，以控制线程池的大小。</li><li><strong>任务处理</strong>：核心线程主要用于处理短时间的任务，保证任务能够得到及时处理；普通线程用于处理任务数量超过核心线程数的情况，根据任务的到达率动态调整线程池的大小。</li></ul><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><ul><li>AbortPolicy：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li>CallerRunsPolicy：调用执行自己的线程运行任务(主线程同时处理自己的任务和该任务)。但是这种策略会<code>降低</code>对于新任务<code>提交速度</code>，<code>影响</code>程序的<code>整体性能</code>。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你任务<code>不能丢弃任何一个任务请求</code>的话，你可以选择这个策略。（说白了，谁管理任务的，谁就负责帮忙）</li><li>DiscardPolicy：不处理新任务，直接丢弃掉。</li><li>DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。</li></ul><h4 id="线程池线程数量"><a href="#线程池线程数量" class="headerlink" title="线程池线程数量"></a>线程池线程数量</h4><p>如何确定？</p><ol><li>一般来说，如果是CPU密集型应用，则线程池大小设置为N+1。（N是CPU的核心数）</li><li>一般来说，如果是IO密集型应用，则线程池大小设置为2N+1。</li><li>在IO优化中，线程等待时间（IO时间）所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越少线程。这样的估算公式可能更适合：最佳线程数目 &#x3D; （（线程等待时间+线程CPU时间）&#x2F;线程CPU时间 ）* CPU数目</li></ol><h4 id="线程池中线程的状态"><a href="#线程池中线程的状态" class="headerlink" title="线程池中线程的状态"></a>线程池中线程的状态</h4><p>线程池中的线程可以处于不同的状态，常见的线程状态包括：</p><ol><li><strong>New（新建）</strong>：线程被<code>创建</code>但还未开始执行。</li><li><strong>Runnable（可运行）</strong>：线程处于<code>就绪</code>状态，等待分配CPU时间片来执行。在可运行状态下，线程可能正在执行，也可能正在等待执行。</li><li><strong>Blocked（阻塞）</strong>：线程被<code>阻塞</code>，无法继续执行。常见的阻塞原因包括等待锁、等待输入&#x2F;输出、等待其他线程通知等。</li><li><strong>Waiting（等待）</strong>：线程处于<code>等待</code>状态，等待其他线程的特定条件满足。进入等待状态的线程需要其他线程的显式通知来唤醒。</li><li><strong>Timed Waiting（计时等待）</strong>：线程处于计时等待状态，等待一定的时间或者等待特定的条件满足。</li><li><strong>Terminated（终止）</strong>：线程已经执行完毕，终止运行。</li></ol><p>等待锁或者io操作就是阻塞,等待特定条件满足就是等待.<code>阻塞是被动的,等待是主动的</code>,等待需要其他程序来唤醒.</p><h4 id="shutdown和shutdownNow"><a href="#shutdown和shutdownNow" class="headerlink" title="shutdown和shutdownNow"></a>shutdown和shutdownNow</h4><p>shutdown是等待所有线程执行任务完毕之后退出。</p><p>shutdownNow是立马中断所有的线程，关闭线程池。</p><h4 id="submit和execute"><a href="#submit和execute" class="headerlink" title="submit和execute"></a>submit和execute</h4><p>区别：</p><ol><li>execute只能提交Runnable类型的任务，没有返回值，而submit既能提交Runnable类型任务也能提交Callable类型任务，返回Future类型。</li><li>execute方法提交的任务异常是直接抛出的，而submit方法是是捕获了异常的，当调用FutureTask的get方法时，才会抛出异常。</li></ol><img src="https://img-blog.csdnimg.cn/img_convert/801f9038979ba89405141affda430217.png" alt="img" style="zoom:50%;" /><p>execute是Executor接口的方法，而submit是ExecutorService的方法，并且ExecutorService接口继承了Executor接口。</p><h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>一个线程池实现,专门用于分治任务,也就是将一个大任务分为多个并行执行的小任务.同时采用了<code>工作窃取</code>的算法,也就是在自己任务队列空的时候,去别的任务队列获取任务执行,实现一种负载均衡.</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue</p><p>BlockingQueue 继承了 Queue 接口，是队列的一种。</p><p>阻塞队列（BlockingQueue）是一个在队列基础上又支持了两个附加操作的队列，两个附加操作（实现阻塞功能）:</p><p>支持阻塞的<code>插入方法put</code>: 队列满时，队列会<code>阻塞插入元素的线程</code>，直到队列不满。<br>支持阻塞的<code>移除方法take</code>: 队列空时，获取元素的线程会<code>等待队列变为非空</code></p><ul><li><p>BlockingQueue实现被设计为主要用于生产者 - 消费者队列</p></li><li><p>BlockingQueue实现是线程安全的。所有排队方法使用内部锁或其他形式的并发控制在<code>原子</code>上实现其效果。</p></li><li><p>BlockingQueue方法有四种形式，具有不同的操作方式，不能立即满足，但可能在将来的某个时间点满足：</p><ul><li>一个抛出异常</li><li>返回一个特殊值（ null或false ，具体取决于操作）</li><li>第三个程序将无限期地阻止当前线程，直到操作成功为止</li><li>在放弃之前只有给定的最大时限。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于JAVA对象</title>
      <link href="/2023/04/27/%E5%85%B3%E4%BA%8EJAVA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/04/27/%E5%85%B3%E4%BA%8EJAVA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>###JAVA对象结构</p><p>由三部分构成：对象头、实例数据、填充字节。为了保证高效，对象头被设计的很小，并且是非结构化的。</p><p>填充字节是为了满足JAVA 的对象大小都是8bit的n倍设置的。</p><p>对象头包含了Mark Word和Class Point信息：其中Class point是当前对象类型的指针，指向了当前对象所在方法区的类型数据；Mark Word存储了和当前对象运行时状态有关的数据，比如锁状态标志，HashCode等</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7ad6ab858b2d759bc1be9c5852ed4704.png" alt="img"></p><ol><li>实例数据：存放类的属性数据信息，包括父类的属性信息；</li><li>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐；</li><li>对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</li></ol><p>对象头的最后两位存储了锁的标志位，01是初始状态，未加锁，其对象头里存储的是对象本身的哈希码，随着锁级别的不同，对象头里会存储不同的内容。偏向锁存储的是当前占用此对象的线程ID；而轻量级则存储指向线程栈中锁记录的指针。从这里我们可以看到，“锁”这个东西，可能是个锁记录+对象头里的引用指针（判断线程是否拥有锁时将线程的锁记录地址和对象头里的指针地址比较)，也可能是对象头里的线程ID（判断线程是否拥有锁时将线程的ID和对象头里存储的线程ID比较）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>序列化</title>
      <link href="/2023/04/26/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/04/26/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>###序列化</p><ol><li><p>所有需要<strong>网络传输</strong>的对象都需要实现序列化接口，建议所有的javaBean都实现Serializable接口。</p></li><li><p>对象的<strong>类名</strong>、<strong>实例变量</strong>（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。</p></li><li><p>如果想让某个变量不被序列化，使用<strong>transient</strong>修饰。</p></li><li><p>序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。</p></li><li><p><strong>反序列化时必须有序列化对象的class文件</strong>。</p></li><li><p>当通过文件、网络来读取序列化后的对象时，必须按照实际写入的<strong>顺序读取</strong>。</p></li><li><p>单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。</p></li><li><p>同一对象<strong>序列化多次</strong>，<strong>只有第一次序列化为二进制流，以后都只是保存序列化编号</strong>，不会重复序列化。</p></li><li><p>建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。</p></li></ol><p><a href="https://juejin.cn/post/6844903848167866375#heading-9">java序列化，看这篇就够了 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA泛型擦除</title>
      <link href="/2023/04/26/JAVA%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
      <url>/2023/04/26/JAVA%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<p>###JAVA泛型擦除原理</p><p>Java 的泛型是伪泛型，因为在编译期间所有的泛型信息都会被擦除掉，泛型擦除具体来说就是在编译成字节码时首先进行类型检查，接着进行类型擦除（即<code>所有类型参数都用他们的限定类型替换，包括类、变量和方法</code>，如果类型变量<code>没有限定</code>，可以替换为<code>Object</code>，如果类型变量有限定则原始类型就用第一个边界的类型来替换，譬如 class Prd&lt;T extends Comparable &amp; Serializable&gt; {} 的原始类型就是 Comparable），接着如果类型擦除和多态性发生冲突时就在子类中生成<u>桥方法</u>解决，接着如果调用泛型方法的返回类型被擦除则在调用该方法时插入强制类型转换。</p><p>先检查再擦除的类型检查是<strong>针对引用</strong>的，用引用调用泛型方法就会对这个引用调用的方法进行类型检测而无关它真正引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList2.add(<span class="string">&quot;123&quot;</span>); <span class="comment">//编译通过 </span></span><br><span class="line">arrayList2.add(<span class="number">123</span>);<span class="comment">//编译错误</span></span><br><span class="line"><span class="type">String</span> <span class="variable">object2</span> <span class="operator">=</span> arrayList2.get(<span class="number">0</span>); <span class="comment">//返回类型是 String </span></span><br><span class="line"></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">arrayList3.add(<span class="string">&quot;123&quot;</span>); <span class="comment">//编译通过 </span></span><br><span class="line">arrayList3.add(<span class="number">123</span>); <span class="comment">//编译通过 </span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object3</span> <span class="operator">=</span> arrayList3.get(<span class="number">0</span>); <span class="comment">//返回类型是 Object</span></span><br></pre></td></tr></table></figure><p>####关于桥方法</p><p>假设有一个超类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(T value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is Parent Class, value is &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及一个子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is Child class, value is &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在Parent类编译之后，方法上的泛型没有了，参数类型变成了Object类型，那就出现问题了，子类中的sayHello方法是重写了父类的方法，但是根据Java重写的要求，方法的参数类型必须是一致的，那这样不就出错了吗？<strong>子类是String但是父类是Object</strong>。结果是可以正常运行。</p><p>原因是编译器为了维护这种重写的原则，在Child类中自动生成了一个桥方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Object value)</span></span><br><span class="line">&#123;</span><br><span class="line">    sayHello((String) value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个桥方法实际上就是对超类中sayHello(Obejct)的<strong>重写</strong>。这样做的原因是，当程序员在子类中写下以下这段代码的时候，本意是对超类中的<strong>同名方法进行重写</strong>，但因为超类发生了类型擦除，所以实际上<strong>并没有重写成功</strong>，因此加入了桥方法的机制来避免类型擦除与多态发生冲突。</p><p>java代码中，判断两个方法是否是同一个方法是根据方法的签名来决定的，方法的签名是不包含方法的返回值的，也就是“方法签名&#x3D;方法名+参数”。如果我们代码里面这样写确实是冲突的Java无法找到是哪一个方法，Java虚拟机中的方法签名规则是不同的，其“方法签名&#x3D;方法名+参数+返回值”，所以他是能正确区分两个方法的，所以字节码中是允许存在上面这种情况的。</p><h4 id="关于泛型擦除与多态性的冲突"><a href="#关于泛型擦除与多态性的冲突" class="headerlink" title="关于泛型擦除与多态性的冲突"></a>关于泛型擦除与多态性的冲突</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    GenericClass&lt;String&gt; genericObj = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;();<span class="comment">// 冲突 ，编译时报错</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    genericObj.doSomething(obj); <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明 <code>GenericClass&lt;String&gt; genericObj = new GenericClass&lt;&gt;();</code> 时，泛型类型参数 <code>T</code> 被指定为 <code>String</code>，因此 <code>genericObj</code> 的实例只能接受 <code>String</code> 类型的参数。然而，在 <code>genericObj.doSomething(obj);</code> 这行代码中，<code>obj</code> 的类型是 <code>Object</code>，不是 <code>String</code>，因此会导致编译错误。</p><h4 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h4><p>多态性有以下几个优点：</p><ol><li>可扩展性：多态性允许在不修改现有代码的情况下添加<code>新的子类</code>。这样可以更方便地扩展系统功能。</li><li>灵活性：通过多态性，可以在运行时<code>动态地确定对象的实际类型</code>，并调用相应类型的方法。这样可以根据实际需要灵活地处理对象。</li><li>可替换性：多态性允许将一个子类对象赋值给父类引用变量，这样可以在不改变代码的情况下，通过替换不同的子类对象来改变程序的行为。</li><li>可维护性：多态性可以使代码更加模块化和可维护，因为每个子类都可以独立地实现自己的行为，不会对其他代码产生影响。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>套接字</title>
      <link href="/2023/04/26/%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
      <url>/2023/04/26/%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>###套接字解决的问题</p><p>应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过<strong>同一个TCP协议端口传输数据</strong>。为了<strong>区别不同的应用程序进程和连接</strong>，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字 (Socket)的接口，区分不同应用程序进程间的网络通信和连接。</p><p>###套接字详细</p><p>生成套接字，主要有3个参数：通信的<strong>目的IP地址</strong>、使用的<strong>传输层协议</strong>(TCP或UDP)和使用的<strong>端口号</strong>。通过将这3个参数结合起来，与一个“插座”Socket绑定，应用层就可以和传输层通过套接字接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的<strong>并发</strong>服务。</p><p>Socket可以看成在两个程序进行通讯连接中的一个端点，一个程序将一段信息写入Socket中，该Socket将这段信息发送给另外一个Socket中，使这段信息能传送到其他程序中。要通过互联网进行通信，至少需要一对套接字，一个运行于客户机端，称之为ClientSocket，另一个运行于服务器端，称之为serverSocket。根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为<strong>三个步骤</strong>：服务器监听，客户端请求，连接确认。   </p><p><strong>服务器监听</strong>：是服务器端套接字并不定位具体的客户端套接字，而是处于<strong>等待连接</strong>的状态，实时<strong>监控网络状态</strong>。</p><p><strong>客户端请求</strong>：是指<strong>由客户端的套接字提出连接请求</strong>，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先<strong>描述它要连接的服务器的套接字</strong>，指出服务器端套接字的<strong>地址和端口号</strong>，然后就向服务器端套接字提出<strong>连接请求</strong>。</p><p><strong>连接确认</strong>：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就<strong>响应</strong>客户端套接字的请求，建立一个<strong>新的线程</strong>，把服务器端套接字的<strong>描述发给客户端</strong>，一旦客户端<strong>确认</strong>了此描述，连接就建立好了。而服务器端套接字<strong>继续处于监听</strong>状态，继续接收其他客户端套接字的连接请求。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/04/25/%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/04/25/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>###反射</p><p>反射是什么：正常我们创建一个类，是在类中定义属性和方法，从而能够编译得到一个class文件，那么，将这个过程反过来，我们已知class类，来获取该类的属性和方法，就是反射。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>###单例模式</p><p>单例模式是Java中最简单的设计模式之一。这种类型的设计模式属于创建者模式，它提供了一种访问对象的最佳方式。</p><p>这种设计模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>#####分类</p><p>饿汉式：类加载就会导致该单实例对象被创建。</p><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时被创建。</p><p>####优缺点</p><p>优点：1.内存中只有一个实例，减少了内存的开销。2.避免对资源的多重占用(比如写文件操作)。</p><p>缺点：没有接口，不能继承。</p><p>主要用于解决一个<strong>全局使用的类</strong>被频繁的创建与销毁的问题。</p><p>#####注：</p><p>1.单例类只能有一个实例。2.单例类必须自己创建自己的实例。3.单例类必须给所有其他对象提供这一实例。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>#####饿汉式</p><p>1.静态成员变量，就是在构造的时候自己直接创建好唯一静态实例，并提供调用该实例的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungryChinese</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungryChinese</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在该类中创建一个该类的对象供外界去使用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">HungryChinese</span> <span class="variable">hungryChinese</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungryChinese</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//提供一个公共的访问方式，让外界获取hungryChinese对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungryChinese <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungryChinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HungryChineseTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取单例类的对象，因为对象私有，只能通过方法去获取</span></span><br><span class="line">        <span class="type">HungryChinese</span> <span class="variable">instance</span> <span class="operator">=</span> HungryChinese.getInstance();</span><br><span class="line">        <span class="type">HungryChinese</span> <span class="variable">instance1</span> <span class="operator">=</span> HungryChinese.getInstance();</span><br><span class="line">        <span class="comment">//判断是否为同一个对象</span></span><br><span class="line">        System.out.println(instance.equals(instance1));<span class="comment">// ture</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.静态代码块方式，类加载的时候执行静态语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungryChinese2</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法，为了不让外界创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungryChinese2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明该类类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungryChinese2 hungryChinese2;<span class="comment">//初始值为null</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//静态代码块中赋值类被加载的时候执行</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        hungryChinese2 = <span class="keyword">new</span> <span class="title class_">HungryChinese2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//对外提供的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungryChinese2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungryChinese2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HungryChinese2Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HungryChinese2</span> <span class="variable">instance</span> <span class="operator">=</span> HungryChinese2.getInstance();</span><br><span class="line">        <span class="type">HungryChinese2</span> <span class="variable">instance1</span> <span class="operator">=</span> HungryChinese2.getInstance();</span><br><span class="line">        System.out.println(instance.equals(instance1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####懒汉式</p><p>1.线程不安全的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法，为了不让外界创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明LazyMan类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan instance;<span class="comment">//只是声明了该类的对象，没有赋初始值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//对外提供访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断instance是否为null,如果为null,说明还没有创建LazyMan类的对象</span></span><br><span class="line">        <span class="comment">//如果没有，创建一个并返回；如果有，直接返回</span></span><br><span class="line">        <span class="comment">//线程不安全，多线程下会创建多个对象</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazyManTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> LazyMan.getInstance();</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance1</span> <span class="operator">=</span> LazyMan.getInstance();</span><br><span class="line">        System.out.println(instance.equals(instance1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> <span class="comment">// 多添加一个synchronized关键字，保证同一时刻最多只有一个线程能执行该方法</span></span><br><span class="line"><span class="comment">//或者下面这种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure><p>可以解决线程安全的问题，不过在多个方法访问时会出现排队的情况。</p><p>3.双重检查法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;<span class="comment">//volatile是Java中的关键字，用来修饰会被不同线程访问和修改的变量。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    singleton =  <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.枚举法(推荐)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量（共享对象），以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>在享元模式中，对象分为两个部分：内部状态（Intrinsic State）和外部状态（Extrinsic State）。内部状态是对象共享的部分，它不依赖于对象的上下文，并且在对象创建后不会发生变化。外部状态是对象特定的部分，它取决于对象的上下文并可能在运行时发生变化。</p><p>享元模式的核心思想是将内部状态和外部状态分离。内部状态存储在享元对象内部，并可共享。外部状态由客户端传递给享元对象，因此客户端负责管理外部状态。通过这种方式，可以在多个对象之间共享相同的内部状态，而每个对象都可以具有不同的外部状态。</p><p>String的字符串常量池就用到了这一点，当创建一个字符串时，如果字符串常量池中已经存在相同内容的字符串对象，则直接返回该对象的引用，而不会创建新的对象。同时也可以自己将字符串添加到常量池。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客设置和一些命令</title>
      <link href="/2023/04/24/%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/04/24/%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>静态网页是通过git的repository代理的，地址是sounio.github.io。博客框架使用了hexo。主题使用了next。</p><p>Git命令</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">以下命令将本地的 master 分支推送到 origin 主机的 master 分支。</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数：</span><br><span class="line">git push --force origin master</span><br><span class="line"></span><br><span class="line">删除主机的分支可以使用 --delete 参数，以下命令表示删除 origin 主机的 master 分支：</span><br><span class="line">git push origin --delete master</span><br><span class="line"></span><br><span class="line">git add --all 将当前目录下包括子目录下所有改动的文件提交到暂存区，注意只包括改动的文件，不改动的不会放到缓存区，还会把删除的文件也提交进去</span><br><span class="line"></span><br><span class="line">git commit 用于将工作区内容霍暂区内容提交到版本库</span><br><span class="line"></span><br><span class="line">git commit -m [message]</span><br></pre></td></tr></table></figure><p>hexo博客框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo g 编译生成</span><br><span class="line"></span><br><span class="line">hexo clean 清理缓存</span><br><span class="line"></span><br><span class="line">hexo d 部署</span><br><span class="line"></span><br><span class="line">hexo new &quot;name&quot; 新建一个name页</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo博客框架、Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
